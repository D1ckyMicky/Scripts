--[[
    Neverlose.cc Style UI Library for Severe
    Version: 16.1 (Config System - Hotfix)
    Developer: Gemini AI & Dicky_Micky_

    - [FIX] Changed config file extension from .json to .cfg to avoid 'banned file extension' error in Severe.
    - [NEW] Implemented the core config saving/loading system using the file system.
    - [NEW] The library now automatically creates a 'NL_Configs' folder on startup.
    - [NEW] On first launch (or if no configs exist), a 'default.cfg' config is created with the default values of all UI elements.
    - [NEW] The 'Configs' tab now dynamically loads and displays all .cfg files found in the 'NL_Configs' folder.
    - [UPDATE] The 'Save' button now saves the current UI values to the selected config file.
    - [UPDATE] The 'Load' button now loads UI values from the selected config file.
    - [INTERNAL] Removed 'DummyData' in favor of the new dynamic system.
]]

local Library = {}

--================================================================
--[[ PRIVATE: CORE PROPERTIES & CONFIGURATION ]]
--================================================================

Library.AnimationState = {} -- Хранилище для состояний анимации

Library.Window = {
    Visible = true, X = 400, Y = 200, Width = 750, Height = 620,
    SidebarWidth = 187, HeaderHeight = 65, IsDragging = false,
    ActiveTab = "", PanelOverlap = 4,
    LastRenderedTab = "" -- << ДОБАВЬТЕ ЭТУ СТРОКУ
}

Library.ConfigFolderPath = "NL_Configs" -- Новая папка для конфигов

Library.Themes = {
    Blue = {
        Name = "Blue", IsPreset = true,
        Fonts = { Title = 2, Main = 1, Size = 14, TitleSize = 27, TabSize = 18, TabHeaderSize = 12 },
        Colors = { 
            MainBackground = {6, 9, 17, 245}, SectionBackground = {3, 11, 23, 255}, SidebarBackground = {11, 20, 33, 204}, 
            Separator = {0, 18, 32, 255}, Accent = {24, 165, 232, 255}, DarkBlue = {3, 23, 51, 255}, 
            DarkGray = {24, 24, 24, 255}, LightGray = {77, 77, 76, 255}, 
            TextPrimary = {234, 239, 245, 255}, TextSecondary = {160, 181, 197, 255}, 
            TabHeader = {100, 120, 140, 255}, GlowColor = {7, 70, 99, 255}, GlowAccent = {24, 165, 232, 255},
            TextLight = {234, 239, 245, 255}, TextDark = {60, 60, 60, 255}
        },
        Transparency = { Solid = 0.9, ActiveTabHighlight = 0.28 },
        Rounding = { Window = 8, Section = 6, Element = 4, Button = 5 }, IconSize = 16
    },
    Black = {
        Name = "Black", IsPreset = true,
        Fonts = { Title = 2, Main = 1, Size = 14, TitleSize = 27, TabSize = 18, TabHeaderSize = 12 },
        Colors = { 
            MainBackground = {6, 6, 9, 247}, SectionBackground = {0, 3, 5, 255}, SidebarBackground = {14, 16, 19, 230}, 
            Separator = {11, 11, 11, 255}, Accent = {72, 130, 255, 255}, DarkBlue = {10, 11, 19, 255}, 
            DarkGray = {24, 24, 24, 255}, LightGray = {77, 77, 76, 255}, 
            TextPrimary = {234, 239, 245, 255}, TextSecondary = {181, 181, 194, 255}, 
            TabHeader = {111, 120, 130, 255}, GlowColor = {22, 39, 77, 255}, GlowAccent = {72, 130, 255, 255},
            TextLight = {234, 239, 245, 255}, TextDark = {60, 60, 60, 255}
        },
        Transparency = { Solid = 0.9, ActiveTabHighlight = 0.28 },
        Rounding = { Window = 8, Section = 6, Element = 4, Button = 5 }, IconSize = 16
    },
    White = {
        Name = "White", IsPreset = true,
        Fonts = { Title = 2, Main = 1, Size = 14, TitleSize = 27, TabSize = 18, TabHeaderSize = 12 },
        Colors = { 
            MainBackground = {250, 250, 255, 247}, SectionBackground = {244, 244, 244, 255}, SidebarBackground = {240, 240, 240, 230}, 
            Separator = {200, 200, 200, 255}, Accent = {24, 165, 232, 255}, DarkBlue = {220, 220, 220, 255}, 
            DarkGray = {165, 165, 165, 255}, LightGray = {120, 120, 120, 255}, 
            TextPrimary = {10, 10, 10, 255}, TextSecondary = {60, 60, 60, 255}, 
            TabHeader = {100, 100, 100, 255}, GlowColor = {7, 70, 99, 255}, GlowAccent = {24, 165, 232, 255},
            TextLight = {234, 239, 245, 255}, TextDark = {60, 60, 60, 255}
        },
        Transparency = { Solid = 0.9, ActiveTabHighlight = 0.28 },
        Rounding = { Window = 8, Section = 6, Element = 4, Button = 5 }, IconSize = 16
    }
}
Library.ActiveTheme = Library.Themes.Blue
Library.CustomThemeCounter = 0
Library.TempTheme = nil
Library.PreEditThemeName = nil

Library.UI = { TabGroups = {}, Sections = {}, Values = {}, DrawingObjects = {}, Popups = {} }

local drag_offset = {x = 0, y = 0}
local was_left_pressed = false
local is_dragging_something = false
local lastToggleTime = 0
local toggleDelay = 0.5
local SCRIPT_PREFIX = "[NL UI Lib] "

--================================================================
--[[ PRIVATE: COLOR CONVERSION FUNCTIONS (PLACEHOLDERS) ]]
--================================================================

-- ВСТАВЬТЕ СЮДА ФУНКЦИЮ _HSVtoRGB
function Library:_HSVtoRGB(h, s, v)
    local r, g, b

    local i = math.floor(h * 6)
    local f = h * 6 - i
    local p = v * (1 - s)
    local q = v * (1 - f * s)
    local t = v * (1 - (1 - f) * s)

    i = i % 6

    if i == 0 then r, g, b = v, t, p
    elseif i == 1 then r, g, b = q, v, p
    elseif i == 2 then r, g, b = p, v, t
    elseif i == 3 then r, g, b = p, q, v
    elseif i == 4 then r, g, b = t, p, v
    elseif i == 5 then r, g, b = v, p, q
    end

    -- Возвращаем таблицу {r, g, b} со значениями от 0 до 255,
    -- как того требует библиотека Drawing.
    return { r * 255, g * 255, b * 255 }
end

-- ВСТАВЬТЕ СЮДА ФУНКЦИЮ _RGBtoHSV
function Library:_RGBtoHSV(r, g, b, a)
    r, g, b = r / 255, g / 255, b / 255
    local max, min = math.max(r, g, b), math.min(r, g, b)
    local h, s, v = max, max, max

    local d = max - min
    s = max == 0 and 0 or d / max

    if max == min then
        h = 0
    else
        if max == r then
            h = (g - b) / d + (g < b and 6 or 0)
        elseif max == g then
            h = (b - r) / d + 2
        elseif max == b then
            h = (r - g) / d + 4
        end
        h = h / 6
    end

    return h, s, v, (a or 255) / 255
end

--================================================================
--[[ PRIVATE: HELPER FUNCTIONS ]]
--================================================================

function Library:_CreateDrawingObject(class)
    local success, object = pcall(Drawing.new, class)
    if not success then warn(SCRIPT_PREFIX .. "Failed to create Drawing object of type:", class); return nil end
    table.insert(self.UI.DrawingObjects, object)
    return object
end

function Library:_DeepCopy(original)
    local copy = {}
    for k, v in pairs(original) do
        if type(v) == "table" then
            v = self:_DeepCopy(v)
        end
        copy[k] = v
    end
    return copy
end

function Library:_DarkenColor(color, factor)
    factor = factor or 0.3
    return { math.max(0, math.floor(color[1] * factor)), math.max(0, math.floor(color[2] * factor)), math.max(0, math.floor(color[3] * factor)), color[4] or 255 }
end

function Library:_IsThemeLight(theme)
    local bg = theme.Colors.MainBackground
    if not bg then return false end
    -- Using luminance formula to determine brightness
    local brightness = (bg[1] * 0.299 + bg[2] * 0.587 + bg[3] * 0.114)
    return brightness > 150 -- Threshold for what is considered a "light" background
end

function Library:_getAvatarThumbnail(userId)
    local url = string.format("https://thumbnails.roblox.com/v1/users/avatar-headshot?userIds=%d&size=420x420&format=Png&isCircular=true", userId)
    local success, response = pcall(function() return httpget(url, "application/json") end)
    if success then
        local decoded = JSONDecode(response)
        if decoded and decoded.data and decoded.data[1] and decoded.data[1].imageUrl then
            return decoded.data[1].imageUrl
        end
    end
    return nil
end

function Library:_SafeNumber(value, default) return type(value) == "number" and value or (default or 0) end
function Library:_IsPointInRegion(x, y, region)
    if not region or not region.x1 or not region.x2 or not region.y1 or not region.y2 then return false end
    return x >= self:_SafeNumber(region.x1, 0) and x <= self:_SafeNumber(region.x2, 0) and y >= self:_SafeNumber(region.y1, 0) and y <= self:_SafeNumber(region.y2, 0)
end
function Library:_SetVisibility(object, visible) if object and object.Visible ~= visible then object.Visible = visible end end
function table.find(tbl, value) for i, v in ipairs(tbl) do if v == value then return i end end; return nil end

-- Вставьте эту новую функцию в раздел PRIVATE: HELPER FUNCTIONS
function Library:_CleanupDrawingObjects(tbl)
    for _, v in pairs(tbl) do
        if type(v) == 'table' then
            if v.Remove and type(v.Remove) == 'function' then
                -- Это объект отрисовки, удаляем его
                pcall(v.Remove, v)
            else
                -- Это обычная таблица, идем глубже
                self:_CleanupDrawingObjects(v)
            end
        end
    end
end

-- Новая функция для плавной смены цвета (анимации)
function Library:_LerpColor(from, to, alpha)
    -- Проверка на случай, если одна из таблиц некорректна
    if type(from) ~= "table" or type(to) ~= "table" then 
        return to or from or {0, 0, 0, 255} 
    end

    -- Интерполяция с использованием значений по умолчанию для каждого канала
    local r = (from[1] or 0) + ((to[1] or 0) - (from[1] or 0)) * alpha
    local g = (from[2] or 0) + ((to[2] or 0) - (from[2] or 0)) * alpha
    local b = (from[3] or 0) + ((to[3] or 0) - (from[3] or 0)) * alpha
    local a = (from[4] or 255) + ((to[4] or 255) - (from[4] or 255)) * alpha
    
    return {r, g, b, a}
end

-- Новая функция для отрисовки подсказки у кнопки Save
function Library:_RenderSaveTooltip()
    local tooltip = self.UI.Core.SaveTooltip
    local saveBtn = self.UI.Core.HeaderButtons.Save
    local isVisible = saveBtn.IsHovered
    local theme = self.ActiveTheme

    self:_SetVisibility(tooltip.Background, isVisible)
    self:_SetVisibility(tooltip.Border, isVisible)
    self:_SetVisibility(tooltip.ConfigName, isVisible)
    self:_SetVisibility(tooltip.Author, isVisible)

    if isVisible then
        self:_AnimateAndApplyColor(tooltip.Background, theme.Colors.SectionBackground)
        self:_AnimateAndApplyColor(tooltip.Border, theme.Colors.Separator)
        self:_AnimateAndApplyColor(tooltip.ConfigName, theme.Colors.TextPrimary)
        self:_AnimateAndApplyColor(tooltip.Author, theme.Colors.TextSecondary)
    
        local configName = self.UI.Core.ConfigsTab.LoadedConfigName
        if configName == "" then configName = "default" end
        tooltip.ConfigName.Text = "Config \"" .. configName .. "\""
        tooltip.Author.Text = "Author: " .. (self.UI.Core.PlayerDisplayName.Text or "user")

        local padding = 16
        local configNameWidth = tooltip.ConfigName.TextBounds and tooltip.ConfigName.TextBounds.x or 100
        local authorWidth = tooltip.Author.TextBounds and tooltip.Author.TextBounds.x or 100
        local tooltipW = math.max(configNameWidth, authorWidth) + padding
        local tooltipH = 50

        local btnRegion = saveBtn.ClickRegion
        local tooltipX, tooltipY = btnRegion.x2 + 10, btnRegion.y1

        tooltip.Background.Position = {tooltipX, tooltipY}
        tooltip.Background.Size = {tooltipW, tooltipH}
        tooltip.Border.Position = {tooltipX, tooltipY}
        tooltip.Border.Size = {tooltipW, tooltipH}
        tooltip.ConfigName.Position = {tooltipX + (padding / 2), tooltipY + 8}
        tooltip.Author.Position = {tooltipX + (padding / 2), tooltipY + 28}
        
        self:_RenderGlowEffect(tooltip.Glow, tooltipX, tooltipY, tooltipW, tooltipH, tooltip.Background.Rounding, theme.Colors.GlowColor)
    else
        self:_HideGlowEffect(tooltip.Glow)
    end
end

function Library:_AnimateAndApplyColor(drawingObject, targetColor, masterOpacity)
    if not drawingObject or type(targetColor) ~= "table" then return end

    local state = self.AnimationState[drawingObject]
    if not state then
        state = { CurrentColor = self:_DeepCopy(targetColor) }
        self.AnimationState[drawingObject] = state
    end

    local speed_value = self.UI.Values["AboutAnimationSpeed"] or 1.6 
    local animationSpeed = speed_value / 16.0

    state.CurrentColor = self:_LerpColor(state.CurrentColor, targetColor, animationSpeed)

    local color = state.CurrentColor
    if color then
        drawingObject.Color = {color[1], color[2], color[3]}
        local baseOpacity = (color[4] or 255) / 255
        
        --[[ НОВОЕ: Умножаем на общую прозрачность ]]
        masterOpacity = (masterOpacity == nil) and 1 or masterOpacity
        drawingObject.Opacity = baseOpacity * masterOpacity
    end
end

function Library:_GetTextColorForBackground(backgroundColor)
    local theme = self.ActiveTheme
    if not backgroundColor or type(backgroundColor) ~= "table" then
        return theme.Colors.TextLight 
    end
    
    local brightness = (backgroundColor[1] * 0.299 + backgroundColor[2] * 0.587 + backgroundColor[3] * 0.114)
    
    return brightness > 140 and theme.Colors.TextDark or theme.Colors.TextLight
end

--================================================================
--[[ PRIVATE: GLOW EFFECT HELPERS ]]
--================================================================

function Library:_Internal_CreateGlowSet(zIndex, count)
    local glowSet = {}
    count = count or 20
    for i = 1, count do
        local glowSquare = self:_CreateDrawingObject("Square")
        if glowSquare then
            glowSquare.Filled = true
            glowSquare.zIndex = zIndex - i
            table.insert(glowSet, glowSquare)
        end
    end
    return glowSet
end

function Library:_RenderGlowEffect(glowSet, x, y, width, height, rounding, targetColor, sides)
    if not glowSet or #glowSet == 0 or not targetColor then return end
    
    -- Используем первый квадрат в наборе как ключ для нашего хранилища состояний
    local stateHolder = glowSet[1]

    -- Получаем или создаем состояние для этого ключа
    local state = self.AnimationState[stateHolder]
    if not state then
        state = { CurrentColor = self:_DeepCopy(targetColor) }
        self.AnimationState[stateHolder] = state
    end
    
    -- Анимируем цвет
    state.CurrentColor = self:_LerpColor(state.CurrentColor, targetColor, 0.1)
    local animatedColor = state.CurrentColor
    
    sides = sides or {top=true, bottom=true, left=true, right=true}
    local glowColorRGB = {animatedColor[1], animatedColor[2], animatedColor[3]}
    local glowOpacity = (animatedColor[4] or 255) / 255

    for i, glowSquare in ipairs(glowSet) do
        local alpha_factor = 0.24 * math.exp(-0.24 * i)
        local spread = i * 0.6
        local glowX, glowY, glowW, glowH = x, y, width, height

        if sides.left then glowX = x - spread; glowW = glowW + spread; end
        if sides.right then glowW = glowW + spread; end
        if sides.top then glowY = y - spread; glowH = glowH + spread; end
        if sides.bottom then glowH = glowH + spread; end
        
        glowSquare.Position = {glowX, glowY}
        glowSquare.Size = {glowW, glowH}
        glowSquare.Rounding = rounding + spread -- Теперь 'rounding' это корректное число
        glowSquare.Color = glowColorRGB
        glowSquare.Opacity = glowOpacity * alpha_factor
        self:_SetVisibility(glowSquare, true)
    end
end

function Library:_HideGlowEffect(glowSet)
    if not glowSet then return end
    for _, glowSquare in ipairs(glowSet) do
        self:_SetVisibility(glowSquare, false)
    end
end


--================================================================
--[[ PRIVATE: INITIALIZATION & CORE UI ]]
--================================================================

function Library:_InitializeCoreUI()
    local UI = self.UI; UI.Core = {}

    UI.Core.Sidebar = { Drawing = self:_CreateDrawingObject("Square"), Glow = self:_Internal_CreateGlowSet(0) }
    UI.Core.RightPanel = { Drawing = self:_CreateDrawingObject("Square"), Glow = self:_Internal_CreateGlowSet(0) }
    UI.Core.VerticalSeparator = self:_CreateDrawingObject("Square")
    UI.Core.SidebarHeaderSeparator = self:_CreateDrawingObject("Square")
    UI.Core.RightPanelHeaderSeparator = self:_CreateDrawingObject("Square")
    
    if UI.Core.Sidebar.Drawing then UI.Core.Sidebar.Drawing.Filled = true; UI.Core.Sidebar.Drawing.zIndex = 1; UI.Core.Sidebar.Drawing.Rounding = self.ActiveTheme.Rounding.Window; end
    if UI.Core.RightPanel.Drawing then UI.Core.RightPanel.Drawing.Filled = true; UI.Core.RightPanel.Drawing.zIndex = 1; UI.Core.RightPanel.Drawing.Rounding = self.ActiveTheme.Rounding.Window; end
    if UI.Core.VerticalSeparator then UI.Core.VerticalSeparator.Filled = true; UI.Core.VerticalSeparator.zIndex = 3; end
    if UI.Core.SidebarHeaderSeparator then UI.Core.SidebarHeaderSeparator.Filled = true; UI.Core.SidebarHeaderSeparator.zIndex = 2; end
    if UI.Core.RightPanelHeaderSeparator then UI.Core.RightPanelHeaderSeparator.Filled = true; UI.Core.RightPanelHeaderSeparator.zIndex = 2; end

    UI.Core.Title = self:_CreateDrawingObject("Text"); UI.Core.Title2 = self:_CreateDrawingObject("Text"); UI.Core.Title3 = self:_CreateDrawingObject("Text")
    if UI.Core.Title then UI.Core.Title.Font = self.ActiveTheme.Fonts.Title; UI.Core.Title.Size = self.ActiveTheme.Fonts.TitleSize; UI.Core.Title.Text = "NEVERLOSE"; UI.Core.Title.Center = false; UI.Core.Title.Outline = false; UI.Core.Title.zIndex = 5; end
    if UI.Core.Title2 then UI.Core.Title2.Font = self.ActiveTheme.Fonts.Title; UI.Core.Title2.Size = self.ActiveTheme.Fonts.TitleSize; UI.Core.Title2.Text = "NEVERLOSE"; UI.Core.Title2.Center = false; UI.Core.Title2.Outline = false; UI.Core.Title2.zIndex = 4; end
    if UI.Core.Title3 then UI.Core.Title3.Font = self.ActiveTheme.Fonts.Title; UI.Core.Title3.Size = self.ActiveTheme.Fonts.TitleSize; UI.Core.Title3.Text = "NEVERLOSE"; UI.Core.Title3.Center = false; UI.Core.Title3.Outline = false; UI.Core.Title3.zIndex = 3; end

    UI.Core.SidebarBottomCircle = self:_CreateDrawingObject("Circle"); if UI.Core.SidebarBottomCircle then UI.Core.SidebarBottomCircle.Filled = false; UI.Core.SidebarBottomCircle.Thickness = 3; UI.Core.SidebarBottomCircle.zIndex = 6; UI.Core.SidebarBottomCircle.Radius = 28; end
    UI.Core.PlayerDisplayName = self:_CreateDrawingObject("Text"); if UI.Core.PlayerDisplayName then UI.Core.PlayerDisplayName.Font = self.ActiveTheme.Fonts.Main; UI.Core.PlayerDisplayName.Size = self.ActiveTheme.Fonts.Size + 2; UI.Core.PlayerDisplayName.Text = ""; UI.Core.PlayerDisplayName.Center = false; UI.Core.PlayerDisplayName.Outline = false; UI.Core.PlayerDisplayName.zIndex = 7; end
    UI.Core.TillLabel = self:_CreateDrawingObject("Text"); if UI.Core.TillLabel then UI.Core.TillLabel.Font = self.ActiveTheme.Fonts.Main; UI.Core.TillLabel.Size = self.ActiveTheme.Fonts.Size; UI.Core.TillLabel.Text = "Till:"; UI.Core.TillLabel.Center = false; UI.Core.TillLabel.Outline = false; UI.Core.TillLabel.zIndex = 7; end
    UI.Core.ForeverLabel = self:_CreateDrawingObject("Text"); if UI.Core.ForeverLabel then UI.Core.ForeverLabel.Font = self.ActiveTheme.Fonts.Main; UI.Core.ForeverLabel.Size = self.ActiveTheme.Fonts.Size; UI.Core.ForeverLabel.Text = " Forever"; UI.Core.ForeverLabel.Center = false; UI.Core.ForeverLabel.Outline = false; UI.Core.ForeverLabel.zIndex = 7; end

    UI.Core.HeaderButtons = {
        Save = { Background = self:_CreateDrawingObject("Square"), Border = self:_CreateDrawingObject("Square"), Label = self:_CreateDrawingObject("Text"), Icon = self:_CreateDrawingObject("Image"), ClickRegion = {}, ClickTime = 0, IsHovered = false, CurrentColor = {0,0,0,0} },
        ViewESP = { Background = self:_CreateDrawingObject("Square"), Border = self:_CreateDrawingObject("Square"), Label = self:_CreateDrawingObject("Text"), ClickRegion = {}, ClickTime = 0, IsOpen = false },
        CreateNew = { Background = self:_CreateDrawingObject("Square"), Border = self:_CreateDrawingObject("Square"), Label = self:_CreateDrawingObject("Text"), Icon = self:_CreateDrawingObject("Image"), ClickRegion = {}, ClickTime = 0 },
        Settings = { Icon = self:_CreateDrawingObject("Image"), ClickRegion = {} }
    }
    
    UI.Core.SaveTooltip = {
        Background = self:_CreateDrawingObject("Square"),
        Border = self:_CreateDrawingObject("Square"),
        Glow = self:_Internal_CreateGlowSet(49),
        ConfigName = self:_CreateDrawingObject("Text"),
        Author = self:_CreateDrawingObject("Text")
    }
    
    self.UI.Popups.About = { IsOpen = false }

    local function setupHeaderButton(button, text, has_icon)
        if button.Background then button.Background.Filled = true; button.Background.zIndex = 2; button.Background.Rounding = self.ActiveTheme.Rounding.Button; end
        if button.Border then button.Border.Filled = false; button.Border.Thickness = 1; button.Border.zIndex = 3; button.Border.Rounding = self.ActiveTheme.Rounding.Button; end
        if button.Label then button.Label.Font = self.ActiveTheme.Fonts.Main; button.Label.Size = self.ActiveTheme.Fonts.Size; button.Label.Text = text; button.Label.Center = false; button.Label.Outline = false; button.Label.zIndex = 4; end
        if button.Icon and has_icon then button.Icon.Size = {13.33, 13.33}; button.Icon.zIndex = 5; button.Icon.Visible = true;
        else if button.Icon then button.Icon.Visible = false end end
    end
    setupHeaderButton(UI.Core.HeaderButtons.Save, " Save", true)
    setupHeaderButton(UI.Core.HeaderButtons.ViewESP, "View ESP", false)
    setupHeaderButton(UI.Core.HeaderButtons.CreateNew, " Create new", true)
    
    if UI.Core.HeaderButtons.Save.Icon then UI.Core.HeaderButtons.Save.Icon.Url = "https://s6.imgcdn.dev/Y4Sudt.png"; end
    if UI.Core.HeaderButtons.CreateNew.Icon then UI.Core.HeaderButtons.CreateNew.Icon.Url = "https://i.imgur.com/plus-sign-icon.png"; end
    if UI.Core.HeaderButtons.Settings.Icon then UI.Core.HeaderButtons.Settings.Icon.Url = "https://s6.imgcdn.dev/Y4SCjT.png"; UI.Core.HeaderButtons.Settings.Icon.Size = {20, 20}; UI.Core.HeaderButtons.Settings.Icon.zIndex = 5; end

    local tooltip = UI.Core.SaveTooltip
    if tooltip.Background then tooltip.Background.Filled = true; tooltip.Background.zIndex = 50; tooltip.Background.Rounding = self.ActiveTheme.Rounding.Element; end
    if tooltip.Border then tooltip.Border.Filled = false; tooltip.Border.Thickness = 1; tooltip.Border.zIndex = 51; tooltip.Border.Rounding = self.ActiveTheme.Rounding.Element; end
    if tooltip.ConfigName then tooltip.ConfigName.Font = self.ActiveTheme.Fonts.Main; tooltip.ConfigName.Size = self.ActiveTheme.Fonts.Size + 2; tooltip.ConfigName.zIndex = 51; end
    if tooltip.Author then tooltip.Author.Font = self.ActiveTheme.Fonts.Main; tooltip.Author.Size = self.ActiveTheme.Fonts.Size; tooltip.Author.zIndex = 51; end

    UI.Core.ViewESPPanel = self:_CreateDrawingObject("Square"); if UI.Core.ViewESPPanel then UI.Core.ViewESPPanel.Filled = true; UI.Core.ViewESPPanel.zIndex = 1; UI.Core.ViewESPPanel.Rounding = self.ActiveTheme.Rounding.Window; end
    UI.Core.ViewESPImage = self:_CreateDrawingObject("Image"); if UI.Core.ViewESPImage then UI.Core.ViewESPImage.zIndex = 2; UI.Core.ViewESPImage.Visible = false; UI.Core.ViewESPImage.Url = "https://s6.imgcdn.dev/Y4wqGT.jpg"; UI.Core.ViewESPImage.Rounding = self.ActiveTheme.Rounding.Window - 2; end
    UI.Core.ViewESPPanelBorder = self:_CreateDrawingObject("Square"); if UI.Core.ViewESPPanelBorder then UI.Core.ViewESPPanelBorder.Filled = false; UI.Core.ViewESPPanelBorder.Thickness = 1; UI.Core.ViewESPPanelBorder.zIndex = 3; UI.Core.ViewESPPanelBorder.Rounding = self.ActiveTheme.Rounding.Window; end

    self:_InitializeAboutWindow()
    self:_InitializePlayerESPSettingsPopup()
    self:_InitializeEditStyleWindow()
    self:_InitializeColorPickerWindow()
    self:_InitializeConfigsTab()

    local Players = game:FindService("Players")
    if Players and Players.localPlayer then
        local localPlayerName = Players.localPlayer.Name
        UI.Core.PlayerDisplayName.Text = localPlayerName
        if UI.Core.AboutWindow.InfoRegisteredToValue then UI.Core.AboutWindow.InfoRegisteredToValue.Text = " " .. localPlayerName end
        local userId = Players.localPlayer.UserId
        if userId and userId > 0 then
            local avatarUrl; pcall(function() avatarUrl = self:_getAvatarThumbnail(userId) end)
            if avatarUrl then
                UI.Core.SidebarAvatar = self:_CreateDrawingObject("Image")
                if UI.Core.SidebarAvatar then UI.Core.SidebarAvatar.Size = {56, 56}; UI.Core.SidebarAvatar.Position = {0, 0}; UI.Core.SidebarAvatar.Opacity = 1; UI.Core.SidebarAvatar.Visible = true; UI.Core.SidebarAvatar.zIndex = 4; UI.Core.SidebarAvatar.Url = avatarUrl; UI.Core.SidebarAvatar.Rounding = 28; end
            end
        end
    end
    
    UI.Core.HeaderButtons.Save.CurrentColor = self:_DeepCopy(self.ActiveTheme.Colors.MainBackground)
end

function Library:_InitializeAboutWindow()
    local about = {}; self.UI.Core.AboutWindow = about; local about_z = 32
    about.StyleCircles = {}
    about.HoveredThemeCircle = { Name = nil, HoverStartTime = 0 } -- For tooltip
    about.Background = self:_CreateDrawingObject("Square"); if about.Background then about.Background.Filled = true; about.Background.zIndex = 30; about.Background.Rounding = self.ActiveTheme.Rounding.Section; end
    about.Border = self:_CreateDrawingObject("Square"); if about.Border then about.Border.Filled = false; about.Border.Thickness = 1; about.Border.zIndex = 31; about.Border.Rounding = self.ActiveTheme.Rounding.Section; end
    about.Glow = self:_Internal_CreateGlowSet(29)
    about.HeaderIcon = self:_CreateDrawingObject("Image"); if about.HeaderIcon then about.HeaderIcon.Url = "https://s6.imgcdn.dev/Y4SCjT.png"; about.HeaderIcon.Size = {16, 16}; about.HeaderIcon.zIndex = about_z; end
    about.HeaderTitle = self:_CreateDrawingObject("Text"); if about.HeaderTitle then about.HeaderTitle.Font = self.ActiveTheme.Fonts.Main; about.HeaderTitle.Size = self.ActiveTheme.Fonts.Size + 2; about.HeaderTitle.Text = "About Neverlose"; about.HeaderTitle.Center = false; about.HeaderTitle.zIndex = about_z; end
    about.CloseButton = { Line1 = self:_CreateDrawingObject("Line"), Line2 = self:_CreateDrawingObject("Line"), ClickRegion = {} }; if about.CloseButton.Line1 then about.CloseButton.Line1.Thickness = 2; about.CloseButton.Line1.zIndex = about_z; end; if about.CloseButton.Line2 then about.CloseButton.Line2.Thickness = 2; about.CloseButton.Line2.zIndex = about_z; end

    local separatorThickness = 2
    about.Separator1 = self:_CreateDrawingObject("Line"); if about.Separator1 then about.Separator1.Thickness = separatorThickness; about.Separator1.zIndex = 31; end
    about.MainTitle = self:_CreateDrawingObject("Text"); if about.MainTitle then about.MainTitle.Font = self.ActiveTheme.Fonts.Title; about.MainTitle.Size = 24; about.MainTitle.Text = "NEVERLOSE.CC"; about.MainTitle.Center = true; about.MainTitle.zIndex = about_z; end
    about.Separator2 = self:_CreateDrawingObject("Line"); if about.Separator2 then about.Separator2.Thickness = separatorThickness; about.Separator2.zIndex = 31; end

    local function setupInfoText(label_text, value_text)
        local label = self:_CreateDrawingObject("Text"); local value = self:_CreateDrawingObject("Text")
        if label then label.Font = self.ActiveTheme.Fonts.Main; label.Size = self.ActiveTheme.Fonts.Size + 2; label.Text = label_text; label.Center = false; label.zIndex = about_z; end
        if value then value.Font = self.ActiveTheme.Fonts.Main; value.Size = self.ActiveTheme.Fonts.Size + 2; value.Text = value_text; value.Center = false; value.zIndex = about_z; end
        return label, value
    end
    about.InfoVersionLabel, about.InfoVersionValue = setupInfoText("Version:", " 2.0.0")
    about.InfoBuildDateLabel, about.InfoBuildDateValue = setupInfoText("Build date:", " Dec 30 2020")
    about.InfoBuildTypeLabel, about.InfoBuildTypeValue = setupInfoText("Build type:", " Release")
    about.InfoRegisteredToLabel, about.InfoRegisteredToValue = setupInfoText("Registered to:", "")
    about.InfoSubscriptionLabel, about.InfoSubscriptionValue = setupInfoText("Subscription till:", " FOREVER")

    about.FooterText = self:_CreateDrawingObject("Text"); if about.FooterText then about.FooterText.Font = self.ActiveTheme.Fonts.Main; about.FooterText.Size = self.ActiveTheme.Fonts.Size - 1; about.FooterText.Text = "neverlose.cc © 2025"; about.FooterText.Center = true; about.FooterText.zIndex = about_z; end
    about.Separator3 = self:_CreateDrawingObject("Line"); if about.Separator3 then about.Separator3.Thickness = separatorThickness; about.Separator3.zIndex = 31; end
    about.CreditText = self:_CreateDrawingObject("Text"); if about.CreditText then about.CreditText.Font = self.ActiveTheme.Fonts.Main; about.CreditText.Size = self.ActiveTheme.Fonts.Size; about.CreditText.Text = "UI by Dicky_Micky_"; about.CreditText.Center = true; about.CreditText.zIndex = about_z; end

    about.AutoSaveToggle = self:_Internal_CreateToggle({ id = "AboutAutoSave", Name = "Auto Save", Default = false, zIndex = about_z });
    about.DpiScaleDropdown = self:_Internal_CreateDropdown({ id = "AboutDpiScale", Name = "Dpi Scale", Options = {"100%", "125%", "150%"}, Default = "100%", Size = {width = 100, height = 25}, zIndex = about_z });
    about.AnimationSpeedSlider = self:_Internal_CreateSlider({ id = "AboutAnimationSpeed", Name = "Animation Speed", Min = 0, Max = 5, Default = 1.6, Increment = 0.1, zIndex = about_z });

    about.StyleLabel, _ = setupInfoText("Style", "");

    -- Tooltip initialization
    local tooltip_z = 60
    about.Tooltip = {
        Background = self:_CreateDrawingObject("Square"),
        Text = self:_CreateDrawingObject("Text")
    }
    if about.Tooltip.Background then about.Tooltip.Background.Filled = true; about.Tooltip.Background.zIndex = tooltip_z; about.Tooltip.Background.Rounding = self.ActiveTheme.Rounding.Element; end
    if about.Tooltip.Text then about.Tooltip.Text.Font = self.ActiveTheme.Fonts.Main; about.Tooltip.Text.Size = self.ActiveTheme.Fonts.Size; about.Tooltip.Text.Center = false; about.Tooltip.Text.zIndex = tooltip_z + 1; end

    self:_RebuildStyleCircles()
    self.UI.Values["AboutSelectedStyle"] = "Blue"
end

function Library:_RebuildStyleCircles()
    local about = self.UI.Core.AboutWindow
    local about_z = 32

    for _, circle in ipairs(about.StyleCircles) do
        if circle.Circle then circle.Circle:Remove() end
        if circle.Border then circle.Border:Remove() end
        if circle.Inner then circle.Inner:Remove() end
        if circle.PlusLine1 then circle.PlusLine1:Remove() end
        if circle.PlusLine2 then circle.PlusLine2:Remove() end
    end
    about.StyleCircles = {}

    local function addCircle(theme, isAddButton)
        local circleObj = {
            Name = theme.Name,
            IsAddButton = isAddButton or false,
            Circle = self:_CreateDrawingObject("Circle"),
            Border = self:_CreateDrawingObject("Circle"),
            ClickRegion = {}
        }

        if circleObj.Circle then 
            circleObj.Circle.Filled = true; 
            circleObj.Circle.zIndex = about_z; 
            circleObj.Circle.Radius = 9; 
            local c = (theme.Colors and theme.Colors.MainBackground) or {40,40,40,255};
            circleObj.Circle.Color = {c[1], c[2], c[3]};
            circleObj.Circle.Opacity = (c[4] or 255) / 255;
        end
        if circleObj.Border then circleObj.Border.Filled = false; circleObj.Border.Thickness = 2; circleObj.Border.zIndex = about_z + 1; circleObj.Border.Radius = 11; circleObj.Border.Visible = false; end

        if isAddButton then
            circleObj.PlusLine1 = self:_CreateDrawingObject("Line"); if circleObj.PlusLine1 then circleObj.PlusLine1.Thickness = 2; circleObj.PlusLine1.zIndex = about_z + 1; end
            circleObj.PlusLine2 = self:_CreateDrawingObject("Line"); if circleObj.PlusLine2 then circleObj.PlusLine2.Thickness = 2; circleObj.PlusLine2.zIndex = about_z + 1; end
        else
            circleObj.Inner = self:_CreateDrawingObject("Circle"); if circleObj.Inner then 
                circleObj.Inner.Filled = true; 
                circleObj.Inner.zIndex = about_z + 1; 
                circleObj.Inner.Radius = 4;
                local c = theme.Colors.Accent;
                circleObj.Inner.Color = {c[1], c[2], c[3]};
                circleObj.Inner.Opacity = (c[4] or 255) / 255;
            end
        end
        table.insert(about.StyleCircles, circleObj)
    end

    local themeOrder = {}
    local customThemeNames = {}
    for themeName, themeData in pairs(self.Themes) do
        if not themeData.IsPreset then
            table.insert(customThemeNames, themeName)
        end
    end
    table.sort(customThemeNames)

    -- Build the final list in display order (which will be rendered right-to-left)
    table.insert(themeOrder, {Name = "Add"}) -- Slot 1
    table.insert(themeOrder, self.Themes.Black) -- Slot 2
    table.insert(themeOrder, self.Themes.White) -- Slot 3
    table.insert(themeOrder, self.Themes.Blue) -- Slot 4
    for _, themeName in ipairs(customThemeNames) do -- Slots 5+
        table.insert(themeOrder, self.Themes[themeName])
    end
    
    for _, themeData in ipairs(themeOrder) do
        addCircle(themeData, themeData.Name == "Add")
    end
end

function Library:_InitializePlayerESPSettingsPopup()
    local popup = {}; self.UI.Popups.PlayerESP = popup; local z = 20
    popup.IsOpen = false; popup.Pos = {x=0, y=0}

    popup.Background = self:_CreateDrawingObject("Square"); if popup.Background then popup.Background.Filled = true; popup.Background.zIndex = z; popup.Background.Rounding = self.ActiveTheme.Rounding.Section; end
    popup.Border = self:_CreateDrawingObject("Square"); if popup.Border then popup.Border.Filled = false; popup.Border.Thickness = 1; popup.Border.zIndex = z + 1; popup.Border.Rounding = self.ActiveTheme.Rounding.Section; end
    popup.Glow = self:_Internal_CreateGlowSet(z - 1)
    popup.Title = self:_CreateDrawingObject("Text"); if popup.Title then popup.Title.Font = self.ActiveTheme.Fonts.Main; popup.Title.Size = self.ActiveTheme.Fonts.Size + 4; popup.Title.Text = "Player ESP Settings"; popup.Title.Center = false; popup.Title.Outline = false; popup.Title.zIndex = z + 2; end
    popup.Separator = self:_CreateDrawingObject("Line"); if popup.Separator then popup.Separator.Thickness = 2; popup.Separator.zIndex = z + 1; end
    popup.BindLabel = self:_CreateDrawingObject("Text"); if popup.BindLabel then popup.BindLabel.Font = self.ActiveTheme.Fonts.Main; popup.BindLabel.Size = self.ActiveTheme.Fonts.Size + 2; popup.BindLabel.Text = "Keybind"; popup.BindLabel.Center = false; popup.BindLabel.Outline = false; popup.BindLabel.zIndex = z + 2; end
    popup.Keybind = self:_Internal_CreateKeybind({ id = "PlayerESPBind", Name = "Bind", Default = "none", zIndex = z + 2 });

    popup.ClickRegion = {}
end

function Library:_InitializeEditStyleWindow()
    local style_window = {}; self.UI.Popups.EditStyle = style_window; local z = 40
    style_window.IsOpen = false
    style_window.IsEditingName = false -- For text input
    style_window.last_key_press_time = 0
    style_window.key_press_delay = 0.08
    style_window.last_key_pressed = ""
    style_window.ColorItems = {}
    style_window.EditingTheme = {}
    style_window.EditingThemeName = "" -- Original name of the theme being edited

    style_window.Background = self:_CreateDrawingObject("Square"); if style_window.Background then style_window.Background.Filled = true; style_window.Background.zIndex = z; style_window.Background.Rounding = self.ActiveTheme.Rounding.Section; end
    style_window.Border = self:_CreateDrawingObject("Square"); if style_window.Border then style_window.Border.Filled = false; style_window.Border.Thickness = 1; style_window.Border.zIndex = z + 1; style_window.Border.Rounding = self.ActiveTheme.Rounding.Section; end
    style_window.Glow = self:_Internal_CreateGlowSet(z - 1)
    
    style_window.HeaderIcon = self:_CreateDrawingObject("Square"); if style_window.HeaderIcon then style_window.HeaderIcon.Filled = true; style_window.HeaderIcon.zIndex = z + 2; style_window.HeaderIcon.Size = {18, 18}; end
    
    style_window.HeaderTitle = self:_CreateDrawingObject("Text"); if style_window.HeaderTitle then style_window.HeaderTitle.Font = self.ActiveTheme.Fonts.Main; style_window.HeaderTitle.Size = self.ActiveTheme.Fonts.Size + 3; style_window.HeaderTitle.Text = "Edit Style"; style_window.HeaderTitle.Center = false; style_window.HeaderTitle.zIndex = z + 2; end
    style_window.CloseButton = { Line1 = self:_CreateDrawingObject("Line"), Line2 = self:_CreateDrawingObject("Line"), ClickRegion = {} }; if style_window.CloseButton.Line1 then style_window.CloseButton.Line1.Thickness = 2; style_window.CloseButton.Line1.zIndex = z + 2; end; if style_window.CloseButton.Line2 then style_window.CloseButton.Line2.Thickness = 2; style_window.CloseButton.Line2.zIndex = z + 2; end
    style_window.Separator1 = self:_CreateDrawingObject("Line"); if style_window.Separator1 then style_window.Separator1.Thickness = 2; style_window.Separator1.zIndex = z + 1; end
    
    style_window.StyleNameLabel = self:_CreateDrawingObject("Text"); if style_window.StyleNameLabel then style_window.StyleNameLabel.Font = self.ActiveTheme.Fonts.Main; style_window.StyleNameLabel.Size = self.ActiveTheme.Fonts.Size + 1; style_window.StyleNameLabel.Text = "Style name"; style_window.StyleNameLabel.Center = false; style_window.StyleNameLabel.zIndex = z + 2; end
    style_window.StyleNameInputBg = self:_CreateDrawingObject("Square"); if style_window.StyleNameInputBg then style_window.StyleNameInputBg.Filled = true; style_window.StyleNameInputBg.zIndex = z + 2; style_window.StyleNameInputBg.Rounding = self.ActiveTheme.Rounding.Element; end
    style_window.StyleNameInputText = self:_CreateDrawingObject("Text"); if style_window.StyleNameInputText then style_window.StyleNameInputText.Font = self.ActiveTheme.Fonts.Main; style_window.StyleNameInputText.Size = self.ActiveTheme.Fonts.Size + 1; style_window.StyleNameInputText.Text = "Style"; style_window.StyleNameInputText.Center = false; style_window.StyleNameInputText.zIndex = z + 3; end
    style_window.StyleNameInputCursor = self:_CreateDrawingObject("Line"); if style_window.StyleNameInputCursor then style_window.StyleNameInputCursor.Thickness = 1.5; style_window.StyleNameInputCursor.zIndex = z + 4; end
    style_window.StyleNameInputClickRegion = {}
    
    style_window.Separator2 = self:_CreateDrawingObject("Line"); if style_window.Separator2 then style_window.Separator2.Thickness = 2; style_window.Separator2.zIndex = z + 1; end
    
    local color_order = {
        "Accent", "GlowColor", "GlowAccent", "DarkBlue", "DarkGray", "LightGray", "MainBackground", "SectionBackground",
        "Separator", "SidebarBackground", "TabHeader", "TextDark", "TextLight"
    }
    for _, colorName in ipairs(color_order) do
        local item = {
            Name = colorName,
            Label = self:_CreateDrawingObject("Text"),
            ColorCircle = self:_CreateDrawingObject("Circle"),
            ColorBorder = self:_CreateDrawingObject("Circle"),
            ClickRegion = {}
        }
        if item.Label then item.Label.Font = self.ActiveTheme.Fonts.Main; item.Label.Size = self.ActiveTheme.Fonts.Size + 1; item.Label.Text = colorName; item.Label.Center = false; item.Label.zIndex = z + 2; end
        if item.ColorCircle then item.ColorCircle.Filled = true; item.ColorCircle.zIndex = z + 2; item.ColorCircle.Radius = 8; end
        if item.ColorBorder then item.ColorBorder.Filled = false; item.ColorBorder.Thickness = 1; item.ColorBorder.zIndex = z + 3; item.ColorBorder.Radius = 9; end
        table.insert(style_window.ColorItems, item)
    end

    style_window.Separator3 = self:_CreateDrawingObject("Line"); if style_window.Separator3 then style_window.Separator3.Thickness = 2; style_window.Separator3.zIndex = z + 1; end

    style_window.RealTimeToggle = self:_Internal_CreateToggle({id = "EditStyleRealTime", Name = "real-time changes", Default = false, zIndex = z + 2})
    style_window.CancelButton = { Background = self:_CreateDrawingObject("Square"), Border = self:_CreateDrawingObject("Square"), IconLine1 = self:_CreateDrawingObject("Line"), IconLine2 = self:_CreateDrawingObject("Line"), Label = self:_CreateDrawingObject("Text"), ClickRegion = {} }
    style_window.SaveButton = { Background = self:_CreateDrawingObject("Square"), Label = self:_CreateDrawingObject("Text"), Icon = self:_CreateDrawingObject("Image"), ClickRegion = {} }

    if style_window.CancelButton.Background then style_window.CancelButton.Background.Filled = true; style_window.CancelButton.Background.zIndex = z + 2; style_window.CancelButton.Background.Rounding = self.ActiveTheme.Rounding.Button; end
    if style_window.CancelButton.Border then style_window.CancelButton.Border.Filled = false; style_window.CancelButton.Border.Thickness = 1; style_window.CancelButton.Border.zIndex = z + 3; style_window.CancelButton.Border.Rounding = self.ActiveTheme.Rounding.Button; end
    if style_window.CancelButton.IconLine1 then style_window.CancelButton.IconLine1.Thickness = 2; style_window.CancelButton.IconLine1.zIndex = z + 4; end
    if style_window.CancelButton.IconLine2 then style_window.CancelButton.IconLine2.Thickness = 2; style_window.CancelButton.IconLine2.zIndex = z + 4; end
    if style_window.CancelButton.Label then style_window.CancelButton.Label.Font = self.ActiveTheme.Fonts.Main; style_window.CancelButton.Label.Size = self.ActiveTheme.Fonts.Size; style_window.CancelButton.Label.Text = "Cancel"; style_window.CancelButton.Label.Center = false; style_window.CancelButton.Label.zIndex = z + 4; end

    if style_window.SaveButton.Background then style_window.SaveButton.Background.Filled = true; style_window.SaveButton.Background.zIndex = z + 2; style_window.SaveButton.Background.Rounding = self.ActiveTheme.Rounding.Button; end
    if style_window.SaveButton.Label then style_window.SaveButton.Label.Font = self.ActiveTheme.Fonts.Main; style_window.SaveButton.Label.Size = self.ActiveTheme.Fonts.Size; style_window.SaveButton.Label.Text = "Save"; style_window.SaveButton.Label.Center = false; style_window.SaveButton.Label.zIndex = z + 3; end
    if style_window.SaveButton.Icon then style_window.SaveButton.Icon.Url = "https://s6.imgcdn.dev/Y4Sudt.png"; style_window.SaveButton.Icon.Size = {13.33, 13.33}; style_window.SaveButton.Icon.zIndex = z + 3; end
end

function Library:_InitializeColorPickerWindow()
    local picker = {}; self.UI.Popups.ColorPicker = picker; local z = 50
    picker.IsOpen = false
    picker.EditingColorName = nil
    picker.Pos = {x=0, y=0}
    
    -- State
    picker.h, picker.s, picker.v, picker.a = 0, 1, 1, 1
    picker.isDraggingHue = false
    picker.isDraggingOpacity = false
    picker.isDraggingSaturationValue = false
    
    -- Drawing Objects
    picker.Background = self:_CreateDrawingObject("Square"); if picker.Background then picker.Background.Filled = true; picker.Background.zIndex = z; picker.Background.Rounding = self.ActiveTheme.Rounding.Window; end
    picker.Border = self:_CreateDrawingObject("Square"); if picker.Border then picker.Border.Filled = false; picker.Border.Thickness = 1; picker.Border.zIndex = z; picker.Border.Rounding = self.ActiveTheme.Rounding.Window; end
    picker.Glow = self:_Internal_CreateGlowSet(z - 1)
    picker.ColorSquare = self:_CreateDrawingObject("Square"); if picker.ColorSquare then picker.ColorSquare.Filled = true; picker.ColorSquare.zIndex = z + 1; picker.ColorSquare.Rounding = self.ActiveTheme.Rounding.Element; end
    picker.GradientOverlay = self:_CreateDrawingObject("Image"); if picker.GradientOverlay then picker.GradientOverlay.Url = "https://pixeldrain.com/api/filesystem/6mLiDUiK"; picker.GradientOverlay.zIndex = z + 2; picker.GradientOverlay.Rounding = self.ActiveTheme.Rounding.Element; end
    picker.SaturationValueNub = self:_CreateDrawingObject("Circle"); if picker.SaturationValueNub then picker.SaturationValueNub.Filled = false; picker.SaturationValueNub.Thickness = 2; picker.SaturationValueNub.Radius = 5; picker.SaturationValueNub.zIndex = z + 3; end
    
    picker.HueSlider = self:_CreateDrawingObject("Image"); if picker.HueSlider then picker.HueSlider.Url = "https://s6.imgcdn.dev/Y40GWM.jpg"; picker.HueSlider.zIndex = z + 1; picker.HueSlider.Rounding = 4; end
    picker.HueNub = self:_CreateDrawingObject("Circle"); if picker.HueNub then picker.HueNub.Filled = true; picker.HueNub.Radius = 7; picker.HueNub.zIndex = z + 3; end
    picker.HueNubBorder = self:_CreateDrawingObject("Circle"); if picker.HueNubBorder then picker.HueNubBorder.Filled = false; picker.HueNubBorder.Thickness = 2; picker.HueNubBorder.Radius = 7; picker.HueNubBorder.zIndex = z + 2; end

    picker.OpacitySliderBackground = self:_CreateDrawingObject("Square"); if picker.OpacitySliderBackground then picker.OpacitySliderBackground.Filled = true; picker.OpacitySliderBackground.zIndex = z + 1; picker.OpacitySliderBackground.Rounding = 4; end
    picker.OpacitySliderGradient = self:_CreateDrawingObject("Image"); if picker.OpacitySliderGradient then picker.OpacitySliderGradient.Url = "https://pixeldrain.com/api/filesystem/2py1vehq"; picker.OpacitySliderGradient.zIndex = z + 2; picker.OpacitySliderGradient.Rounding = 4; end
    picker.OpacityNub = self:_CreateDrawingObject("Circle"); if picker.OpacityNub then picker.OpacityNub.Filled = true; picker.OpacityNub.Radius = 7; picker.OpacityNub.zIndex = z + 3; end
    picker.OpacityNubBorder = self:_CreateDrawingObject("Circle"); if picker.OpacityNubBorder then picker.OpacityNubBorder.Filled = false; picker.OpacityNubBorder.Thickness = 2; picker.OpacityNubBorder.Radius = 7; picker.OpacityNubBorder.zIndex = z + 2; end
    
    -- Click Regions
    picker.SaturationValueRegion = {}
    picker.HueSliderRegion = {}
    picker.OpacitySliderRegion = {}
end

function Library:_InitializeConfigsTab()
    local configs = {}; self.UI.Core.ConfigsTab = configs; local z = 4
    
    configs.LoadedConfigName = ""
    configs.Items = {} -- Will be populated by _RefreshConfigList

    configs.MyItemsLabel = self:_CreateDrawingObject("Text")
    if configs.MyItemsLabel then
        configs.MyItemsLabel.Font = self.ActiveTheme.Fonts.Main; configs.MyItemsLabel.Size = self.ActiveTheme.Fonts.Size + 2; configs.MyItemsLabel.Text = "- My items"; configs.MyItemsLabel.Center = false; configs.MyItemsLabel.zIndex = z;
    end

    configs.Scrollbar = {
        Background = self:_CreateDrawingObject("Square"),
        Nub = self:_CreateDrawingObject("Square")
    }
    if configs.Scrollbar.Background then configs.Scrollbar.Background.Filled = true; configs.Scrollbar.Background.zIndex = z + 2; configs.Scrollbar.Background.Rounding = 2; end
    if configs.Scrollbar.Nub then configs.Scrollbar.Nub.Filled = true; configs.Scrollbar.Nub.zIndex = z + 3; configs.Scrollbar.Nub.Rounding = 2; end

    configs.OptionsPopup = {
        IsOpen = false, ItemIndex = nil, Pos = {x=0, y=0}, ClickRegion = {},
        Background = self:_CreateDrawingObject("Square"),
        Border = self:_CreateDrawingObject("Square"),
        Glow = self:_Internal_CreateGlowSet(z + 10),
        IncludeStyleToggle = self:_Internal_CreateToggle({ id = "ConfigIncludeStyle", Name = "Include Style", Default = true, zIndex = z + 12 })
    }
    if configs.OptionsPopup.Background then configs.OptionsPopup.Background.Filled = true; configs.OptionsPopup.Background.zIndex = z + 11; configs.OptionsPopup.Background.Rounding = self.ActiveTheme.Rounding.Section; end
    if configs.OptionsPopup.Border then configs.OptionsPopup.Border.Filled = false; configs.OptionsPopup.Border.Thickness = 1; configs.OptionsPopup.Border.zIndex = z + 12; configs.OptionsPopup.Border.Rounding = self.ActiveTheme.Rounding.Section; end
end

--================================================================
--[[ PRIVATE: CONFIG SYSTEM ]]
--================================================================

function Library:_GetConfigPath(name)
    return self.ConfigFolderPath .. "\\" .. name .. ".cfg"
end

function Library:_SaveConfig(name)
    local configData = {
        Values = {},
        Themes = {},
        ActiveThemeName = self.ActiveTheme.Name
    }

    for id, value in pairs(self.UI.Values) do
        if not string.find(id, "About") and id ~= "ConfigIncludeStyle" then
            configData.Values[id] = value
        end
    end

    if self.UI.Values["ConfigIncludeStyle"] then
        print(SCRIPT_PREFIX .. "Saving custom themes...") -- Строка для отладки
        for themeName, themeData in pairs(self.Themes) do
            if not themeData.IsPreset then
                -- [ДОБАВЛЕНО] Печатаем в консоль каждую найденную кастомную тему
                print(SCRIPT_PREFIX .. "Found custom theme to save: " .. themeName)
                
                local sanitizedTheme = {
                    Colors = self:_DeepCopy(themeData.Colors),
                    Rounding = self:_DeepCopy(themeData.Rounding),
                    Transparency = self:_DeepCopy(themeData.Transparency),
                    IconSize = themeData.IconSize
                }
                configData.Themes[themeName] = sanitizedTheme
            end
        end
    end

    local success, encodedData = pcall(JSONEncode, configData)
    if success then
        writefile(self:_GetConfigPath(name), encodedData)
        print(SCRIPT_PREFIX .. "Config '" .. name .. "' saved successfully.")
        self.UI.Core.ConfigsTab.NeedsRefresh = true
    else
        warn(SCRIPT_PREFIX .. "Failed to encode config data for '" .. name .. "'.")
    end
end

function Library:_LoadConfig(name)
    local filePath = self:_GetConfigPath(name)
    if not checkfile(filePath) then warn(SCRIPT_PREFIX .. "Config file not found: " .. name); return end
    local success, fileContent = pcall(readfile, filePath)
    if not success or not fileContent then warn(SCRIPT_PREFIX .. "Failed to read config file: " .. name); return end
    local success, decodedData = pcall(JSONDecode, fileContent)
    if not success or not decodedData then warn(SCRIPT_PREFIX .. "Failed to decode config JSON: " .. name); return end

    -- Загружаем темы, восстанавливая их полную структуру
    if decodedData.Themes then
        for themeName, savedThemeData in pairs(decodedData.Themes) do
            local fullTheme = {
                Name = themeName,
                IsPreset = false,
                Colors = savedThemeData.Colors,
                Rounding = savedThemeData.Rounding,
                Transparency = savedThemeData.Transparency,
                IconSize = savedThemeData.IconSize,
                Fonts = self:_DeepCopy(self.Themes.Blue.Fonts) -- Используем шрифты из темы по умолчанию
            }
            self.Themes[themeName] = fullTheme
        end
        self:_RebuildStyleCircles()
    end

    -- Применяем значения и вызываем коллбэки для обновления
    if decodedData.Values then
        for id, value in pairs(decodedData.Values) do
            if self.UI.Values[id] ~= nil then
                self.UI.Values[id] = value
                -- [ДОБАВЛЕНО] Ищем элемент и вызываем его коллбэк для обновления
                for _, section in ipairs(self.UI.Sections) do
                    for _, element in ipairs(section.Elements) do
                        if element.id == id and element.Callback then
                            pcall(element.Callback, value)
                            break
                        end
                    end
                end
            end
        end
    end
    
    if decodedData.ActiveThemeName and self.Themes[decodedData.ActiveThemeName] then
        self.ActiveTheme = self.Themes[decodedData.ActiveThemeName]
        self.UI.Values.AboutSelectedStyle = decodedData.ActiveThemeName
    end

    self.UI.Core.ConfigsTab.LoadedConfigName = name
    print(SCRIPT_PREFIX .. "Config '" .. name .. "' loaded successfully.")
end

function Library:_InitializeConfigsTab()
    local configs = {}; self.UI.Core.ConfigsTab = configs; local z = 4
    
    configs.LoadedConfigName = ""
    configs.Items = {} -- Will be populated by _RefreshConfigList
    configs.NeedsRefresh = false -- [ДОБАВЛЕНО] Флаг для отложенного обновления

    configs.MyItemsLabel = self:_CreateDrawingObject("Text")
    if configs.MyItemsLabel then
        configs.MyItemsLabel.Font = self.ActiveTheme.Fonts.Main; configs.MyItemsLabel.Size = self.ActiveTheme.Fonts.Size + 2; configs.MyItemsLabel.Text = "- My items"; configs.MyItemsLabel.Center = false; configs.MyItemsLabel.zIndex = z;
    end

    configs.Scrollbar = {
        Background = self:_CreateDrawingObject("Square"),
        Nub = self:_CreateDrawingObject("Square")
    }
    if configs.Scrollbar.Background then configs.Scrollbar.Background.Filled = true; configs.Scrollbar.Background.zIndex = z + 2; configs.Scrollbar.Background.Rounding = 2; end
    if configs.Scrollbar.Nub then configs.Scrollbar.Nub.Filled = true; configs.Scrollbar.Nub.zIndex = z + 3; configs.Scrollbar.Nub.Rounding = 2; end

    configs.OptionsPopup = {
        IsOpen = false, ItemIndex = nil, Pos = {x=0, y=0}, ClickRegion = {},
        Background = self:_CreateDrawingObject("Square"),
        Border = self:_CreateDrawingObject("Square"),
        Glow = self:_Internal_CreateGlowSet(z + 10),
        IncludeStyleToggle = self:_Internal_CreateToggle({ id = "ConfigIncludeStyle", Name = "Include Style", Default = true, zIndex = z + 12 })
    }
    if configs.OptionsPopup.Background then configs.OptionsPopup.Background.Filled = true; configs.OptionsPopup.Background.zIndex = z + 11; configs.OptionsPopup.Background.Rounding = self.ActiveTheme.Rounding.Section; end
    if configs.OptionsPopup.Border then configs.OptionsPopup.Border.Filled = false; configs.OptionsPopup.Border.Thickness = 1; configs.OptionsPopup.Border.zIndex = z + 12; configs.OptionsPopup.Border.Rounding = self.ActiveTheme.Rounding.Section; end
end

-- Вставьте эту новую функцию в раздел PRIVATE: CONFIG SYSTEM
function Library:_CreateNewConfig()
    local baseName = "New config"
    local newName = baseName
    local i = 1
    
    while checkfile(self:_GetConfigPath(newName)) do
        newName = baseName .. " (" .. i .. ")"
        i = i + 1
    end
    
    print(SCRIPT_PREFIX .. "Creating new config: " .. newName)
    self:_SaveConfig(newName)
end

function Library:_RefreshConfigList()
    local configs = self.UI.Core.ConfigsTab
    
    for _, item in ipairs(configs.Items) do
        self:_CleanupDrawingObjects(item.Drawing)
    end
    configs.Items = {}

    local files = listfiles(self.ConfigFolderPath)
    if not files then return end

    local localPlayerName = "user"
    local p = game:FindService("Players")
    if p and p.localPlayer then
        localPlayerName = p.localPlayer.Name
    end

    for _, fileName in ipairs(files) do
        if string.sub(fileName, -4) == ".cfg" then
            local configName = string.sub(fileName, 1, -5)
            local item = {
                Name = configName,
                Modified = "N/A",
                Author = localPlayerName,
                Drawing = {
                    Background = self:_CreateDrawingObject("Square"),
                    Border = self:_CreateDrawingObject("Square"), -- [ДОБАВЛЕНО] Объект для обводки
                    Name = self:_CreateDrawingObject("Text"),
                    Modified = self:_CreateDrawingObject("Text"),
                    Author = self:_CreateDrawingObject("Text"),
                    OptionsButton = {
                        Dot1 = self:_CreateDrawingObject("Circle"), Dot2 = self:_CreateDrawingObject("Circle"), Dot3 = self:_CreateDrawingObject("Circle"),
                        ClickRegion = {}
                    },
                    LoadButton = {
                        Background = self:_CreateDrawingObject("Square"),
                        Icon = self:_CreateDrawingObject("Image"),
                        Label = self:_CreateDrawingObject("Text"),
                        ClickRegion = {}
                    },
                    SaveButton = {
                        Background = self:_CreateDrawingObject("Square"), Border = self:_CreateDrawingObject("Square"),
                        Icon = self:_CreateDrawingObject("Image"), Label = self:_CreateDrawingObject("Text"),
                        ClickRegion = {}
                    }
                }
            }
            
            local d = item.Drawing; local z = 4
            if d.Background then d.Background.Filled = true; d.Background.zIndex = z; d.Background.Rounding = self.ActiveTheme.Rounding.Section; end
            -- [ДОБАВЛЕНО] Настройка обводки
            if d.Border then d.Border.Filled = false; d.Border.Thickness = 1; d.Border.zIndex = z + 1; d.Border.Rounding = self.ActiveTheme.Rounding.Section; end
            
            if d.Name then d.Name.Font = self.ActiveTheme.Fonts.Main; d.Name.Size = self.ActiveTheme.Fonts.Size + 2; d.Name.Center = false; d.Name.zIndex = z + 1; end
            if d.Modified then d.Modified.Font = self.ActiveTheme.Fonts.Main; d.Modified.Size = self.ActiveTheme.Fonts.Size; d.Modified.Center = false; d.Modified.zIndex = z + 1; end
            if d.Author then d.Author.Font = self.ActiveTheme.Fonts.Main; d.Author.Size = self.ActiveTheme.Fonts.Size; d.Author.Center = false; d.Author.zIndex = z + 1; end
            
            if d.OptionsButton.Dot1 then d.OptionsButton.Dot1.Filled = true; d.OptionsButton.Dot1.Radius = 1.5; d.OptionsButton.Dot1.zIndex = z + 2; end
            if d.OptionsButton.Dot2 then d.OptionsButton.Dot2.Filled = true; d.OptionsButton.Dot2.Radius = 1.5; d.OptionsButton.Dot2.zIndex = z + 2; end
            if d.OptionsButton.Dot3 then d.OptionsButton.Dot3.Filled = true; d.OptionsButton.Dot3.Radius = 1.5; d.OptionsButton.Dot3.zIndex = z + 2; end

            if d.LoadButton.Background then d.LoadButton.Background.Filled = true; d.LoadButton.Background.zIndex = z + 2; d.LoadButton.Background.Rounding = self.ActiveTheme.Rounding.Button; end
            if d.LoadButton.Icon then d.LoadButton.Icon.Size = {14, 14}; d.LoadButton.Icon.zIndex = z + 3; d.LoadButton.Icon.Url = "https://s6.imgcdn.dev/Y4v6tt.png"; end
            if d.LoadButton.Label then d.LoadButton.Label.Font = self.ActiveTheme.Fonts.Main; d.LoadButton.Label.Size = self.ActiveTheme.Fonts.Size; d.LoadButton.Label.Text = "Load"; d.LoadButton.Label.Center = false; d.LoadButton.Label.zIndex = z + 3; end

            if d.SaveButton.Background then d.SaveButton.Filled = true; d.SaveButton.zIndex = z + 2; d.SaveButton.Rounding = self.ActiveTheme.Rounding.Button; end
            if d.SaveButton.Border then d.SaveButton.Border.Filled = false; d.SaveButton.Border.Thickness = 1; d.SaveButton.Border.zIndex = z + 3; d.SaveButton.Border.Rounding = self.ActiveTheme.Rounding.Button; end
            if d.SaveButton.Icon then d.SaveButton.Icon.Size = {13.33, 13.33}; d.SaveButton.Icon.zIndex = z + 3; d.SaveButton.Icon.Url = "https://s6.imgcdn.dev/Y4Sudt.png"; end
            if d.SaveButton.Label then d.SaveButton.Label.Font = self.ActiveTheme.Fonts.Main; d.SaveButton.Label.Size = self.ActiveTheme.Fonts.Size; d.SaveButton.Label.Text = "Save"; d.SaveButton.Label.Center = false; d.SaveButton.Label.zIndex = z + 3; end
            
            table.insert(configs.Items, item)
        end
    end
end

--================================================================
--[[ PRIVATE: THEME MANAGEMENT ]]
--================================================================



--================================================================
--[[ PRIVATE: RENDERING & INPUT HANDLING ]]
--================================================================

function Library:_RenderAboutWindow(mouse_pos)
    local about = self.UI.Core.AboutWindow
    local isVisible = self.UI.Popups.About.IsOpen
    local theme = self.ActiveTheme
    
    local function setAboutVisibility(tbl, visible)
        for key, obj in pairs(tbl) do
            if type(obj) == 'table' then
                if obj.Visible ~= nil then self:_SetVisibility(obj, visible)
                elseif obj.Label and (obj.Back or obj.Button or obj.LeftFill) then
                    self:_SetVisibility(obj.Label, visible);
                    if obj.Back then self:_SetVisibility(obj.Back, visible); self:_SetVisibility(obj.Nub, visible); end
                    if obj.LeftFill then self:_SetVisibility(obj.LeftFill, visible); self:_SetVisibility(obj.RightFill, visible); self:_SetVisibility(obj.Nub, visible); self:_SetVisibility(obj.ValueText, visible); end
                    if obj.Button then self:_SetVisibility(obj.Button, visible); self:_SetVisibility(obj.ButtonText, visible); self:_SetVisibility(obj.ArrowLine1, visible); self:_SetVisibility(obj.ArrowLine2, visible); end
                elseif key ~= "ClickRegion" and key ~= "StyleCircles" and key ~= "Glow" and key ~= "Tooltip" and key ~= "HoveredThemeCircle" then
                     setAboutVisibility(obj, visible)
                end
            end
        end
    end
    setAboutVisibility(about, isVisible)
    self:_SetVisibility(about.Tooltip.Background, false)
    self:_SetVisibility(about.Tooltip.Text, false)

    for _, circle in ipairs(about.StyleCircles) do
        self:_SetVisibility(circle.Circle, isVisible); 
        self:_SetVisibility(circle.Border, isVisible and self.UI.Values.AboutSelectedStyle == circle.Name);
        if circle.Inner then self:_SetVisibility(circle.Inner, isVisible) end
        if circle.PlusLine1 then self:_SetVisibility(circle.PlusLine1, isVisible); self:_SetVisibility(circle.PlusLine2, isVisible) end
    end

    if not isVisible then
        if about.Glow then self:_HideGlowEffect(about.Glow) end
        if about.AnimationSpeedSlider.Glow then self:_HideGlowEffect(about.AnimationSpeedSlider.Glow) end
        local dropdown = about.DpiScaleDropdown
        if dropdown.IsOpen then
            dropdown.IsOpen = false
            self:_SetVisibility(dropdown.OptionBackground, false); self:_SetVisibility(dropdown.BorderLeft, false); self:_SetVisibility(dropdown.BorderRight, false); self:_SetVisibility(dropdown.BorderBottom, false)
            for _, option in ipairs(dropdown.OptionList) do self:_SetVisibility(option, false) end
        end
        return
    end

    self:_AnimateAndApplyColor(about.Background, theme.Colors.SectionBackground)
    self:_AnimateAndApplyColor(about.Border, theme.Colors.Separator)
    self:_AnimateAndApplyColor(about.HeaderIcon, theme.Colors.TextSecondary)
    self:_AnimateAndApplyColor(about.HeaderTitle, theme.Colors.TextPrimary)
    self:_AnimateAndApplyColor(about.CloseButton.Line1, theme.Colors.TextSecondary)
    self:_AnimateAndApplyColor(about.CloseButton.Line2, theme.Colors.TextSecondary)
    self:_AnimateAndApplyColor(about.Separator1, theme.Colors.Separator)
    self:_AnimateAndApplyColor(about.MainTitle, theme.Colors.TextPrimary)
    self:_AnimateAndApplyColor(about.Separator2, theme.Colors.Separator)
    self:_AnimateAndApplyColor(about.InfoVersionLabel, theme.Colors.TextSecondary); self:_AnimateAndApplyColor(about.InfoVersionValue, theme.Colors.Accent)
    self:_AnimateAndApplyColor(about.InfoBuildDateLabel, theme.Colors.TextSecondary); self:_AnimateAndApplyColor(about.InfoBuildDateValue, theme.Colors.Accent)
    self:_AnimateAndApplyColor(about.InfoBuildTypeLabel, theme.Colors.TextSecondary); self:_AnimateAndApplyColor(about.InfoBuildTypeValue, theme.Colors.Accent)
    self:_AnimateAndApplyColor(about.InfoRegisteredToLabel, theme.Colors.TextSecondary); self:_AnimateAndApplyColor(about.InfoRegisteredToValue, theme.Colors.Accent)
    self:_AnimateAndApplyColor(about.InfoSubscriptionLabel, theme.Colors.TextSecondary); self:_AnimateAndApplyColor(about.InfoSubscriptionValue, theme.Colors.Accent)
    self:_AnimateAndApplyColor(about.FooterText, theme.Colors.TextSecondary)
    self:_AnimateAndApplyColor(about.Separator3, theme.Colors.Separator)
    self:_AnimateAndApplyColor(about.CreditText, theme.Colors.TextSecondary)
    self:_AnimateAndApplyColor(about.StyleLabel, theme.Colors.TextSecondary)
    self:_AnimateAndApplyColor(about.Tooltip.Background, theme.Colors.MainBackground)
    self:_AnimateAndApplyColor(about.Tooltip.Text, theme.Colors.TextPrimary)
    for _, circle in ipairs(about.StyleCircles) do
        self:_AnimateAndApplyColor(circle.Border, theme.Colors.Accent)
        if circle.PlusLine1 then self:_AnimateAndApplyColor(circle.PlusLine1, theme.Colors.TextSecondary) end
        if circle.PlusLine2 then self:_AnimateAndApplyColor(circle.PlusLine2, theme.Colors.TextSecondary) end
    end
    self:_AnimateAndApplyColor(about.AutoSaveToggle.Label, theme.Colors.TextSecondary)
    local slider = about.AnimationSpeedSlider; self:_AnimateAndApplyColor(slider.Label, theme.Colors.TextSecondary); self:_AnimateAndApplyColor(slider.LeftFill, theme.Colors.Accent); self:_AnimateAndApplyColor(slider.RightFill, theme.Colors.DarkBlue); self:_AnimateAndApplyColor(slider.Nub, theme.Colors.Accent); self:_AnimateAndApplyColor(slider.ValueText, theme.Colors.TextPrimary);
    local dd = about.DpiScaleDropdown; self:_AnimateAndApplyColor(dd.Label, theme.Colors.TextSecondary); self:_AnimateAndApplyColor(dd.Button, theme.Colors.DarkBlue); self:_AnimateAndApplyColor(dd.ButtonText, theme.Colors.TextPrimary); self:_AnimateAndApplyColor(dd.ArrowLine1, theme.Colors.TextPrimary); self:_AnimateAndApplyColor(dd.ArrowLine2, theme.Colors.TextPrimary); self:_AnimateAndApplyColor(dd.OptionBackground, theme.Colors.SectionBackground); self:_AnimateAndApplyColor(dd.BorderLeft, theme.Colors.Separator); self:_AnimateAndApplyColor(dd.BorderRight, theme.Colors.Separator); self:_AnimateAndApplyColor(dd.BorderBottom, theme.Colors.Separator);

    local winW, winH = 360, 500
    local winX, winY = self.Window.X + (self.Window.Width / 2) - (winW / 2), self.Window.Y + (self.Window.Height / 2) - (winH / 2)
    about.ClickRegion = {x1 = winX, y1 = winY, x2 = winX + winW, y2 = winY + winH}
    about.Background.Position = {winX, winY}; about.Background.Size = {winW, winH}
    about.Border.Position = {winX, winY}; about.Border.Size = {winW, winH}
    if about.Glow then self:_RenderGlowEffect(about.Glow, winX, winY, winW, winH, about.Background.Rounding, theme.Colors.GlowColor) end
    about.HeaderIcon.Position = {winX + 15, winY + 12}
    about.HeaderTitle.Position = {winX + 15 + about.HeaderIcon.Size.x + 8, winY + 13}
    about.CloseButton.Line1.From = {winX + winW - 25, winY + 12}; about.CloseButton.Line1.To = {winX + winW - 15, winY + 22}
    about.CloseButton.Line2.From = {winX + winW - 25, winY + 22}; about.CloseButton.Line2.To = {winX + winW - 15, winY + 12}
    about.CloseButton.ClickRegion = {x1 = winX + winW - 30, y1 = winY + 10, x2 = winX + winW - 10, y2 = winY + 25}
    local currentY = winY + 40
    about.Separator1.From = {winX + 10, currentY}; about.Separator1.To = {winX + winW - 10, currentY}
    currentY = currentY + 25
    about.MainTitle.Position = {winX + winW / 2, currentY}
    currentY = currentY + 40
    about.Separator2.From = {winX + 10, currentY}; about.Separator2.To = {winX + winW - 10, currentY}
    currentY = currentY + 20
    local infoX = winX + 30
    local function renderInfoLine(y, label, value) if label and value then label.Position = {infoX, y}; if label.TextBounds then value.Position = {infoX + label.TextBounds.x + 5, y} end; return y + 25; end; return y; end
    currentY = renderInfoLine(currentY, about.InfoVersionLabel, about.InfoVersionValue)
    currentY = renderInfoLine(currentY, about.InfoBuildDateLabel, about.InfoBuildDateValue)
    currentY = renderInfoLine(currentY, about.InfoBuildTypeLabel, about.InfoBuildTypeValue)
    currentY = renderInfoLine(currentY, about.InfoRegisteredToLabel, about.InfoRegisteredToValue)
    currentY = renderInfoLine(currentY, about.InfoSubscriptionLabel, about.InfoSubscriptionValue)
    about.FooterText.Position = {winX + winW / 2, currentY}
    currentY = currentY + 50; about.Separator3.From = {winX + 10, currentY}; about.Separator3.To = {winX + winW - 10, currentY}; currentY = currentY + 15
    local controlX = winX + 20; local controlW = winW - 40; local controlSpacing = 35
    local rightEdge = winX + winW - 25
    local toggle = about.AutoSaveToggle
    toggle.Label.Position = {controlX, currentY}; local toggleBackX = rightEdge - toggle.Size.width; toggle.Back.Position = {toggleBackX, currentY + 4}; toggle.Back.Size = {toggle.Size.width, toggle.Size.height}; toggle.ClickRegion = {x1 = toggleBackX, y1 = currentY, x2 = toggleBackX + toggle.Size.width, y2 = currentY + toggle.Size.height + 8}; 
    local targetBackColor, targetNubColor; if self.UI.Values[toggle.id] then targetBackColor = self:_DarkenColor(theme.Colors.Accent, 0.3); targetNubColor = theme.Colors.Accent; toggle.Nub.Position = {toggleBackX + toggle.Size.width - 5, currentY + 4 + toggle.Size.height/2} else targetBackColor = theme.Colors.DarkGray; targetNubColor = theme.Colors.LightGray; toggle.Nub.Position = {toggleBackX + 5, currentY + 4 + toggle.Size.height/2} end;
    self:_AnimateAndApplyColor(toggle.Back, targetBackColor); self:_AnimateAndApplyColor(toggle.Nub, targetNubColor);
    currentY = currentY + controlSpacing
    local slider = about.AnimationSpeedSlider
    slider.Label.Position = {controlX, currentY}; 
    local valueTextWidth = 40; local sliderRightEdge = rightEdge - valueTextWidth; local sliderBackX = controlX + 140; local sliderBackWidth = sliderRightEdge - sliderBackX
    slider.Back.Position = {sliderBackX, currentY + 8}; slider.Back.Size = {sliderBackWidth, 2}; slider.ClickRegion = { x1 = sliderBackX, y1 = currentY - 2, x2 = sliderBackX + sliderBackWidth, y2 = currentY + 18 }; local value_percentage = math.clamp((self.UI.Values[slider.id] - slider.Min) / (slider.Max - slider.Min), 0, 1); local nubX = sliderBackX + sliderBackWidth * value_percentage; slider.LeftFill.Position = {sliderBackX, currentY + 8}; slider.LeftFill.Size = {nubX - sliderBackX, 2}; slider.RightFill.Position = {nubX, currentY + 8}; slider.RightFill.Size = {sliderBackX + sliderBackWidth - nubX, 2}; slider.Nub.Position = {nubX, currentY + 9}; 
    local glowWidth = nubX - sliderBackX; local glowHeight = 8; if glowWidth > 0 and slider.Glow then self:_RenderGlowEffect(slider.Glow, sliderBackX, currentY + 9 - (glowHeight / 2), glowWidth, glowHeight, slider.LeftFill.Rounding, theme.Colors.GlowAccent, {top=true, bottom=true, left=true, right=false}) elseif slider.Glow then self:_HideGlowEffect(slider.Glow) end
    local valueText = string.format("%.1f", self.UI.Values[slider.id]); local valueTextX = rightEdge - valueTextWidth + 10; slider.ValueText.Text = valueText; slider.ValueText.Position = {valueTextX, currentY}; currentY = currentY + controlSpacing
    local dropdown = about.DpiScaleDropdown
    local dropdownY = currentY - 4
    dropdown.Label.Position = {controlX, dropdownY + 5}; local dropdownButtonX = rightEdge - dropdown.Size.width; dropdown.Button.Position = {dropdownButtonX, dropdownY}; dropdown.Button.Size = {dropdown.Size.width, dropdown.Size.height}; dropdown.ButtonText.Position = {dropdownButtonX + 5, dropdownY + dropdown.Size.height / 2 - dropdown.ButtonText.Size / 2}; dropdown.ButtonText.Text = self.UI.Values[dropdown.id]; local arrowX, arrowY = dropdownButtonX + dropdown.Size.width - 15, dropdownY + dropdown.Size.height / 2; dropdown.ArrowLine1.From = {arrowX, arrowY - 2}; dropdown.ArrowLine1.To = {arrowX + 5, arrowY + 3}; dropdown.ArrowLine2.From = {arrowX + 5, arrowY + 3}; dropdown.ArrowLine2.To = {arrowX + 10, arrowY - 2}; dropdown.ClickRegion = { x1 = dropdownButtonX, y1 = dropdownY, x2 = dropdownButtonX + dropdown.Size.width, y2 = dropdownY + dropdown.Size.height }
    self:_SetVisibility(dropdown.BorderLeft, dropdown.IsOpen); self:_SetVisibility(dropdown.BorderRight, dropdown.IsOpen); self:_SetVisibility(dropdown.BorderBottom, dropdown.IsOpen)
    if dropdown.IsOpen then
        local optionListHeight = #dropdown.Options * 20 + 5; local bgX, bgY, bgW, bgH = dropdownButtonX, dropdownY + dropdown.Size.height, dropdown.Size.width, optionListHeight
        self:_SetVisibility(dropdown.OptionBackground, true); dropdown.OptionBackground.Position = {bgX, bgY}; dropdown.OptionBackground.Size = {bgW, bgH}; dropdown.BorderLeft.From = {bgX, bgY}; dropdown.BorderLeft.To = {bgX, bgY + bgH}; dropdown.BorderRight.From = {bgX + bgW, bgY}; dropdown.BorderRight.To = {bgX + bgW, bgY + bgH}; dropdown.BorderBottom.From = {bgX, bgY + bgH}; dropdown.BorderBottom.To = {bgX + bgW, bgY + bgH};
        local optionY = dropdownY + dropdown.Size.height + 5
        for i, option in ipairs(dropdown.OptionList) do 
            self:_SetVisibility(option, true); option.Position = {dropdownButtonX + 5, optionY}; option.Text = dropdown.Options[i]; 
            local targetOptColor = (self.UI.Values[dropdown.id] == dropdown.Options[i]) and theme.Colors.Accent or theme.Colors.TextPrimary
            self:_AnimateAndApplyColor(option, targetOptColor)
            optionY = optionY + 20 
        end
    else
        self:_SetVisibility(dropdown.OptionBackground, false); for _, option in ipairs(dropdown.OptionList) do self:_SetVisibility(option, false) end
    end
    currentY = currentY + controlSpacing
    local styleY = currentY + 4
    about.StyleLabel.Position = {controlX, styleY}; 
    local maxPerRow = 8; local circleSpacing = 30; local circleStartX = rightEdge
    for i, circle in ipairs(about.StyleCircles) do
        local slotIndex = i - 1; local col = slotIndex % maxPerRow; local row = math.floor(slotIndex / maxPerRow)
        local circleX = circleStartX - (col * circleSpacing); local circleY = styleY + 5 + (row * circleSpacing)
        circle.Circle.Position = {circleX, circleY}; circle.Border.Position = {circleX, circleY}
        if circle.Inner then circle.Inner.Position = {circleX, circleY} end
        if circle.PlusLine1 then circle.PlusLine1.From = {circleX - 4, circleY}; circle.PlusLine1.To = {circleX + 4, circleY}; circle.PlusLine2.From = {circleX, circleY - 4}; circle.PlusLine2.To = {circleX, circleY + 4}; end
        circle.ClickRegion = {x1 = circleX - 10, y1 = circleY - 5, x2 = circleX + 10, y2 = circleY + 15}
    end
    if about.HoveredThemeCircle.Name and (tick() - about.HoveredThemeCircle.HoverStartTime > 1) then
        local tooltip = about.Tooltip; local text = about.HoveredThemeCircle.Name; tooltip.Text.Text = text
        if tooltip.Text.TextBounds then
            local ttW = tooltip.Text.TextBounds.x + 16; local ttH = tooltip.Text.TextBounds.y + 10; local ttX = mouse_pos.x + 15; local ttY = mouse_pos.y
            tooltip.Background.Position = {ttX, ttY}; tooltip.Background.Size = {ttW, ttH}; tooltip.Text.Position = {ttX + 8, ttY + 5}
            self:_SetVisibility(tooltip.Background, true); self:_SetVisibility(tooltip.Text, true)
        end
    end
    about.CreditText.Position = {winX + winW / 2, winY + winH - 25}
end

function Library:_RenderPlayerESPSettingsPopup()
    local popup = self.UI.Popups.PlayerESP
    local isVisible = popup.IsOpen
    local theme = self.ActiveTheme

    self:_SetVisibility(popup.Background, isVisible); self:_SetVisibility(popup.Border, isVisible); self:_SetVisibility(popup.Title, isVisible); self:_SetVisibility(popup.Separator, isVisible); self:_SetVisibility(popup.BindLabel, isVisible); self:_SetVisibility(popup.Keybind.Button, isVisible); self:_SetVisibility(popup.Keybind.ButtonText, isVisible);

    if not isVisible then
        if popup.Glow then self:_HideGlowEffect(popup.Glow) end
        return
    end
    
    self:_AnimateAndApplyColor(popup.Background, theme.Colors.SectionBackground)
    self:_AnimateAndApplyColor(popup.Border, theme.Colors.Separator)
    self:_AnimateAndApplyColor(popup.Title, theme.Colors.TextPrimary)
    self:_AnimateAndApplyColor(popup.Separator, theme.Colors.Separator)
    self:_AnimateAndApplyColor(popup.BindLabel, theme.Colors.TextSecondary)
    
    local accentColor = theme.Colors.Accent
    self:_AnimateAndApplyColor(popup.Keybind.Button, accentColor)
    self:_AnimateAndApplyColor(popup.Keybind.ButtonText, self:_GetTextColorForBackground(accentColor))

    local pX, pY = popup.Pos.x, popup.Pos.y
    local pW = 250
    local currentY = pY + 8
    if popup.Title then popup.Title.Position = {pX + 10, currentY}; end
    currentY = currentY + popup.Title.Size + 5
    local separatorY = currentY
    if popup.Separator then popup.Separator.From = {pX + 10, separatorY}; popup.Separator.To = {pX + pW - 10, separatorY}; end
    currentY = currentY + 15
    local elementY = currentY
    if popup.BindLabel then popup.BindLabel.Position = {pX + 10, elementY}; end
    local keybind = popup.Keybind
    local bindButtonX = pX + pW - keybind.Size.width - 15
    local bindButtonY = elementY - 5
    if keybind.Button then keybind.Button.Position = {bindButtonX, bindButtonY}; keybind.Button.Size = {keybind.Size.width, keybind.Size.height}; end
    if keybind.ButtonText then keybind.ButtonText.Position = {bindButtonX + (keybind.Size.width / 2), bindButtonY + (keybind.Size.height / 2) - (keybind.ButtonText.Size / 2)}; keybind.ButtonText.Center = true; keybind.ButtonText.Text = keybind.IsListening and "..." or self.UI.Values[keybind.id]; end
    keybind.ClickRegion = {x1 = bindButtonX, y1 = bindButtonY, x2 = bindButtonX + keybind.Size.width, y2 = bindButtonY + keybind.Size.height}
    currentY = currentY + 30
    currentY = currentY + 5
    local totalHeight = currentY - pY
    popup.ClickRegion = {x1 = pX, y1 = pY, x2 = pX + pW, y2 = pY + totalHeight}
    if popup.Background then popup.Background.Position = {pX, pY}; popup.Background.Size = {pW, totalHeight}; end
    if popup.Border then popup.Border.Position = {pX, pY}; popup.Border.Size = {pW, totalHeight}; end
    if popup.Glow then self:_RenderGlowEffect(popup.Glow, pX, pY, pW, totalHeight, popup.Background.Rounding, theme.Colors.GlowColor) end
end

function Library:_RenderEditStyleWindow()
    local style_window = self.UI.Popups.EditStyle
    local isVisible = style_window.IsOpen
    local theme = self.ActiveTheme

    self:_SetVisibility(style_window.Background, isVisible); self:_SetVisibility(style_window.Border, isVisible); self:_SetVisibility(style_window.HeaderIcon, isVisible); self:_SetVisibility(style_window.HeaderTitle, isVisible); self:_SetVisibility(style_window.CloseButton.Line1, isVisible); self:_SetVisibility(style_window.CloseButton.Line2, isVisible); self:_SetVisibility(style_window.Separator1, isVisible);
    self:_SetVisibility(style_window.StyleNameLabel, isVisible); self:_SetVisibility(style_window.StyleNameInputBg, isVisible); self:_SetVisibility(style_window.StyleNameInputText, isVisible); self:_SetVisibility(style_window.Separator2, isVisible); self:_SetVisibility(style_window.Separator3, isVisible);
    self:_SetVisibility(style_window.StyleNameInputCursor, isVisible and style_window.IsEditingName and math.sin(tick() * 5) > 0)
    for _, item in ipairs(style_window.ColorItems) do self:_SetVisibility(item.Label, isVisible); self:_SetVisibility(item.ColorCircle, isVisible); self:_SetVisibility(item.ColorBorder, isVisible); end
    self:_SetVisibility(style_window.RealTimeToggle.Label, isVisible); self:_SetVisibility(style_window.RealTimeToggle.Back, isVisible); self:_SetVisibility(style_window.RealTimeToggle.Nub, isVisible);
    self:_SetVisibility(style_window.CancelButton.Background, isVisible); self:_SetVisibility(style_window.CancelButton.Border, isVisible); self:_SetVisibility(style_window.CancelButton.IconLine1, isVisible); self:_SetVisibility(style_window.CancelButton.IconLine2, isVisible); self:_SetVisibility(style_window.CancelButton.Label, isVisible);
    self:_SetVisibility(style_window.SaveButton.Background, isVisible); self:_SetVisibility(style_window.SaveButton.Label, isVisible); self:_SetVisibility(style_window.SaveButton.Icon, isVisible);
    
    if not isVisible then
        self:_HideGlowEffect(style_window.Glow)
        return
    end

    self:_AnimateAndApplyColor(style_window.Background, theme.Colors.SectionBackground)
    self:_AnimateAndApplyColor(style_window.Border, theme.Colors.Separator)
    self:_AnimateAndApplyColor(style_window.HeaderTitle, theme.Colors.TextPrimary)
    self:_AnimateAndApplyColor(style_window.CloseButton.Line1, theme.Colors.TextSecondary)
    self:_AnimateAndApplyColor(style_window.CloseButton.Line2, theme.Colors.TextSecondary)
    self:_AnimateAndApplyColor(style_window.Separator1, theme.Colors.Separator)
    self:_AnimateAndApplyColor(style_window.Separator2, theme.Colors.Separator)
    self:_AnimateAndApplyColor(style_window.Separator3, theme.Colors.Separator)
    self:_AnimateAndApplyColor(style_window.StyleNameLabel, theme.Colors.TextSecondary)
    self:_AnimateAndApplyColor(style_window.StyleNameInputBg, theme.Colors.DarkBlue)
    self:_AnimateAndApplyColor(style_window.StyleNameInputText, theme.Colors.TextPrimary)
    self:_AnimateAndApplyColor(style_window.StyleNameInputCursor, theme.Colors.Accent)
    for _, item in ipairs(style_window.ColorItems) do self:_AnimateAndApplyColor(item.Label, theme.Colors.TextSecondary); self:_AnimateAndApplyColor(item.ColorBorder, theme.Colors.LightGray); end
    self:_AnimateAndApplyColor(style_window.RealTimeToggle.Label, theme.Colors.TextSecondary)
    self:_AnimateAndApplyColor(style_window.CancelButton.Background, theme.Colors.MainBackground)
    self:_AnimateAndApplyColor(style_window.CancelButton.Border, theme.Colors.Separator)
    self:_AnimateAndApplyColor(style_window.CancelButton.IconLine1, theme.Colors.TextPrimary)
    self:_AnimateAndApplyColor(style_window.CancelButton.IconLine2, theme.Colors.TextPrimary)
    self:_AnimateAndApplyColor(style_window.CancelButton.Label, theme.Colors.TextPrimary)
    
    local saveButtonAccentColor = theme.Colors.Accent
    self:_AnimateAndApplyColor(style_window.SaveButton.Background, saveButtonAccentColor)
    local saveButtonTextColor = self:_GetTextColorForBackground(saveButtonAccentColor)
    self:_AnimateAndApplyColor(style_window.SaveButton.Label, saveButtonTextColor)
    self:_AnimateAndApplyColor(style_window.SaveButton.Icon, saveButtonTextColor)

    local winW, winH = 300, 540
    local winX, winY = self.Window.X + self.Window.Width + 15, self.Window.Y
    
    style_window.ClickRegion = {x1 = winX, y1 = winY, x2 = winX + winW, y2 = winY + winH}
    style_window.Background.Position = {winX, winY}; style_window.Background.Size = {winW, winH}
    style_window.Border.Position = {winX, winY}; style_window.Border.Size = {winW, winH}
    self:_RenderGlowEffect(style_window.Glow, winX, winY, winW, winH, style_window.Background.Rounding, theme.Colors.GlowColor)

    local headerY = winY + 12
    local accentIconColor = style_window.EditingTheme.Colors.Accent or {255,255,255,255}
    self:_AnimateAndApplyColor(style_window.HeaderIcon, accentIconColor)
    style_window.HeaderIcon.Position = {winX + 15, headerY}
    style_window.HeaderTitle.Position = {winX + 15 + style_window.HeaderIcon.Size.x + 8, headerY + 1}
    
    style_window.CloseButton.Line1.From = {winX + winW - 25, headerY}; style_window.CloseButton.Line1.To = {winX + winW - 15, headerY + 10}
    style_window.CloseButton.Line2.From = {winX + winW - 25, headerY + 10}; style_window.CloseButton.Line2.To = {winX + winW - 15, headerY}
    style_window.CloseButton.ClickRegion = {x1 = winX + winW - 30, y1 = winY + 10, x2 = winX + winW - 10, y2 = winY + 25}

    local currentY = winY + 40
    style_window.Separator1.From = {winX + 10, currentY}; style_window.Separator1.To = {winX + winW - 10, currentY}
    
    currentY = currentY + 15
    style_window.StyleNameLabel.Position = {winX + 15, currentY}
    local inputW = 150; local inputH = 25
    local inputX = winX + winW - inputW - 15
    style_window.StyleNameInputBg.Position = {inputX, currentY - 5}; style_window.StyleNameInputBg.Size = {inputW, inputH}
    style_window.StyleNameInputText.Position = {inputX + 8, currentY - 5 + (inputH/2) - (style_window.StyleNameInputText.Size / 2)}
    style_window.StyleNameInputClickRegion = {x1 = inputX, y1 = currentY - 5, x2 = inputX + inputW, y2 = currentY - 5 + inputH}
    
    if style_window.StyleNameInputText.TextBounds then
        local cursorX = inputX + 8 + style_window.StyleNameInputText.TextBounds.x
        local cursorY = currentY - 5 + 4
        style_window.StyleNameInputCursor.From = {cursorX, cursorY}
        style_window.StyleNameInputCursor.To = {cursorX, cursorY + inputH - 8}
    end

    currentY = currentY + 30
    style_window.Separator2.From = {winX + 10, currentY}; style_window.Separator2.To = {winX + winW - 10, currentY}
    
    currentY = currentY + 15
    for _, item in ipairs(style_window.ColorItems) do
        item.Label.Position = {winX + 15, currentY}
        local circleX = winX + winW - 30
        
        local c = style_window.EditingTheme.Colors[item.Name] or {255,0,255,255}
        self:_AnimateAndApplyColor(item.ColorCircle, c)

        item.ColorCircle.Position = {circleX, currentY + 7}
        item.ColorBorder.Position = {circleX, currentY + 7}
        item.ClickRegion = {x1 = winX + 15, y1 = currentY, x2 = winX + winW - 15, y2 = currentY + 20}
        currentY = currentY + 25
    end
    
    currentY = currentY + 20
    style_window.Separator3.From = {winX + 10, currentY}; style_window.Separator3.To = {winX + winW - 10, currentY}

    local footerY = winY + winH - 70
    local saveBtn = style_window.SaveButton; local saveBtnW, saveBtnH = 80, 28
    local saveBtnX, saveBtnY = winX + winW - saveBtnW - 15, footerY
    saveBtn.Background.Position = {saveBtnX, saveBtnY}; saveBtn.Background.Size = {saveBtnW, saveBtnH}
    local saveIconX = saveBtnX + 12; local saveIconY = saveBtnY + (saveBtnH / 2) - (saveBtn.Icon.Size.y / 2)
    saveBtn.Icon.Position = {saveIconX, saveIconY}
    saveBtn.Label.Position = {saveIconX + saveBtn.Icon.Size.x + 8, saveBtnY + (saveBtnH / 2) - (saveBtn.Label.Size / 2)}
    saveBtn.ClickRegion = {x1 = saveBtnX, y1 = saveBtnY, x2 = saveBtnX + saveBtnW, y2 = saveBtnY + saveBtnH}

    local cancelBtn = style_window.CancelButton; local cancelBtnW, cancelBtnH = 90, 28
    local cancelBtnX = saveBtnX - cancelBtnW - 10; local cancelBtnY = footerY
    cancelBtn.Background.Position = {cancelBtnX, cancelBtnY}; cancelBtn.Background.Size = {cancelBtnW, cancelBtnH}
    cancelBtn.Border.Position = {cancelBtnX, cancelBtnY}; cancelBtn.Border.Size = {cancelBtnW, cancelBtnH}
    local cancelIconCenterX, cancelIconCenterY = cancelBtnX + 15, cancelBtnY + cancelBtnH / 2
    cancelBtn.IconLine1.From = {cancelIconCenterX - 4, cancelIconCenterY - 4}; cancelBtn.IconLine1.To = {cancelIconCenterX + 4, cancelIconCenterY + 4}
    cancelBtn.IconLine2.From = {cancelIconCenterX - 4, cancelIconCenterY + 4}; cancelBtn.IconLine2.To = {cancelIconCenterX + 4, cancelIconCenterY - 4}
    cancelBtn.Label.Position = {cancelIconCenterX + 10, cancelBtnY + (cancelBtnH / 2) - (cancelBtn.Label.Size / 2)}
    cancelBtn.ClickRegion = {x1 = cancelBtnX, y1 = cancelBtnY, x2 = cancelBtnX + cancelBtnW, y2 = cancelBtnY + cancelBtnH}

    local toggleY = footerY + cancelBtnH + 15
    local toggle = style_window.RealTimeToggle
    toggle.Label.Position = {winX + 15, toggleY + 5}
    if toggle.Label.TextBounds then
      local toggleBackX = winX + 15 + toggle.Label.TextBounds.x + 10
      toggle.Back.Position = {toggleBackX, toggleY + 7}; toggle.Back.Size = {toggle.Size.width, toggle.Size.height}; toggle.ClickRegion = {x1 = toggleBackX, y1 = toggleY, x2 = toggleBackX + toggle.Size.width, y2 = toggleY + toggle.Size.height + 14}
      local backColor, nubColor
      if self.UI.Values[toggle.id] then
          backColor = theme.Colors.ToggleEnabledBackground or self:_DarkenColor(theme.Colors.Accent, 0.3)
          nubColor = theme.Colors.Accent
          toggle.Nub.Position = {toggleBackX + toggle.Size.width - 5, toggleY + 7 + toggle.Size.height/2}
      else
          backColor = theme.Colors.DarkGray
          nubColor = theme.Colors.LightGray
          toggle.Nub.Position = {toggleBackX + 5, toggleY + 7 + toggle.Size.height/2}
      end
      self:_AnimateAndApplyColor(toggle.Back, backColor)
      self:_AnimateAndApplyColor(toggle.Nub, nubColor)
    end
end

function Library:_RenderColorPickerWindow()
    local picker = self.UI.Popups.ColorPicker
    local isVisible = picker.IsOpen

    self:_SetVisibility(picker.Background, isVisible)
    self:_SetVisibility(picker.Border, isVisible)
    self:_SetVisibility(picker.ColorSquare, isVisible)
    self:_SetVisibility(picker.GradientOverlay, isVisible)
    self:_SetVisibility(picker.SaturationValueNub, isVisible)
    self:_SetVisibility(picker.HueSlider, isVisible)
    self:_SetVisibility(picker.HueNub, isVisible)
    self:_SetVisibility(picker.HueNubBorder, isVisible)
    self:_SetVisibility(picker.OpacitySliderBackground, isVisible)
    self:_SetVisibility(picker.OpacitySliderGradient, isVisible)
    self:_SetVisibility(picker.OpacityNub, isVisible)
    self:_SetVisibility(picker.OpacityNubBorder, isVisible)
    
    if isVisible then
        local padding = 10
        local squareSize = 160
        local sliderHeight = 8
        local sliderSpacing = 12

        local pickerW = squareSize + (padding * 2)
        local pickerH = squareSize + (padding * 2) + (sliderHeight * 2) + (sliderSpacing * 2)
        local pickerX, pickerY = picker.Pos.x, picker.Pos.y
        
        picker.Background.Position = {pickerX, pickerY}
        picker.Background.Size = {pickerW, pickerH}
        local bgColor = self.ActiveTheme.Colors.SectionBackground
        picker.Background.Color = {bgColor[1], bgColor[2], bgColor[3]}
        picker.Background.Opacity = (bgColor[4] or 255) / 255

        picker.Border.Position = {pickerX, pickerY}
        picker.Border.Size = {pickerW, pickerH}
        local borderColor = self.ActiveTheme.Colors.Separator
        picker.Border.Color = {borderColor[1], borderColor[2], borderColor[3]}
        picker.Border.Opacity = (borderColor[4] or 255) / 255

        self:_RenderGlowEffect(picker.Glow, pickerX, pickerY, pickerW, pickerH, picker.Background.Rounding, self.ActiveTheme.Colors.GlowColor)

        local squareX = pickerX + padding
        local squareY = pickerY + padding
        
        -- Main saturation/value square
        picker.ColorSquare.Position = {squareX, squareY}
        picker.ColorSquare.Size = {squareSize, squareSize}
        local pureHue = self:_HSVtoRGB(picker.h, 1, 1)
        picker.ColorSquare.Color = {pureHue[1], pureHue[2], pureHue[3]}

        picker.GradientOverlay.Position = {squareX, squareY}
        picker.GradientOverlay.Size = {squareSize, squareSize}

        local svNubX = squareX + (picker.s * squareSize)
        local svNubY = squareY + ((1 - picker.v) * squareSize)
        picker.SaturationValueNub.Position = {svNubX, svNubY}
        picker.SaturationValueNub.Color = picker.v > 0.5 and {0,0,0} or {255,255,255}
        picker.SaturationValueRegion = {x1 = squareX, y1 = squareY, x2 = squareX + squareSize, y2 = squareY + squareSize}

        local currentY = squareY + squareSize + sliderSpacing

        -- Hue Slider
        picker.HueSlider.Position = {squareX, currentY}
        picker.HueSlider.Size = {squareSize, sliderHeight}
        local hueNubX = squareX + (picker.h * squareSize)
        local hueNubY = currentY + sliderHeight / 2
        picker.HueNub.Position = {hueNubX, hueNubY}
        picker.HueNubBorder.Position = {hueNubX, hueNubY}
        local hueNubColor = self:_HSVtoRGB(picker.h, 1, 1) -- Dynamic color
        picker.HueNub.Color = {hueNubColor[1], hueNubColor[2], hueNubColor[3]}
        picker.HueNubBorder.Color = {0, 0, 0}
        picker.HueSliderRegion = {x1 = squareX, y1 = currentY, x2 = squareX + squareSize, y2 = currentY + sliderHeight}

        currentY = currentY + sliderHeight + sliderSpacing

        -- Opacity Slider
        picker.OpacitySliderBackground.Position = {squareX, currentY}
        picker.OpacitySliderBackground.Size = {squareSize, sliderHeight}
        local opacityBgColor = self:_HSVtoRGB(picker.h, picker.s, picker.v)
        picker.OpacitySliderBackground.Color = {opacityBgColor[1], opacityBgColor[2], opacityBgColor[3]}
        
        picker.OpacitySliderGradient.Position = {squareX, currentY}
        picker.OpacitySliderGradient.Size = {squareSize, sliderHeight}

        local opacityNubX = squareX + (picker.a * squareSize)
        local opacityNubY = currentY + sliderHeight / 2
        picker.OpacityNub.Position = {opacityNubX, opacityNubY}
        picker.OpacityNubBorder.Position = {opacityNubX, opacityNubY}
        picker.OpacityNub.Color = {255, 255, 255}
        picker.OpacityNubBorder.Color = {0, 0, 0}
        picker.OpacitySliderRegion = {x1 = squareX, y1 = currentY, x2 = squareX + squareSize, y2 = currentY + sliderHeight}
    else
        self:_HideGlowEffect(picker.Glow)
    end
end

function Library:_RenderLoop()
    if not self.Window.Visible then return end

    if self.UI.Core.ConfigsTab.NeedsRefresh then
        self:_RefreshConfigList()
        self.UI.Core.ConfigsTab.NeedsRefresh = false
    end

    local mouse_pos = getmouseposition()
    if not mouse_pos then return end

    local Core = self.UI.Core
    local theme = self.ActiveTheme
    local isThemeLight = self:_IsThemeLight(theme)
    local windowX, windowY = self:_SafeNumber(self.Window.X, 0), self:_SafeNumber(self.Window.Y, 0)
    local sidebarWidth, headerHeight = self:_SafeNumber(self.Window.SidebarWidth, 0), self:_SafeNumber(self.Window.HeaderHeight, 0)
    local rightPanelX = windowX + sidebarWidth - self.Window.PanelOverlap

    self:_SetVisibility(Core.Sidebar.Drawing, true); self:_SetVisibility(Core.RightPanel.Drawing, true); self:_SetVisibility(Core.VerticalSeparator, true); self:_SetVisibility(Core.SidebarHeaderSeparator, true); self:_SetVisibility(Core.RightPanelHeaderSeparator, true); self:_SetVisibility(Core.Title, true); self:_SetVisibility(Core.SidebarBottomCircle, true); if Core.SidebarAvatar then self:_SetVisibility(Core.SidebarAvatar, true) end; self:_SetVisibility(Core.PlayerDisplayName, true); self:_SetVisibility(Core.TillLabel, true); self:_SetVisibility(Core.ForeverLabel, true)
    self:_SetVisibility(Core.Title2, not isThemeLight); self:_SetVisibility(Core.Title3, not isThemeLight)

    self:_AnimateAndApplyColor(Core.Sidebar.Drawing, theme.Colors.SidebarBackground)
    self:_AnimateAndApplyColor(Core.RightPanel.Drawing, theme.Colors.MainBackground)
    self:_AnimateAndApplyColor(Core.VerticalSeparator, theme.Colors.Separator)
    self:_AnimateAndApplyColor(Core.SidebarHeaderSeparator, theme.Colors.Separator)
    self:_AnimateAndApplyColor(Core.RightPanelHeaderSeparator, theme.Colors.Separator)
    self:_AnimateAndApplyColor(Core.Title, theme.Colors.TextPrimary)
    self:_AnimateAndApplyColor(Core.Title2, theme.Colors.Accent)
    self:_AnimateAndApplyColor(Core.Title3, theme.Colors.SectionBackground)
    self:_AnimateAndApplyColor(Core.SidebarBottomCircle, theme.Colors.Separator)
    self:_AnimateAndApplyColor(Core.PlayerDisplayName, theme.Colors.TextPrimary)
    self:_AnimateAndApplyColor(Core.TillLabel, theme.Colors.TextSecondary)
    self:_AnimateAndApplyColor(Core.ForeverLabel, theme.Colors.Accent)
    if Core.SidebarAvatar then self:_AnimateAndApplyColor(Core.SidebarAvatar, {255, 255, 255, 255}) end

    if Core.Sidebar.Drawing then Core.Sidebar.Drawing.Position = {windowX, windowY}; Core.Sidebar.Drawing.Size = {sidebarWidth, self.Window.Height}; end
    if Core.RightPanel.Drawing then Core.RightPanel.Drawing.Position = {rightPanelX, windowY}; Core.RightPanel.Drawing.Size = {self.Window.Width - sidebarWidth + self.Window.PanelOverlap, self.Window.Height}; end

    self:_RenderGlowEffect(Core.Sidebar.Glow, windowX, windowY, sidebarWidth, self.Window.Height, Core.Sidebar.Drawing.Rounding, theme.Colors.GlowColor, {top=true, bottom=true, left=true, right=true})
    self:_RenderGlowEffect(Core.RightPanel.Glow, rightPanelX, windowY, self.Window.Width - sidebarWidth + self.Window.PanelOverlap, self.Window.Height, Core.RightPanel.Drawing.Rounding, theme.Colors.GlowColor, {top=true, bottom=true, left=false, right=true})

    if Core.VerticalSeparator then Core.VerticalSeparator.Position = {rightPanelX, windowY}; Core.VerticalSeparator.Size = {4, self.Window.Height}; end
    if Core.SidebarHeaderSeparator then Core.SidebarHeaderSeparator.Position = {windowX, windowY + self.Window.Height - 100 + 14}; Core.SidebarHeaderSeparator.Size = {sidebarWidth, 4}; end
    if Core.RightPanelHeaderSeparator then Core.RightPanelHeaderSeparator.Position = {rightPanelX, windowY + headerHeight}; Core.RightPanelHeaderSeparator.Size = {self.Window.Width - sidebarWidth + self.Window.PanelOverlap, 4}; end
    if Core.Title then Core.Title.Position = {windowX + 11, windowY + 25}; end
    if Core.Title2 then Core.Title2.Position = {windowX + 9, windowY + 26}; end
    if Core.Title3 then Core.Title3.Position = {windowX + 7, windowY + 24}; end
    if Core.SidebarBottomCircle then local circleX = windowX + 8 + Core.SidebarBottomCircle.Radius; local circleY = windowY + self.Window.Height - 44; Core.SidebarBottomCircle.Position = {circleX, circleY}; end
    if Core.SidebarAvatar then local avatarSize = 56; local avatarX = windowX + 8; local avatarY = windowY + self.Window.Height - 44 - avatarSize / 2; Core.SidebarAvatar.Position = {avatarX, avatarY}; Core.SidebarAvatar.Size = {avatarSize, avatarSize}; end
    if Core.PlayerDisplayName then local textX = windowX + 15 + Core.SidebarBottomCircle.Radius * 2 + 5; local textY = windowY + self.Window.Height - 56; Core.PlayerDisplayName.Position = {textX, textY}; end
    if Core.TillLabel then local textX = windowX + 15 + Core.SidebarBottomCircle.Radius * 2 + 5; local textY = windowY + self.Window.Height - 40; Core.TillLabel.Position = {textX, textY}; end
    if Core.ForeverLabel then local textX = windowX + 8 + Core.SidebarBottomCircle.Radius * 2 + 30; local textY = windowY + self.Window.Height - 40; Core.ForeverLabel.Position = {textX, textY}; end

    do
        local startX, startY = rightPanelX + 35, windowY + (headerHeight / 2)
        local function renderHeaderButton(button, x, y, width, height, has_icon, is_accent)
             self:_SetVisibility(button.Background, true); self:_SetVisibility(button.Border, true); self:_SetVisibility(button.Label, true); if button.Icon then self:_SetVisibility(button.Icon, button.Icon.Visible) end
             
             button.Background.Position = {x, y}; button.Background.Size = {width, height}; 
             button.Border.Position = {x, y}; button.Border.Size = {width, height}; 
             
             local isHovered = self:_IsPointInRegion(mouse_pos.x, mouse_pos.y, button.ClickRegion)
             button.IsHovered = isHovered 
             
             local targetBgColor, targetTextColor

             if button == Core.HeaderButtons.CreateNew then
                local baseColor = theme.Colors.Accent
                local opacity = isHovered and 255 or (255 * 0.6)
                targetBgColor = {baseColor[1], baseColor[2], baseColor[3], opacity}
                targetTextColor = self:_GetTextColorForBackground(baseColor)
             else
                targetBgColor = isHovered and self:_DarkenColor(theme.Colors.Accent, 0.5) or (is_accent and theme.Colors.Accent or theme.Colors.MainBackground)
                targetTextColor = is_accent and self:_GetTextColorForBackground(theme.Colors.Accent) or theme.Colors.TextPrimary
             end

             local targetBorderColor = (tick() - (button.ClickTime or 0) < 0.1 or (button.IsOpen)) and theme.Colors.Accent or theme.Colors.Separator
             
             self:_AnimateAndApplyColor(button.Background, targetBgColor)
             self:_AnimateAndApplyColor(button.Border, targetBorderColor)
             self:_AnimateAndApplyColor(button.Label, targetTextColor)
             if button.Icon then self:_AnimateAndApplyColor(button.Icon, targetTextColor) end

             if has_icon and button.Icon then local iconX, iconY = x + 12, y + (height / 2) - (button.Icon.Size.y / 2); button.Icon.Position = {iconX, iconY}; local labelX, labelY = iconX + button.Icon.Size.x + 5, y + (height / 2) - (button.Label.Size / 2); button.Label.Position = {labelX, labelY}; button.Label.Center = false else button.Label.Position = {x + width / 2, y + (height / 2) - (button.Label.Size / 2)}; button.Label.Center = true end
             button.ClickRegion = {x1 = x, y1 = y, x2 = x + width, y2 = y + height}
        end

        local btnWidth, btnHeight, spacing = 75, 30, 15
        local createNewBtnWidth = 120
        local btnY = startY - (btnHeight / 2)
        local currentX = startX

        renderHeaderButton(Core.HeaderButtons.Save, currentX, btnY, btnWidth, btnHeight, true, false)
        currentX = currentX + btnWidth + spacing
        
        renderHeaderButton(Core.HeaderButtons.ViewESP, currentX, btnY, btnWidth, btnHeight, false, false)
        currentX = currentX + btnWidth + spacing

        if self.Window.ActiveTab == "Configs" then
            renderHeaderButton(Core.HeaderButtons.CreateNew, currentX, btnY, createNewBtnWidth, btnHeight, true, true)
        else
            self:_SetVisibility(Core.HeaderButtons.CreateNew.Background, false); self:_SetVisibility(Core.HeaderButtons.CreateNew.Border, false); self:_SetVisibility(Core.HeaderButtons.CreateNew.Label, false); self:_SetVisibility(Core.HeaderButtons.CreateNew.Icon, false);
        end
        
        local settingsIcon = Core.HeaderButtons.Settings.Icon
        local settingsX = rightPanelX + (self.Window.Width - sidebarWidth + self.Window.PanelOverlap) - settingsIcon.Size.x - 20 - 30
        local settingsY = startY - (settingsIcon.Size.y / 2)
        self:_SetVisibility(settingsIcon, true); settingsIcon.Position = {settingsX, settingsY}; Core.HeaderButtons.Settings.ClickRegion = {x1 = settingsX, y1 = settingsY, x2 = settingsX + settingsIcon.Size.x, y2 = settingsY + settingsIcon.Size.y}
        self:_AnimateAndApplyColor(settingsIcon, theme.Colors.TextSecondary)
    end
    
    self:_SetVisibility(Core.ViewESPPanel, Core.HeaderButtons.ViewESP.IsOpen); self:_SetVisibility(Core.ViewESPPanelBorder, Core.HeaderButtons.ViewESP.IsOpen)
    if Core.HeaderButtons.ViewESP.IsOpen then 
        local panelX = windowX + self.Window.Width + 11; 
        self:_AnimateAndApplyColor(Core.ViewESPPanel, theme.Colors.SectionBackground)
        self:_AnimateAndApplyColor(Core.ViewESPPanelBorder, theme.Colors.Separator)
        self:_AnimateAndApplyColor(Core.ViewESPImage, {255,255,255,255})
        Core.ViewESPPanel.Position = {panelX, windowY}; Core.ViewESPPanel.Size = {200, 310}; 
        Core.ViewESPPanelBorder.Position = {panelX, windowY}; Core.ViewESPPanelBorder.Size = {200, 310}; 
        if Core.ViewESPImage then self:_SetVisibility(Core.ViewESPImage, true); local imageX, imageY = panelX + 3, windowY + 3; Core.ViewESPImage.Position = {imageX, imageY}; Core.ViewESPImage.Size = {194, 304}; end
    elseif Core.ViewESPImage then self:_SetVisibility(Core.ViewESPImage, false) end

    self:_RenderTabs(windowX, windowY + headerHeight, sidebarWidth)
    
    if self.Window.ActiveTab == "Configs" then
        self:_RenderConfigsTab(rightPanelX, windowY, headerHeight)
        for _, section in ipairs(self.UI.Sections) do
            for _, obj in pairs(section.Drawing) do self:_SetVisibility(obj, false) end
            for _, el in ipairs(section.Elements) do 
                for _, obj in pairs(el) do if type(obj) == 'table' and obj.Visible ~= nil then self:_SetVisibility(obj, false) end end 
                if el.OptionList then for _, opt in ipairs(el.OptionList) do self:_SetVisibility(opt, false) end end
                if el.Glow then self:_HideGlowEffect(el.Glow) end
            end
        end
    else
        self:_RenderSections(rightPanelX, windowY, headerHeight)
        local configsTab = self.UI.Core.ConfigsTab
        self:_SetVisibility(configsTab.MyItemsLabel, false)
        self:_SetVisibility(configsTab.Scrollbar.Background, false)
        self:_SetVisibility(configsTab.Scrollbar.Nub, false)
        for _, item in ipairs(configsTab.Items) do
            for _, obj in pairs(item.Drawing) do
                 if type(obj) == 'table' then
                     for _, sub_obj in pairs(obj) do if type(sub_obj) == 'table' and sub_obj.Visible ~= nil then self:_SetVisibility(sub_obj, false) end end
                     if obj.Visible ~= nil then self:_SetVisibility(obj, false) end
                 end
            end
        end
        local popup = configsTab.OptionsPopup
        if popup.IsOpen then popup.IsOpen = false end
    end
    
    self:_RenderSaveTooltip()
    self:_RenderConfigOptionsPopup()
    self:_RenderPlayerESPSettingsPopup()
    self:_RenderAboutWindow(mouse_pos)
    self:_RenderEditStyleWindow()
    self:_RenderColorPickerWindow()
    self.Window.LastRenderedTab = self.Window.ActiveTab
end

function Library:_RenderTabs(x, y, width)
    local currentY = y + 25
    local theme = self.ActiveTheme

    for _, group in ipairs(self.UI.TabGroups) do
        if group.Header then
            self:_SetVisibility(group.Header, true)
            self:_AnimateAndApplyColor(group.Header, theme.Colors.TabHeader)
            group.Header.Position = {x + 25, currentY}
        end
        currentY = currentY + theme.Fonts.TabHeaderSize + 10

        for _, tab in ipairs(group.Tabs) do
            local tabHeight = theme.Fonts.TabSize + 10
            local is_active = (self.Window.ActiveTab == tab.Name)
            local target_text_color = is_active and theme.Colors.TextPrimary or theme.Colors.TextSecondary
            local startX = x + 25

            if tab.Icon then
                self:_SetVisibility(tab.Icon, true)
                tab.Icon.Position = {startX, currentY + (tabHeight / 2) - (theme.IconSize / 2)}
                local iconColor = (tab.Name == "Players" or tab.Name == "Configs") and theme.Colors.Accent or target_text_color
                self:_AnimateAndApplyColor(tab.Icon, iconColor)
                startX = startX + theme.IconSize + 8
            end

            if tab.Text then
                self:_SetVisibility(tab.Text, true)
                tab.Text.Position = {startX, currentY + (tabHeight / 2) - (tab.Text.Size / 2)}
                self:_AnimateAndApplyColor(tab.Text, target_text_color)
            end

            tab.ClickRegion = {x1 = x + 10, y1 = currentY, x2 = x + width - 10, y2 = currentY + tabHeight}

            -- [[ ИСПРАВЛЕННАЯ ЛОГИКА АНИМАЦИИ ]]
            if tab.Highlight then
                tab.Highlight.Position = {x + 10, currentY}
                tab.Highlight.Size = {self.Window.SidebarWidth - 20, tabHeight}
                
                -- Устанавливаем цвет напрямую, без лишней анимации
                local accentColor = theme.Colors.Accent
                tab.Highlight.Color = {accentColor[1], accentColor[2], accentColor[3]}

                -- Анимируем ТОЛЬКО прозрачность
                local state = self.AnimationState[tab.Highlight]
                if not state then
                    local initialOpacity = is_active and (theme.Transparency.ActiveTabHighlight or 0.28) or 0
                    state = { CurrentOpacity = initialOpacity }
                    self.AnimationState[tab.Highlight] = state
                end

                local targetOpacity = is_active and (theme.Transparency.ActiveTabHighlight or 0.28) or 0
                local speed_value = self.UI.Values["AboutAnimationSpeed"] or 1.6
                local animationSpeed = speed_value / 16.0

                state.CurrentOpacity = state.CurrentOpacity + (targetOpacity - state.CurrentOpacity) * animationSpeed
                tab.Highlight.Opacity = state.CurrentOpacity
            end

            currentY = currentY + tabHeight + 5
        end
        currentY = currentY + 15
    end
end

function Library:_RenderSections(panelX, panelY, headerHeight)
    -- Начальные координаты Y для левой и правой колонок
    local leftColumnY = panelY + headerHeight + 20
    local rightColumnY = panelY + headerHeight + 20
    local columnSpacing = 20
    local columnWidth = ((self.Window.Width - self.Window.SidebarWidth + self.Window.PanelOverlap) - (columnSpacing * 3)) / 2
    local leftColumnX = panelX + columnSpacing
    local rightColumnX = leftColumnX + columnWidth + columnSpacing
    local theme = self.ActiveTheme

    local ANIMATION_SLIDE_DISTANCE = 15
    -- Определяем, изменилась ли вкладка, что запускает анимацию
    local tab_changed = self.Window.ActiveTab ~= self.Window.LastRenderedTab

    for _, section in ipairs(self.UI.Sections) do
        -- =================================================================
        -- [[ ЛОГИКА СОСТОЯНИЯ АНИМАЦИИ ]]
        -- Этот блок определяет, должна ли секция появляться, исчезать или быть статичной.
        -- =================================================================
        local is_active_now = section.ParentTab == self.Window.ActiveTab
        local was_active_before = section.ParentTab == self.Window.LastRenderedTab

        local is_appearing = is_active_now and tab_changed
        local is_disappearing = not is_active_now and was_active_before and tab_changed

        -- Получаем или создаем состояние анимации для этой секции
        local state_key = section.Drawing.Background
        local anim_state = self.AnimationState[state_key]
        if not anim_state then
            anim_state = { Opacity = is_active_now and 1 or 0, YOffset = 0 }
            self.AnimationState[state_key] = anim_state
        end

        -- Если секция появляется, сбрасываем ее анимацию в начальную точку
        if is_appearing then
            anim_state.Opacity = 0
            anim_state.YOffset = ANIMATION_SLIDE_DISTANCE -- Начинаем снизу
        end

        -- Определяем цель (конечное значение) для нашей анимации
        local targetOpacity = is_active_now and 1 or 0
        local targetYOffset = is_disappearing and ANIMATION_SLIDE_DISTANCE or 0 -- При исчезновении "уезжаем" вниз

        -- Интерполируем текущие значения к целевым для плавной анимации
        local speed_value = self.UI.Values["AboutAnimationSpeed"] or 1.6
        local animationSpeed = speed_value / 12.0
        anim_state.Opacity = anim_state.Opacity + (targetOpacity - anim_state.Opacity) * animationSpeed
        anim_state.YOffset = anim_state.YOffset + (targetYOffset - anim_state.YOffset) * animationSpeed

        local masterOpacity = anim_state.Opacity

        -- =================================================================
        -- [[ ИСПРАВЛЕНИЕ РАСПОЛОЖЕНИЯ И ПОЗИЦИОНИРОВАНИЯ ]]
        -- Новая логика, которая исправляет баги с "прыгающими" секциями.
        -- =================================================================

        -- Сначала динамически рассчитываем высоту секции
        local sectionHeight
        do
            local tempElementY = 28 -- Начинаем с высоты заголовка секции
            for _, el in ipairs(section.Elements) do
                tempElementY = tempElementY + 35 -- Примерное расстояние между элементами
                if (el.type == "Dropdown" or el.type == "Multidropdown") and el.IsOpen then
                    tempElementY = tempElementY + (#el.Options * 20) + 5 -- Добавляем место для открытого списка
                end
            end
            sectionHeight = tempElementY + 15 -- Добавляем финальный отступ
        end

        local sectionX, sectionY

        if is_active_now then
            -- Если секция активна, она является частью текущего макета.
            -- Рассчитываем её позицию и СРАЗУ ЖЕ увеличиваем Y для следующей секции в колонке.
            if section.Side == "Left" then
                sectionX, sectionY = leftColumnX, leftColumnY
                leftColumnY = leftColumnY + sectionHeight + columnSpacing
            else
                sectionX, sectionY = rightColumnX, rightColumnY
                rightColumnY = rightColumnY + sectionHeight + columnSpacing
            end
            -- Сохраняем эту "правильную" позицию. Когда секция начнет исчезать,
            -- она будет анимироваться именно из этой точки.
            section.lastRenderPos = { x = sectionX, y = sectionY }
        else
            -- Если секция неактивна (скрыта или исчезает), используем её последнюю
            -- сохраненную позицию, чтобы избежать прыжков.
            if section.lastRenderPos then
                sectionX, sectionY = section.lastRenderPos.x, section.lastRenderPos.y
            else
                -- Если у нее никогда не было позиции (например, первый кадр), прячем ее.
                sectionX, sectionY = -9999, -9999
            end
        end

        -- Если секция полностью исчезла, прекращаем её отрисовку для оптимизации.
        if masterOpacity < 0.01 then
            for _, obj in pairs(section.Drawing) do self:_SetVisibility(obj, false) end
            for _, el in ipairs(section.Elements) do for k, v in pairs(el) do if type(v) == 'table' and v.Visible ~= nil then self:_SetVisibility(v, false) end end; if el.OptionList then for _, opt in ipairs(el.OptionList) do self:_SetVisibility(opt, false) end end end
            if section.Glow then self:_HideGlowEffect(section.Glow) end
            for _, el in ipairs(section.Elements) do if el.Glow then self:_HideGlowEffect(el.Glow) end end
            continue -- Переходим к следующей секции
        end

        -- Конечная Y позиция для отрисовки, включая анимацию "сползания"
        local animatedY = sectionY + anim_state.YOffset

        -- =================================================================
        -- [[ ЛОГИКА ОТРИСОВКИ ]]
        -- Эта часть в основном такая же, как в твоём коде, но использует
        -- исправленные позиции и общую прозрачность `masterOpacity`.
        -- =================================================================
        local sDrawing = section.Drawing
        for _, obj in pairs(sDrawing) do self:_SetVisibility(obj, true) end
        self:_AnimateAndApplyColor(sDrawing.Background, theme.Colors.SectionBackground, masterOpacity)
        self:_AnimateAndApplyColor(sDrawing.Border, theme.Colors.Separator, masterOpacity)
        self:_AnimateAndApplyColor(sDrawing.Title, theme.Colors.TextPrimary, masterOpacity)
        self:_AnimateAndApplyColor(sDrawing.Separator, theme.Colors.Separator, masterOpacity)

        sDrawing.Background.Position = {sectionX, animatedY}
        sDrawing.Background.Size = {columnWidth, sectionHeight}
        sDrawing.Border.Position = {sectionX, animatedY}
        sDrawing.Border.Size = {columnWidth, sectionHeight}
        sDrawing.Title.Position = {sectionX + 10, animatedY + 8}
        local separatorLineY = animatedY + 8 + sDrawing.Title.Size + 5
        sDrawing.Separator.From = {sectionX + 10, separatorLineY}; sDrawing.Separator.To = {sectionX + columnWidth - 10, separatorLineY};

        local elementY = separatorLineY + 15

        for _, el in ipairs(section.Elements) do
            for k, v in pairs(el) do if type(v) == 'table' and v.Visible ~= nil then self:_SetVisibility(v, true) end end
            if el.OptionList then for i, opt in ipairs(el.OptionList) do self:_SetVisibility(opt, el.IsOpen) end end

            local currentElementY = elementY - separatorLineY + animatedY + 15
            self:_AnimateAndApplyColor(el.Label, theme.Colors.TextSecondary, masterOpacity)

            if el.type == "Toggle" then
                el.Label.Position = {sectionX + 10, currentElementY};
                local toggleBackX = sectionX + columnWidth - el.Size.width - 15
                el.Back.Position = {toggleBackX, currentElementY + 2}; el.Back.Size = {el.Size.width, el.Size.height}; el.ClickRegion = {x1 = toggleBackX, y1 = currentElementY, x2 = toggleBackX + el.Size.width, y2 = currentElementY + el.Size.height + 4}
                local is_on = self.UI.Values[el.id]
                local nubY = currentElementY + 2 + el.Size.height / 2
                el.Nub.Position = is_on and {toggleBackX + el.Size.width - 5, nubY} or {toggleBackX + 5, nubY}
                local targetBackColor = is_on and self:_DarkenColor(theme.Colors.Accent, 0.3) or theme.Colors.DarkGray
                local targetNubColor = is_on and theme.Colors.Accent or theme.Colors.LightGray
                self:_AnimateAndApplyColor(el.Back, targetBackColor, masterOpacity)
                self:_AnimateAndApplyColor(el.Nub, targetNubColor, masterOpacity)
                if el.HasSettings and el.SettingsIcon then self:_AnimateAndApplyColor(el.SettingsIcon, theme.Colors.TextSecondary, masterOpacity); local iconX = toggleBackX - el.SettingsIcon.Size.x - 10; el.SettingsIcon.Position = {iconX, currentElementY}; el.SettingsClickRegion = {x1 = iconX, y1 = currentElementY, x2 = iconX + el.SettingsIcon.Size.x, y2 = currentElementY + el.SettingsIcon.Size.y} end
                elementY = elementY + 35

            elseif el.type == "Slider" then
                el.Label.Position = {sectionX + 10, currentElementY};
                local sliderBackX = sectionX + 100; local sliderBackWidth = columnWidth - 110 - 50
                el.Back.Position = {sliderBackX, currentElementY + 8}; el.Back.Size = {sliderBackWidth, 2}; el.ClickRegion = { x1 = sliderBackX, y1 = currentElementY - 2, x2 = sliderBackX + sliderBackWidth, y2 = currentElementY + 18 };
                local value_percentage = math.clamp((self.UI.Values[el.id] - el.Min) / (el.Max - el.Min), 0, 1); local nubX = sliderBackX + sliderBackWidth * value_percentage
                el.LeftFill.Position = {sliderBackX, currentElementY + 8}; el.LeftFill.Size = {nubX - sliderBackX, 2};
                el.RightFill.Position = {nubX, currentElementY + 8}; el.RightFill.Size = {sliderBackX + sliderBackWidth - nubX, 2};
                el.Nub.Position = {nubX, currentElementY + 9};
                local valueText = tostring(math.floor(self.UI.Values[el.id])); local valueTextX = sectionX + columnWidth - 40
                el.ValueText.Text = valueText; el.ValueText.Position = {valueTextX, currentElementY};

                self:_AnimateAndApplyColor(el.LeftFill, theme.Colors.Accent, masterOpacity);
                -- [[ ИСПРАВЛЕНИЕ ЦВЕТА СЛАЙДЕРА ]]
                -- Используем DarkGray вместо DarkBlue, чтобы он выглядел так же, как фон выключенного переключателя, и не казался черным.
                self:_AnimateAndApplyColor(el.RightFill, theme.Colors.DarkGray, masterOpacity);
                self:_AnimateAndApplyColor(el.Nub, theme.Colors.Accent, masterOpacity);
                self:_AnimateAndApplyColor(el.ValueText, theme.Colors.TextPrimary, masterOpacity);
                elementY = elementY + 35

            elseif el.type == "Dropdown" or el.type == "Multidropdown" then
                el.Label.Position = {sectionX + 10, currentElementY + 5};
                local dropdownButtonX, dropdownButtonY = sectionX + columnWidth - el.Size.width - 15, currentElementY
                el.Button.Position = {dropdownButtonX, dropdownButtonY}; el.Button.Size = {el.Size.width, el.Size.height}
                local textToShow = (el.type == "Dropdown") and self.UI.Values[el.id] or (#self.UI.Values[el.id] == 0 and "..." or table.concat(self.UI.Values[el.id], ", ")); if #textToShow > 11 then textToShow = string.sub(textToShow, 1, 10) .. "..." end
                el.ButtonText.Position = { dropdownButtonX + 5, dropdownButtonY + el.Size.height / 2 - el.ButtonText.Size / 2 }; el.ButtonText.Text = textToShow;
                local arrowX, arrowY = dropdownButtonX + el.Size.width - 15, dropdownButtonY + el.Size.height / 2
                el.ArrowLine1.From = {arrowX, arrowY - 2}; el.ArrowLine1.To = {arrowX + 5, arrowY + 3}; el.ArrowLine2.From = {arrowX + 5, arrowY + 3}; el.ArrowLine2.To = {arrowX + 10, arrowY - 2}
                el.ClickRegion = { x1 = dropdownButtonX, y1 = dropdownButtonY, x2 = dropdownButtonX + el.Size.width, y2 = dropdownButtonY + el.Size.height }

                self:_AnimateAndApplyColor(el.Button, theme.Colors.DarkBlue, masterOpacity);
                self:_AnimateAndApplyColor(el.ButtonText, theme.Colors.TextPrimary, masterOpacity);
                self:_AnimateAndApplyColor(el.ArrowLine1, theme.Colors.TextPrimary, masterOpacity);
                self:_AnimateAndApplyColor(el.ArrowLine2, theme.Colors.TextPrimary, masterOpacity);

                if el.IsOpen then
                    self:_AnimateAndApplyColor(el.OptionBackground, theme.Colors.SectionBackground, masterOpacity);
                    self:_AnimateAndApplyColor(el.BorderLeft, theme.Colors.Separator, masterOpacity);
                    self:_AnimateAndApplyColor(el.BorderRight, theme.Colors.Separator, masterOpacity);
                    self:_AnimateAndApplyColor(el.BorderBottom, theme.Colors.Separator, masterOpacity);
                    local optionY_offset = dropdownButtonY + el.Size.height + 5
                    for i, option in ipairs(el.OptionList) do
                         option.Position.y = optionY_offset + ((i-1) * 20) -- Make sure y is updated
                         local isSelected = (el.type == "Dropdown" and self.UI.Values[el.id] == el.Options[i]) or (el.type == "Multidropdown" and table.find(self.UI.Values[el.id], el.Options[i]));
                         local targetOptColor = isSelected and theme.Colors.Accent or theme.Colors.TextPrimary
                         self:_AnimateAndApplyColor(option, targetOptColor, masterOpacity)
                    end
                end
                elementY = elementY + 35
                if el.IsOpen then elementY = elementY + (#el.Options * 20) + 5 end
            end
        end
    end
end

function Library:_RenderConfigsTab(panelX, panelY, headerHeight)
    local configs = self.UI.Core.ConfigsTab
    local theme = self.ActiveTheme

    self:_SetVisibility(configs.MyItemsLabel, true)
    self:_SetVisibility(configs.Scrollbar.Background, true)
    self:_SetVisibility(configs.Scrollbar.Nub, true)
    self:_AnimateAndApplyColor(configs.MyItemsLabel, theme.Colors.TextPrimary)
    self:_AnimateAndApplyColor(configs.Scrollbar.Background, theme.Colors.DarkBlue)
    self:_AnimateAndApplyColor(configs.Scrollbar.Nub, theme.Colors.Accent)

    for _, item in ipairs(configs.Items) do
        local d = item.Drawing
        self:_SetVisibility(d.Background, true); self:_SetVisibility(d.Border, true); self:_SetVisibility(d.Name, true); self:_SetVisibility(d.Modified, true); self:_SetVisibility(d.Author, true); self:_SetVisibility(d.OptionsButton.Dot1, true); self:_SetVisibility(d.OptionsButton.Dot2, true); self:_SetVisibility(d.OptionsButton.Dot3, true)
        
        self:_AnimateAndApplyColor(d.Background, theme.Colors.SectionBackground)
        self:_AnimateAndApplyColor(d.Border, theme.Colors.Separator)
        self:_AnimateAndApplyColor(d.Name, theme.Colors.TextPrimary)
        self:_AnimateAndApplyColor(d.Modified, theme.Colors.TextSecondary)
        self:_AnimateAndApplyColor(d.Author, theme.Colors.TextSecondary)
        self:_AnimateAndApplyColor(d.OptionsButton.Dot1, theme.Colors.TextSecondary)
        self:_AnimateAndApplyColor(d.OptionsButton.Dot2, theme.Colors.TextSecondary)
        self:_AnimateAndApplyColor(d.OptionsButton.Dot3, theme.Colors.TextSecondary)
    end

    local startX = panelX + 20
    local startY = panelY + headerHeight + 20
    local contentWidth = (self.Window.Width - self.Window.SidebarWidth + self.Window.PanelOverlap) - 40
    local scrollbarWidth = 6
    local contentAreaWidth = contentWidth - scrollbarWidth - 10
    configs.MyItemsLabel.Position = {startX, startY}
    local currentY = startY + 25
    local itemHeight = 60
    local itemSpacing = 10

    for i, item in ipairs(configs.Items) do
        local d = item.Drawing
        d.Background.Position = {startX, currentY}; d.Background.Size = {contentAreaWidth, itemHeight}
        d.Border.Position = {startX, currentY}; d.Border.Size = {contentAreaWidth, itemHeight}
        d.Name.Text = item.Name; d.Name.Position = {startX + 15, currentY + 12}
        d.Modified.Text = "Modified: " .. item.Modified; d.Modified.Position = {startX + 15, currentY + 35}
        if d.Modified.TextBounds and d.Modified.TextBounds.x then
            d.Author.Text = "Author: " .. item.Author
            d.Author.Position = {startX + 15 + d.Modified.TextBounds.x + 10, currentY + 35}
        end
        local btnWidth, btnHeight = 85, 28
        local btnX = startX + contentAreaWidth - btnWidth - 15
        local btnY = currentY + (itemHeight / 2) - (btnHeight / 2)
        local optionsBtnX = btnX - 25; local optionsBtnY = currentY + (itemHeight / 2)
        d.OptionsButton.Dot1.Position = {optionsBtnX - 6, optionsBtnY}; d.OptionsButton.Dot2.Position = {optionsBtnX, optionsBtnY}; d.OptionsButton.Dot3.Position = {optionsBtnX + 6, optionsBtnY}
        d.OptionsButton.ClickRegion = {x1 = optionsBtnX - 10, y1 = optionsBtnY - 10, x2 = optionsBtnX + 10, y2 = optionsBtnY + 10}
        local isLoaded = (configs.LoadedConfigName == item.Name)
        self:_SetVisibility(d.SaveButton.Background, isLoaded); self:_SetVisibility(d.SaveButton.Border, isLoaded); self:_SetVisibility(d.SaveButton.Icon, isLoaded); self:_SetVisibility(d.SaveButton.Label, isLoaded)
        self:_SetVisibility(d.LoadButton.Background, not isLoaded); self:_SetVisibility(d.LoadButton.Icon, not isLoaded); self:_SetVisibility(d.LoadButton.Label, not isLoaded)
        
        if isLoaded then
            local saveBtn = d.SaveButton
            self:_AnimateAndApplyColor(saveBtn.Background, theme.Colors.SectionBackground)
            self:_AnimateAndApplyColor(saveBtn.Border, theme.Colors.Accent)
            self:_AnimateAndApplyColor(saveBtn.Icon, theme.Colors.TextPrimary)
            self:_AnimateAndApplyColor(saveBtn.Label, theme.Colors.TextPrimary)
            saveBtn.Background.Position = {btnX, btnY}; saveBtn.Background.Size = {btnWidth, btnHeight}
            saveBtn.Border.Position = {btnX, btnY}; saveBtn.Border.Size = {btnWidth, btnHeight}
            local iconX = btnX + 15
            saveBtn.Icon.Position = {iconX, btnY + (btnHeight / 2) - (saveBtn.Icon.Size.y / 2)}
            saveBtn.Label.Position = {iconX + saveBtn.Icon.Size.x + 8, btnY + (btnHeight / 2) - (saveBtn.Label.Size / 2)}
            saveBtn.ClickRegion = {x1 = btnX, y1 = btnY, x2 = btnX + btnWidth, y2 = btnY + btnHeight}
        else
            local loadBtn = d.LoadButton
            local accentColor = theme.Colors.Accent
            local textColorForAccent = self:_GetTextColorForBackground(accentColor)
            
            self:_AnimateAndApplyColor(loadBtn.Background, accentColor)
            self:_AnimateAndApplyColor(loadBtn.Icon, textColorForAccent)
            self:_AnimateAndApplyColor(loadBtn.Label, textColorForAccent)

            loadBtn.Background.Position = {btnX, btnY}; loadBtn.Background.Size = {btnWidth, btnHeight}
            local iconX = btnX + 15
            loadBtn.Icon.Position = {iconX, btnY + (btnHeight / 2) - (loadBtn.Icon.Size.y / 2)}
            loadBtn.Label.Position = {iconX + loadBtn.Icon.Size.x + 8, btnY + (btnHeight / 2) - (loadBtn.Label.Size / 2)}
            loadBtn.ClickRegion = {x1 = btnX, y1 = btnY, x2 = btnX + btnWidth, y2 = btnY + btnHeight}
        end
        currentY = currentY + itemHeight + itemSpacing
    end
    local scrollbarX = startX + contentAreaWidth + 5
    local scrollbarHeight = self.Window.Height - headerHeight - 40
    configs.Scrollbar.Background.Position = {scrollbarX, startY}
    configs.Scrollbar.Background.Size = {scrollbarWidth, scrollbarHeight}
    local nubHeight = 80
    configs.Scrollbar.Nub.Position = {scrollbarX, startY}
    configs.Scrollbar.Nub.Size = {scrollbarWidth, nubHeight}
end

function Library:_RenderConfigOptionsPopup()
    local configs = self.UI.Core.ConfigsTab
    local popup = configs.OptionsPopup
    local isVisible = popup.IsOpen
    local theme = self.ActiveTheme

    self:_SetVisibility(popup.Background, isVisible)
    self:_SetVisibility(popup.Border, isVisible)
    self:_SetVisibility(popup.IncludeStyleToggle.Label, isVisible)
    self:_SetVisibility(popup.IncludeStyleToggle.Back, isVisible)
    self:_SetVisibility(popup.IncludeStyleToggle.Nub, isVisible)

    if not isVisible then
        if popup.Glow then self:_HideGlowEffect(popup.Glow) end
        return
    end

    self:_AnimateAndApplyColor(popup.Background, theme.Colors.SectionBackground)
    self:_AnimateAndApplyColor(popup.Border, theme.Colors.Separator)
    self:_AnimateAndApplyColor(popup.IncludeStyleToggle.Label, theme.Colors.TextSecondary)
    
    local pW, pH = 150, 50
    local pX, pY = popup.Pos.x, popup.Pos.y
    popup.ClickRegion = {x1=pX, y1=pY, x2=pX+pW, y2=pY+pH}
    popup.Background.Position = {pX, pY}; popup.Background.Size = {pW, pH}
    popup.Border.Position = {pX, pY}; popup.Border.Size = {pW, pH}
    if popup.Glow then self:_RenderGlowEffect(popup.Glow, pX, pY, pW, pH, popup.Background.Rounding, theme.Colors.GlowColor) end

    local toggle = popup.IncludeStyleToggle
    local toggleY = pY + (pH / 2) - (toggle.Label.Size / 2)
    toggle.Label.Position = {pX + 10, toggleY}
    local toggleBackX = pX + pW - toggle.Size.width - 15
    toggle.Back.Position = {toggleBackX, toggleY + 2}; toggle.Back.Size = {toggle.Size.width, toggle.Size.height}; toggle.ClickRegion = {x1 = toggleBackX, y1 = toggleY, x2 = toggleBackX + toggle.Size.width, y2 = toggleY + toggle.Size.height + 4}
    
    local targetBackColor, targetNubColor
    if self.UI.Values[toggle.id] then
        targetBackColor = theme.Colors.ToggleEnabledBackground or self:_DarkenColor(theme.Colors.Accent, 0.3)
        targetNubColor = theme.Colors.Accent
        toggle.Nub.Position = {toggleBackX + toggle.Size.width - 5, toggleY + 2 + toggle.Size.height/2}
    else
        targetBackColor = theme.Colors.DarkGray
        targetNubColor = theme.Colors.LightGray
        toggle.Nub.Position = {toggleBackX + 5, toggleY + 2 + toggle.Size.height/2}
    end
    self:_AnimateAndApplyColor(toggle.Back, targetBackColor)
    self:_AnimateAndApplyColor(toggle.Nub, targetNubColor)
end

function Library:_InputLoop()
    local mouse_pos = getmouseposition()
    if not mouse_pos then return end

    local mouse_x, mouse_y = self:_SafeNumber(mouse_pos.x, 0), self:_SafeNumber(mouse_pos.y, 0)
    local is_left_pressed_now = isleftpressed()
    local is_left_clicked = was_left_pressed and not is_left_pressed_now

    local picker = self.UI.Popups.ColorPicker
    local style_window = self.UI.Popups.EditStyle
    local configsTab = self.UI.Core.ConfigsTab
    local about_window = self.UI.Core.AboutWindow

    if is_left_pressed_now then
        if not is_dragging_something then
            is_dragging_something = true
            local about_slider = about_window.AnimationSpeedSlider
            
            if self.UI.Popups.About.IsOpen and self:_IsPointInRegion(mouse_x, mouse_y, about_slider.ClickRegion) then
                about_slider.IsDragging = true
            elseif picker.IsOpen and self:_IsPointInRegion(mouse_x, mouse_y, picker.HueSliderRegion) then
                picker.isDraggingHue = true
            elseif picker.IsOpen and self:_IsPointInRegion(mouse_x, mouse_y, picker.OpacitySliderRegion) then
                picker.isDraggingOpacity = true
            elseif picker.IsOpen and self:_IsPointInRegion(mouse_x, mouse_y, picker.SaturationValueRegion) then
                picker.isDraggingSaturationValue = true
            elseif not self.UI.Popups.About.IsOpen and not self.UI.Popups.PlayerESP.IsOpen and not self.UI.Popups.EditStyle.IsOpen and not self.UI.Popups.ColorPicker.IsOpen and not configsTab.OptionsPopup.IsOpen then
                 local started_slider_drag = false
                 if self.Window.ActiveTab ~= "Configs" then
                    for _, section in ipairs(self.UI.Sections) do
                        if section.ParentTab == self.Window.ActiveTab then
                            for _, el in ipairs(section.Elements) do
                                if el.type == "Slider" and self:_IsPointInRegion(mouse_x, mouse_y, el.ClickRegion) then
                                    el.IsDragging = true; started_slider_drag = true; break
                                end
                            end
                        end
                        if started_slider_drag then break end
                    end
                 end
                 if not started_slider_drag then
                    local header_drag_region = {x1 = self.Window.X, y1 = self.Window.Y, x2 = self.Window.X + self.Window.Width, y2 = self.Window.Y + self.Window.HeaderHeight}
                    local on_header_button = self:_IsPointInRegion(mouse_x, mouse_y, self.UI.Core.HeaderButtons.Save.ClickRegion) or self:_IsPointInRegion(mouse_x, mouse_y, self.UI.Core.HeaderButtons.ViewESP.ClickRegion) or self:_IsPointInRegion(mouse_x, mouse_y, self.UI.Core.HeaderButtons.CreateNew.ClickRegion) or self:_IsPointInRegion(mouse_x, mouse_y, self.UI.Core.HeaderButtons.Settings.ClickRegion)
                    if self:_IsPointInRegion(mouse_x, mouse_y, header_drag_region) and not on_header_button then
                        self.Window.IsDragging = true; drag_offset = {x = mouse_x - self.Window.X, y = mouse_y - self.Window.Y}
                    else
                        is_dragging_something = false
                    end
                 end
            else
                is_dragging_something = false
            end
        end
    else
        if self.Window.IsDragging then self.Window.IsDragging = false end
        for _, section in ipairs(self.UI.Sections) do for _, el in ipairs(section.Elements) do if el.IsDragging then el.IsDragging = false end end end
        if about_window.AnimationSpeedSlider.IsDragging then about_window.AnimationSpeedSlider.IsDragging = false end
        if picker.isDraggingHue then picker.isDraggingHue = false end
        if picker.isDraggingOpacity then picker.isDraggingOpacity = false end
        if picker.isDraggingSaturationValue then picker.isDraggingSaturationValue = false end
    end

    if self.Window.IsDragging then self.Window.X = mouse_x - drag_offset.x; self.Window.Y = mouse_y - drag_offset.y; end
    for _, section in ipairs(self.UI.Sections) do
        for _, el in ipairs(section.Elements) do
            if el.type == "Slider" and el.IsDragging then
                local sliderBackX, sliderBackWidth = self:_SafeNumber(el.Back.Position.x, 0), self:_SafeNumber(el.Back.Size.x, 1)
                local mouse_relative_x = math.clamp(mouse_x - sliderBackX, 0, sliderBackWidth)
                local percentage = sliderBackWidth > 0 and (mouse_relative_x / sliderBackWidth) or 0
                local raw_value = el.Min + (el.Max - el.Min) * percentage
                local stepped_value = math.floor(raw_value / el.Increment + 0.5) * el.Increment
                local clamped_value = math.clamp(stepped_value, el.Min, el.Max)
                if clamped_value ~= self.UI.Values[el.id] then self.UI.Values[el.id] = clamped_value; if el.Callback then el.Callback(self.UI.Values[el.id]); end end
            end
        end
    end
    local about_slider = about_window.AnimationSpeedSlider
    if about_slider.IsDragging then
        local sliderBackX, sliderBackWidth = self:_SafeNumber(about_slider.Back.Position.x, 0), self:_SafeNumber(about_slider.Back.Size.x, 1)
        local mouse_relative_x = math.clamp(mouse_x - sliderBackX, 0, sliderBackWidth)
        local percentage = sliderBackWidth > 0 and (mouse_relative_x / sliderBackWidth) or 0
        local raw_value = about_slider.Min + (about_slider.Max - about_slider.Min) * percentage
        local stepped_value = math.floor(raw_value / about_slider.Increment + 0.5) * about_slider.Increment
        local clamped_value = math.clamp(stepped_value, about_slider.Min, about_slider.Max)
        if clamped_value ~= self.UI.Values[about_slider.id] then self.UI.Values[about_slider.id] = clamped_value; end
    end
    
    local function update_color_picker()
        local new_rgb = self:_HSVtoRGB(picker.h, picker.s, picker.v)
        local new_color = {new_rgb[1], new_rgb[2], new_rgb[3], picker.a * 255}
        
        style_window.EditingTheme.Colors[picker.EditingColorName] = new_color

        if self.UI.Values.EditStyleRealTime and self.TempTheme then
             self.TempTheme.Colors[picker.EditingColorName] = new_color
        end
    end

    if picker.isDraggingHue then
        local region = picker.HueSliderRegion
        local percentage = math.clamp((mouse_x - region.x1) / (region.x2 - region.x1), 0, 1)
        picker.h = percentage
        update_color_picker()
    end
    if picker.isDraggingOpacity then
        local region = picker.OpacitySliderRegion
        local percentage = math.clamp((mouse_x - region.x1) / (region.x2 - region.x1), 0, 1)
        picker.a = percentage
        update_color_picker()
    end
    if picker.isDraggingSaturationValue then
        local region = picker.SaturationValueRegion
        picker.s = math.clamp((mouse_x - region.x1) / (region.x2 - region.x1), 0, 1)
        picker.v = 1 - math.clamp((mouse_y - region.y1) / (region.y2 - region.y1), 0, 1)
        update_color_picker()
    end
    
    if about_window and self.UI.Popups.About.IsOpen then
        local is_hovering_any_circle = false
        for _, circle in ipairs(about_window.StyleCircles) do
            if self:_IsPointInRegion(mouse_x, mouse_y, circle.ClickRegion) then
                is_hovering_any_circle = true
                if about_window.HoveredThemeCircle.Name ~= circle.Name then
                    about_window.HoveredThemeCircle.Name = circle.Name
                    about_window.HoveredThemeCircle.HoverStartTime = tick()
                end
                break
            end
        end
        if not is_hovering_any_circle then
            about_window.HoveredThemeCircle.Name = nil
        end
    end

    if is_left_clicked then
        if is_dragging_something then
            is_dragging_something = false
        else
            local click_was_handled = false
            local clicked_dropdown_button = nil
            
            local function revert_realtime_changes()
                if self.UI.Values.EditStyleRealTime and self.PreEditThemeName then
                    self.ActiveTheme = self.Themes[self.PreEditThemeName] or self.Themes.Blue
                    self.UI.Values.AboutSelectedStyle = self.ActiveTheme.Name
                end
                self.TempTheme = nil
                self.PreEditThemeName = nil
                self.UI.Values.EditStyleRealTime = false
            end

            if configsTab.OptionsPopup.IsOpen then
                click_was_handled = true
                local popup = configsTab.OptionsPopup
                if self:_IsPointInRegion(mouse_x, mouse_y, popup.IncludeStyleToggle.ClickRegion) then
                    self.UI.Values[popup.IncludeStyleToggle.id] = not self.UI.Values[popup.IncludeStyleToggle.id]
                elseif not self:_IsPointInRegion(mouse_x, mouse_y, popup.ClickRegion) then
                    popup.IsOpen = false
                end
            elseif picker.IsOpen then
                click_was_handled = true
                local picker_region = {x1=picker.Background.Position.x, y1=picker.Background.Position.y, x2=picker.Background.Position.x+picker.Background.Size.x, y2=picker.Background.Position.y+picker.Background.Size.y}
                if not self:_IsPointInRegion(mouse_x, mouse_y, picker_region) then
                    picker.IsOpen = false
                end
            elseif style_window.IsOpen then
                click_was_handled = true
                if self:_IsPointInRegion(mouse_x, mouse_y, style_window.CloseButton.ClickRegion) then
                    revert_realtime_changes()
                    style_window.IsOpen = false
                    style_window.IsEditingName = false
                elseif self:_IsPointInRegion(mouse_x, mouse_y, style_window.CancelButton.ClickRegion) then
                    revert_realtime_changes()
                    style_window.IsOpen = false
                    style_window.IsEditingName = false
                elseif self:_IsPointInRegion(mouse_x, mouse_y, style_window.SaveButton.ClickRegion) then
                    local newTheme = self:_DeepCopy(style_window.EditingTheme)
                    local newName = style_window.StyleNameInputText.Text
                    local originalName = style_window.EditingThemeName
                    
                    if newName == "" then newName = "Custom" end

                    if newName ~= originalName and self.Themes[originalName] and not self.Themes[originalName].IsPreset then
                        self.Themes[originalName] = nil
                    end
                    
                    if self.Themes[newName] and newName ~= originalName then
                        local i = 1
                        while self.Themes[newName .. " (" .. i .. ")"] do i = i + 1 end
                        newName = newName .. " (" .. i .. ")"
                    end
                    
                    newTheme.Name = newName
                    newTheme.IsPreset = false
                    self.Themes[newName] = newTheme
                    
                    self:_RebuildStyleCircles()
                    self.UI.Values.AboutSelectedStyle = newTheme.Name
                    self.ActiveTheme = newTheme
                    
                    self.TempTheme = nil
                    self.PreEditThemeName = nil
                    self.UI.Values.EditStyleRealTime = false
                    style_window.IsOpen = false
                    style_window.IsEditingName = false
                elseif self:_IsPointInRegion(mouse_x, mouse_y, style_window.RealTimeToggle.ClickRegion) then
                    self.UI.Values.EditStyleRealTime = not self.UI.Values.EditStyleRealTime
                    if self.UI.Values.EditStyleRealTime then
                        self.PreEditThemeName = self.ActiveTheme.Name
                        self.TempTheme = self:_DeepCopy(style_window.EditingTheme)
                        self.ActiveTheme = self.TempTheme
                    else
                        self.ActiveTheme = self.Themes[self.PreEditThemeName] or self.Themes.Blue
                        self.UI.Values.AboutSelectedStyle = self.ActiveTheme.Name
                        self.TempTheme = nil
                        self.PreEditThemeName = nil
                    end
                elseif self:_IsPointInRegion(mouse_x, mouse_y, style_window.StyleNameInputClickRegion) then
                    style_window.IsEditingName = true
                else
                    local clicked_color = false
                    for _, item in ipairs(style_window.ColorItems) do
                        if self:_IsPointInRegion(mouse_x, mouse_y, item.ClickRegion) then
                            picker.IsOpen = true
                            picker.EditingColorName = item.Name
                            picker.Pos = {x = mouse_x, y = mouse_y}
                            local color_to_edit = style_window.EditingTheme.Colors[item.Name]
                            picker.h, picker.s, picker.v, picker.a = self:_RGBtoHSV(color_to_edit[1], color_to_edit[2], color_to_edit[3], color_to_edit[4])
                            clicked_color = true
                            break
                        end
                    end
                    if not clicked_color then
                        style_window.IsEditingName = false
                    end
                end
            elseif self.UI.Popups.About.IsOpen then
                click_was_handled = true
                local about = self.UI.Core.AboutWindow
                local about_dropdown = about.DpiScaleDropdown

                if self:_IsPointInRegion(mouse_x, mouse_y, about.CloseButton.ClickRegion) then 
                    self.UI.Popups.About.IsOpen = false
                    if about_dropdown.IsOpen then about_dropdown.IsOpen = false end
                elseif self:_IsPointInRegion(mouse_x, mouse_y, about.AutoSaveToggle.ClickRegion) then 
                    self.UI.Values.AboutAutoSave = not self.UI.Values.AboutAutoSave
                elseif self:_IsPointInRegion(mouse_x, mouse_y, about_dropdown.ClickRegion) then 
                    about_dropdown.IsOpen = not about_dropdown.IsOpen
                elseif about_dropdown.IsOpen and self:_IsPointInRegion(mouse_x, mouse_y, {x1 = about_dropdown.Button.Position.x, y1 = about_dropdown.Button.Position.y + about_dropdown.Size.height, x2 = about_dropdown.Button.Position.x + about_dropdown.OptionBackground.Size.x, y2 = about_dropdown.Button.Position.y + about_dropdown.Size.height + about_dropdown.OptionBackground.Size.y}) then
                    local optionY = about_dropdown.Button.Position.y + about_dropdown.Size.height + 5
                    for i, option_text in ipairs(about_dropdown.OptionList) do
                        local optionRegion = {x1 = about_dropdown.Button.Position.x, y1 = optionY, x2 = about_dropdown.Button.Position.x + about_dropdown.Size.width, y2 = optionY + 20}
                        if self:_IsPointInRegion(mouse_x, mouse_y, optionRegion) then
                            self.UI.Values[about_dropdown.id] = about_dropdown.Options[i]
                            about_dropdown.IsOpen = false
                            break
                        end
                        optionY = optionY + 20
                    end
                else
                    local circle_clicked = false
                    for _, circle in ipairs(about.StyleCircles) do
                        if self:_IsPointInRegion(mouse_x, mouse_y, circle.ClickRegion) then
                            circle_clicked = true
                            if circle.IsAddButton then
                                self.CustomThemeCounter = self.CustomThemeCounter + 1
                                local newName = "Custom " .. self.CustomThemeCounter
                                style_window.EditingTheme = self:_DeepCopy(self.ActiveTheme)
                                style_window.EditingThemeName = newName
                                style_window.StyleNameInputText.Text = newName
                                style_window.IsOpen = true
                            else
                                self.UI.Values.AboutSelectedStyle = circle.Name
                                self.ActiveTheme = self.Themes[circle.Name]
                            end
                            break
                        end
                    end

                    if not circle_clicked then
                        if about_dropdown.IsOpen then about_dropdown.IsOpen = false
                        elseif not self:_IsPointInRegion(mouse_x, mouse_y, about.ClickRegion) then
                             self.UI.Popups.About.IsOpen = false
                        end
                    end
                end

            elseif self.UI.Popups.PlayerESP.IsOpen then
                 click_was_handled = true
                 local esppopup = self.UI.Popups.PlayerESP
                 if self:_IsPointInRegion(mouse_x, mouse_y, esppopup.ClickRegion) then
                     if self:_IsPointInRegion(mouse_x, mouse_y, esppopup.Keybind.ClickRegion) then esppopup.Keybind.IsListening = not esppopup.Keybind.IsListening end
                 else
                     esppopup.IsOpen = false; esppopup.Keybind.IsListening = false
                 end
            else
                if self.Window.ActiveTab == "Configs" then
                    local config_item_clicked = false
                    for i, item in ipairs(configsTab.Items) do
                        local d = item.Drawing
                        if configsTab.LoadedConfigName == item.Name and self:_IsPointInRegion(mouse_x, mouse_y, d.SaveButton.ClickRegion) then
                            self:_SaveConfig(item.Name)
                            config_item_clicked = true; break
                        elseif configsTab.LoadedConfigName ~= item.Name and self:_IsPointInRegion(mouse_x, mouse_y, d.LoadButton.ClickRegion) then
                            self:_LoadConfig(item.Name)
                            config_item_clicked = true; break
                        elseif self:_IsPointInRegion(mouse_x, mouse_y, d.OptionsButton.ClickRegion) then
                            local popup = configsTab.OptionsPopup
                            popup.IsOpen = not popup.IsOpen
                            popup.ItemIndex = i
                            popup.Pos = {x = mouse_x - 155, y = mouse_y}
                            config_item_clicked = true; break
                        end
                    end
                    if config_item_clicked then click_was_handled = true end
                end

                if not click_was_handled then
                    for _, section in ipairs(self.UI.Sections) do
                        if section.ParentTab == self.Window.ActiveTab then
                            for _, el in ipairs(section.Elements) do
                                if (el.type == "Dropdown" or el.type == "Multidropdown") and el.IsOpen then
                                    local dropdownButtonX = el.Button.Position.x
                                    local optionY = el.Button.Position.y + el.Size.height + 5
                                    for i, option_text in ipairs(el.OptionList) do
                                        local optionRegion = {x1 = dropdownButtonX, y1 = optionY, x2 = dropdownButtonX + el.Size.width, y2 = optionY + 20}
                                        if self:_IsPointInRegion(mouse_x, mouse_y, optionRegion) then
                                            if el.type == "Dropdown" then self.UI.Values[el.id] = el.Options[i]; if el.Callback then el.Callback(self.UI.Values[el.id]) end; el.IsOpen = false;
                                            else local opt = el.Options[i]; local found_idx = table.find(self.UI.Values[el.id], opt); if found_idx then table.remove(self.UI.Values[el.id], found_idx) else table.insert(self.UI.Values[el.id], opt) end; if el.Callback then el.Callback(self.UI.Values[el.id]) end; clicked_dropdown_button = el end
                                            click_was_handled = true; break
                                        end
                                        optionY = optionY + 20
                                    end
                                end
                                if click_was_handled then break end
                            end
                        end
                        if click_was_handled then break end
                    end
                end

                if not click_was_handled then
                    -- [ИЗМЕНЕНО] Управление кликами по кнопкам в шапке
                    local create_btn_region = self.UI.Core.HeaderButtons.CreateNew.ClickRegion
                    local save_btn_region = self.UI.Core.HeaderButtons.Save.ClickRegion
                    local view_esp_region = self.UI.Core.HeaderButtons.ViewESP.ClickRegion
                    local settings_region = self.UI.Core.HeaderButtons.Settings.ClickRegion

                    if self:_IsPointInRegion(mouse_x, mouse_y, create_btn_region) and self.Window.ActiveTab == "Configs" then
                        click_was_handled = true;
                        self.UI.Core.HeaderButtons.CreateNew.ClickTime = tick()
                        self:_CreateNewConfig()
                    elseif self:_IsPointInRegion(mouse_x, mouse_y, save_btn_region) then
                        click_was_handled = true; self.UI.Core.HeaderButtons.Save.ClickTime = tick();
                        if configsTab.LoadedConfigName ~= "" then self:_SaveConfig(configsTab.LoadedConfigName) end
                    elseif self:_IsPointInRegion(mouse_x, mouse_y, view_esp_region) then 
                        click_was_handled = true; self.UI.Core.HeaderButtons.ViewESP.IsOpen = not self.UI.Core.HeaderButtons.ViewESP.IsOpen; self.UI.Core.HeaderButtons.ViewESP.ClickTime = tick();
                    elseif self:_IsPointInRegion(mouse_x, mouse_y, settings_region) then 
                        click_was_handled = true; self.UI.Popups.About.IsOpen = not self.UI.Popups.About.IsOpen;
                    else
                        for _, group in ipairs(self.UI.TabGroups) do for _, tab in ipairs(group.Tabs) do if self:_IsPointInRegion(mouse_x, mouse_y, tab.ClickRegion) then self.Window.ActiveTab = tab.Name; click_was_handled = true; break; end end if click_was_handled then break; end end
                        if not click_was_handled then
                            if self.Window.ActiveTab ~= "Configs" then
                                for _, section in ipairs(self.UI.Sections) do
                                    if section.ParentTab == self.Window.ActiveTab then
                                        for _, el in ipairs(section.Elements) do
                                            if el.HasSettings and self:_IsPointInRegion(mouse_x, mouse_y, el.SettingsClickRegion) then
                                                local espPopup = self.UI.Popups.PlayerESP; espPopup.IsOpen = not espPopup.IsOpen; espPopup.Pos = {x = mouse_x, y = mouse_y}; click_was_handled = true; break
                                            elseif self:_IsPointInRegion(mouse_x, mouse_y, el.ClickRegion) then
                                                click_was_handled = true
                                                if el.type == "Toggle" then self.UI.Values[el.id] = not self.UI.Values[el.id]; if el.Callback then el.Callback(self.UI.Values[el.id]) end;
                                                elseif el.type == "Dropdown" or el.type == "Multidropdown" then clicked_dropdown_button = el; el.IsOpen = not el.IsOpen;
                                                end; break
                                            end
                                        end
                                    end
                                    if click_was_handled then break end
                                end
                            end
                        end
                    end
                end
                for _, section in ipairs(self.UI.Sections) do for _, el in ipairs(section.Elements) do if (el.type == "Dropdown" or el.type == "Multidropdown") and el ~= clicked_dropdown_button then el.IsOpen = false; end end end
            end
        end
    end

    local popupKeybind = self.UI.Popups.PlayerESP.Keybind
    if popupKeybind.IsListening then
        local key = getpressedkey()
        if key and key ~= "None" then if self.UI.Values[popupKeybind.id] ~= key then self.UI.Values[popupKeybind.id] = key; end; popupKeybind.IsListening = false; end
    end
    
    if style_window.IsEditingName then
        local key = getpressedkey()
        if key and key ~= "None" and key ~= style_window.last_key_pressed and (tick() - style_window.last_key_press_time > style_window.key_press_delay) then
            local current_text = style_window.StyleNameInputText.Text
            if key == "Backspace" then
                if #current_text > 0 then style_window.StyleNameInputText.Text = string.sub(current_text, 1, -2) end
            elseif key == "Space" then
                if #current_text < 20 then style_window.StyleNameInputText.Text = current_text .. " " end
            elseif string.len(key) == 1 and string.match(key, "%w") then
                if #current_text < 20 then style_window.StyleNameInputText.Text = current_text .. key end
            end
            style_window.last_key_press_time = tick()
            style_window.last_key_pressed = key
        elseif key == "None" then
             style_window.last_key_pressed = "None"
        end
    end

    local esp_bind = self.UI.Values["PlayerESPBind"]
    if esp_bind and esp_bind ~= "none" then
        local currentTime = tick()
        if getpressedkey() and getpressedkey() ~= "None" and getpressedkey() == esp_bind and (currentTime - lastToggleTime >= toggleDelay) then
            self.UI.Values["PlayerESP"] = not self.UI.Values["PlayerESP"]
            lastToggleTime = currentTime
            for _, section in ipairs(self.UI.Sections) do
                for _, el in ipairs(section.Elements) do
                    if el.id == "PlayerESP" and el.Callback then
                        el.Callback(self.UI.Values["PlayerESP"])
                        break
                    end
                end
            end
        end
    end

    was_left_pressed = is_left_pressed_now
end

function Library:_AddPresetsTab()
    local tabGroupName = "PRESETS"
    local tabName = "Configs"

    for _, group in ipairs(self.UI.TabGroups) do
        if group.Name == tabGroupName then return end
    end

    local group = { Name = tabGroupName, Header = self:_CreateDrawingObject("Text"), Tabs = {} }
    if group.Header then
        group.Header.Font = self.ActiveTheme.Fonts.Main; group.Header.Size = self.ActiveTheme.Fonts.TabHeaderSize; group.Header.Text = group.Name; group.Header.Center = false; group.Header.Outline = false; group.Header.zIndex = 3;
    end

    local tab = {
        Name = tabName,
        Text = self:_CreateDrawingObject("Text"),
        Icon = self:_CreateDrawingObject("Image"),
        ClickRegion = {},
        Highlight = self:_CreateDrawingObject("Square") -- Добавляем недостающий объект
    }
    -- И настраиваем его
    if tab.Highlight then
        tab.Highlight.Filled = true
        tab.Highlight.zIndex = 2
        tab.Highlight.Rounding = self.ActiveTheme.Rounding.Element + 3
        tab.Highlight.Visible = true
    end

    if tab.Text then
        tab.Text.Font = self.ActiveTheme.Fonts.Main; tab.Text.Size = self.ActiveTheme.Fonts.TabSize; tab.Text.Text = tabName; tab.Text.Center = false; tab.Text.Outline = false; tab.Text.zIndex = 3; end
    if tab.Icon then
        tab.Icon.Url = "https://s6.imgcdn.dev/Y4Skk8.png" -- Gear icon
        tab.Icon.Size = {self.ActiveTheme.IconSize, self.ActiveTheme.IconSize}; tab.Icon.zIndex = 3;
    end

    table.insert(group.Tabs, tab)
    table.insert(self.UI.TabGroups, group)
end


function Library:_MainLoop()
    print(SCRIPT_PREFIX .. "UI Initialized and Main Loop started. 31")
    local is_first_frame = true
    while self.Window.Visible do
        if is_first_frame then
            self:_AddPresetsTab()
            is_first_frame = false
        end
        pcall(function() self:_InputLoop(); self:_RenderLoop() end)
        wait(0.01)
    end
end

--================================================================
--[[ PRIVATE: INTERNAL ELEMENT CREATORS ]]
--================================================================

function Library:_Internal_CreateToggle(options)
    if self.UI.Values[options.id] == nil then
        self.UI.Values[options.id] = options.Default or false
    end
    local z = options.zIndex or 4
    local toggle = {
        id = options.id, type = "Toggle", Name = options.Name, Size = {width = 35, height = 12},
        HasSettings = options.HasSettings or false, Callback = options.Callback,
        Label = self:_CreateDrawingObject("Text"), Back = self:_CreateDrawingObject("Square"),
        Nub = self:_CreateDrawingObject("Circle"), ClickRegion = {}, SettingsClickRegion = {},
        SettingsIcon = nil,
        CurrentBackColor = {0,0,0,0}, -- Текущий цвет фона
        CurrentNubColor = {0,0,0,0}   -- Текущий цвет ползунка
    }
    if toggle.HasSettings then
        toggle.SettingsIcon = self:_CreateDrawingObject("Image")
        if toggle.SettingsIcon then
            toggle.SettingsIcon.Url = "https://s6.imgcdn.dev/Y4Skk8.png"
            toggle.SettingsIcon.Size = {16, 16}
            toggle.SettingsIcon.zIndex = z + 1
        end
    end
    if toggle.Label then
        toggle.Label.Font = self.ActiveTheme.Fonts.Main; toggle.Label.Size = self.ActiveTheme.Fonts.Size + 2; toggle.Label.Text = toggle.Name; toggle.Label.Center = false; toggle.Label.Outline = false; toggle.Label.zIndex = z;
    end
    if toggle.Back then
        toggle.Back.Filled = true; toggle.Back.zIndex = z; toggle.Back.Rounding = 6;
    end
    if toggle.Nub then
        toggle.Nub.Filled = true; toggle.Nub.zIndex = z + 1; toggle.Nub.Radius = 9;
    end
    return toggle
end

function Library:_Internal_CreateSlider(options)
    if self.UI.Values[options.id] == nil then
        self.UI.Values[options.id] = options.Default or options.Min or 0
    end
    local z = options.zIndex or 4
    local slider = {
        id = options.id, type = "Slider", Name = options.Name, Min = options.Min or 0, Max = options.Max or 100,
        Increment = options.Increment or 1, IsDragging = false, Callback = options.Callback,
        Label = self:_CreateDrawingObject("Text"), Back = self:_CreateDrawingObject("Square"),
        LeftFill = self:_CreateDrawingObject("Square"), RightFill = self:_CreateDrawingObject("Square"),
        Nub = self:_CreateDrawingObject("Circle"), ValueText = self:_CreateDrawingObject("Text"),
        ClickRegion = {}, Glow = self:_Internal_CreateGlowSet(z),
        CurrentNubColor = {0,0,0,0}, CurrentFillColor = {0,0,0,0} -- Цвета для анимации
    }
    if slider.Label then slider.Label.Font = self.ActiveTheme.Fonts.Main; slider.Label.Size = self.ActiveTheme.Fonts.Size + 2; slider.Label.Text = slider.Name; slider.Label.Center = false; slider.Label.Outline = false; slider.Label.zIndex = z; end
    if slider.Back then slider.Back.Filled = true; slider.Back.zIndex = z; slider.Back.Rounding = 1; end
    if slider.LeftFill then slider.LeftFill.Filled = true; slider.LeftFill.zIndex = z + 1; slider.LeftFill.Rounding = 1; end
    if slider.RightFill then slider.RightFill.Filled = true; slider.RightFill.zIndex = z + 1; slider.RightFill.Rounding = 1; end
    if slider.Nub then slider.Nub.Filled = true; slider.Nub.zIndex = z + 2; slider.Nub.Radius = 8; end
    if slider.ValueText then slider.ValueText.Font = self.ActiveTheme.Fonts.Main; slider.ValueText.Size = self.ActiveTheme.Fonts.Size; slider.ValueText.Center = false; slider.ValueText.Outline = false; slider.ValueText.zIndex = z; end
    return slider
end

function Library:_Internal_CreateDropdown(options)
    if self.UI.Values[options.id] == nil then
        self.UI.Values[options.id] = options.Default or options.Options[1]
    end
    local z = options.zIndex or 4
    local dropdown = {
        id = options.id, type = "Dropdown", Name = options.Name, Options = options.Options,
        IsOpen = false, Size = options.Size or {width = 120, height = 25}, Callback = options.Callback,
        Label = self:_CreateDrawingObject("Text"), Button = self:_CreateDrawingObject("Square"),
        ButtonText = self:_CreateDrawingObject("Text"), OptionList = {},
        OptionBackground = self:_CreateDrawingObject("Square"), ArrowLine1 = self:_CreateDrawingObject("Line"),
        ArrowLine2 = self:_CreateDrawingObject("Line"), ClickRegion = {},
        BorderLeft = self:_CreateDrawingObject("Line"), BorderRight = self:_CreateDrawingObject("Line"),
        BorderBottom = self:_CreateDrawingObject("Line"), Glow = self:_Internal_CreateGlowSet(z + 8),
        CurrentButtonColor = {0,0,0,0} -- Цвет для анимации
    }
    if dropdown.Label then dropdown.Label.Font = self.ActiveTheme.Fonts.Main; dropdown.Label.Size = self.ActiveTheme.Fonts.Size + 2; dropdown.Label.Text = dropdown.Name; dropdown.Label.Center = false; dropdown.Label.Outline = false; dropdown.Label.zIndex = z; end
    if dropdown.Button then dropdown.Button.Filled = true; dropdown.Button.zIndex = z; dropdown.Button.Rounding = self.ActiveTheme.Rounding.Element; end
    if dropdown.ButtonText then dropdown.ButtonText.Font = self.ActiveTheme.Fonts.Main; dropdown.ButtonText.Size = self.ActiveTheme.Fonts.Size + 3; dropdown.ButtonText.Text = self.UI.Values[dropdown.id]; dropdown.ButtonText.Center = false; dropdown.ButtonText.Outline = false; dropdown.ButtonText.zIndex = z + 1; end
    if dropdown.OptionBackground then dropdown.OptionBackground.Filled = true; dropdown.OptionBackground.zIndex = z + 9; dropdown.OptionBackground.Visible = false; dropdown.OptionBackground.Rounding = self.ActiveTheme.Rounding.Element; end
    if dropdown.ArrowLine1 then dropdown.ArrowLine1.Thickness = 2; dropdown.ArrowLine1.zIndex = z + 2; end
    if dropdown.ArrowLine2 then dropdown.ArrowLine2.Thickness = 2; dropdown.ArrowLine2.zIndex = z + 2; end
    if dropdown.BorderLeft then dropdown.BorderLeft.Thickness = 1; dropdown.BorderLeft.zIndex = z + 10; dropdown.BorderLeft.Visible = false; end
    if dropdown.BorderRight then dropdown.BorderRight.Thickness = 1; dropdown.BorderRight.zIndex = z + 10; dropdown.BorderRight.Visible = false; end
    if dropdown.BorderBottom then dropdown.BorderBottom.Thickness = 1; dropdown.BorderBottom.zIndex = z + 10; dropdown.BorderBottom.Visible = false; end
    for i, option in ipairs(dropdown.Options) do local optionText = self:_CreateDrawingObject("Text"); if optionText then optionText.Font = self.ActiveTheme.Fonts.Main; optionText.Size = self.ActiveTheme.Fonts.Size; optionText.Text = option; optionText.Center = false; optionText.Outline = false; optionText.zIndex = z + 10; optionText.Visible = false; end table.insert(dropdown.OptionList, optionText) end
    return dropdown
end

function Library:_Internal_CreateMultidropdown(options)
    if self.UI.Values[options.id] == nil then
        self.UI.Values[options.id] = options.Default or {}
    end
    local z = options.zIndex or 4
    local multidropdown = {
        id = options.id, type = "Multidropdown", Name = options.Name, Options = options.Options,
        IsOpen = false, Size = {width = 120, height = 25}, Callback = options.Callback,
        Label = self:_CreateDrawingObject("Text"), Button = self:_CreateDrawingObject("Square"),
        ButtonText = self:_CreateDrawingObject("Text"), OptionList = {},
        OptionBackground = self:_CreateDrawingObject("Square"), ArrowLine1 = self:_CreateDrawingObject("Line"),
        ArrowLine2 = self:_CreateDrawingObject("Line"), ClickRegion = {},
        BorderLeft = self:_CreateDrawingObject("Line"), BorderRight = self:_CreateDrawingObject("Line"),
        BorderBottom = self:_CreateDrawingObject("Line"), Glow = self:_Internal_CreateGlowSet(z + 8),
        CurrentButtonColor = {0,0,0,0} -- Цвет для анимации
    }
    if multidropdown.Label then multidropdown.Label.Font = self.ActiveTheme.Fonts.Main; multidropdown.Label.Size = self.ActiveTheme.Fonts.Size + 2; multidropdown.Label.Text = multidropdown.Name; multidropdown.Label.Center = false; multidropdown.Label.Outline = false; multidropdown.Label.zIndex = z; end
    if multidropdown.Button then multidropdown.Button.Filled = true; multidropdown.Button.zIndex = z; multidropdown.Button.Rounding = self.ActiveTheme.Rounding.Element; end
    if multidropdown.ButtonText then multidropdown.ButtonText.Font = self.ActiveTheme.Fonts.Main; multidropdown.ButtonText.Size = self.ActiveTheme.Fonts.Size + 3; multidropdown.ButtonText.Text = ""; multidropdown.ButtonText.Center = false; multidropdown.ButtonText.Outline = false; multidropdown.ButtonText.zIndex = z + 1; end
    if multidropdown.OptionBackground then multidropdown.OptionBackground.Filled = true; multidropdown.OptionBackground.zIndex = z + 9; multidropdown.OptionBackground.Visible = false; multidropdown.OptionBackground.Rounding = self.ActiveTheme.Rounding.Element; end
    if multidropdown.ArrowLine1 then multidropdown.ArrowLine1.Thickness = 2; multidropdown.ArrowLine1.zIndex = z + 2; end
    if multidropdown.ArrowLine2 then multidropdown.ArrowLine2.Thickness = 2; multidropdown.ArrowLine2.zIndex = z + 2; end
    if multidropdown.BorderLeft then multidropdown.BorderLeft.Thickness = 1; multidropdown.BorderLeft.zIndex = z + 10; multidropdown.BorderLeft.Visible = false; end
    if multidropdown.BorderRight then multidropdown.BorderRight.Thickness = 1; multidropdown.BorderRight.zIndex = z + 10; multidropdown.BorderRight.Visible = false; end
    if multidropdown.BorderBottom then multidropdown.BorderBottom.Thickness = 1; multidropdown.BorderBottom.zIndex = z + 10; multidropdown.BorderBottom.Visible = false; end
    for i, option in ipairs(multidropdown.Options) do local optionText = self:_CreateDrawingObject("Text"); if optionText then optionText.Font = self.ActiveTheme.Fonts.Main; optionText.Size = self.ActiveTheme.Fonts.Size; optionText.Text = option; optionText.Center = false; optionText.Outline = false; optionText.zIndex = z + 10; optionText.Visible = false; end table.insert(multidropdown.OptionList, optionText) end
    return multidropdown
end

function Library:_Internal_CreateKeybind(options)
    if self.UI.Values[options.id] == nil then
        self.UI.Values[options.id] = options.Default or "none"
    end
    local z = options.zIndex or 4
    local keybind = { id = options.id, type = "Keybind", Name = options.Name, Size = {width = 50, height = 25}, Callback = options.Callback, Button = self:_CreateDrawingObject("Square"), ButtonText = self:_CreateDrawingObject("Text"), IsListening = false, ClickRegion = {} }
    if keybind.Button then keybind.Button.Filled = false; keybind.Button.Thickness = 1; keybind.Button.zIndex = z; keybind.Button.Rounding = self.ActiveTheme.Rounding.Element; end
    if keybind.ButtonText then keybind.ButtonText.Font = self.ActiveTheme.Fonts.Main; keybind.ButtonText.Size = self.ActiveTheme.Fonts.Size; keybind.ButtonText.Text = self.UI.Values[keybind.id]; keybind.ButtonText.Center = false; keybind.ButtonText.Outline = false; keybind.ButtonText.zIndex = z + 1; end
    return keybind
end

--================================================================
--[[ PUBLIC API ]]
--================================================================

function Library:Tab(options)
    local tabGroupName = options.Group
    local tabName = options.Name

    local existingGroup; for _, group in ipairs(self.UI.TabGroups) do if group.Name == tabGroupName then existingGroup = group; break end end

    if not existingGroup then
        existingGroup = { Name = tabGroupName, Header = self:_CreateDrawingObject("Text"), Tabs = {} }
        if existingGroup.Header then existingGroup.Header.Font = self.ActiveTheme.Fonts.Main; existingGroup.Header.Size = self.ActiveTheme.Fonts.TabHeaderSize; existingGroup.Header.Text = existingGroup.Name; existingGroup.Header.Center = false; existingGroup.Header.Outline = false; existingGroup.Header.zIndex = 3; end
        table.insert(self.UI.TabGroups, existingGroup)
    end

    local tab_obj = {
        Name = tabName,
        Text = self:_CreateDrawingObject("Text"),
        Icon = nil,
        ClickRegion = {},
        --[[ НОВОЕ: Персональный объект подсветки для вкладки ]]
        Highlight = self:_CreateDrawingObject("Square")
    }
    if tab_obj.Highlight then
        tab_obj.Highlight.Filled = true
        tab_obj.Highlight.zIndex = 2
        tab_obj.Highlight.Rounding = self.ActiveTheme.Rounding.Element + 3
        tab_obj.Highlight.Visible = true -- Он всегда видим, но может быть прозрачным
    end
    if tab_obj.Text then tab_obj.Text.Font = self.ActiveTheme.Fonts.Main; tab_obj.Text.Size = self.ActiveTheme.Fonts.TabSize; tab_obj.Text.Text = tabName; tab_obj.Text.Center = false; tab_obj.Text.Outline = false; tab_obj.Text.zIndex = 3; end
    if options.Icon then tab_obj.Icon = self:_CreateDrawingObject("Image"); if tab_obj.Icon then tab_obj.Icon.Url = options.Icon; tab_obj.Icon.Size = {self.ActiveTheme.IconSize, self.ActiveTheme.IconSize}; tab_obj.Icon.zIndex = 3; end end

    if self.Window.ActiveTab == "" then self.Window.ActiveTab = tabName end
    table.insert(existingGroup.Tabs, tab_obj)

    local self_lib = self
    local TabObject = {};
    function TabObject:Section(sectionOptions) sectionOptions.ParentTab = tabName; return self_lib:Section(sectionOptions) end
    return TabObject
end

function Library:Section(options)
    local section = {
        Title = options.Name, ParentTab = options.ParentTab, Side = options.Side or "Left", Elements = {},
        Drawing = { Background = self:_CreateDrawingObject("Square"), Border = self:_CreateDrawingObject("Square"), Title = self:_CreateDrawingObject("Text"), Separator = self:_CreateDrawingObject("Line") }
    }
    if section.Drawing.Background then section.Drawing.Background.Filled = true; section.Drawing.Background.zIndex = 2; section.Drawing.Background.Rounding = self.ActiveTheme.Rounding.Section; end
    if section.Drawing.Border then section.Drawing.Border.Filled = false; section.Drawing.Border.Thickness = 1; section.Drawing.Border.zIndex = 3; section.Drawing.Border.Rounding = self.ActiveTheme.Rounding.Section; end
    if section.Drawing.Title then section.Drawing.Title.Font = self.ActiveTheme.Fonts.Main; section.Drawing.Title.Size = self.ActiveTheme.Fonts.Size + 10; section.Drawing.Title.Text = section.Title; section.Drawing.Title.Center = false; section.Drawing.Title.Outline = false; section.Drawing.Title.zIndex = 4; end
    if section.Drawing.Separator then section.Drawing.Separator.Thickness = 2; section.Drawing.Separator.zIndex = 3; end

    table.insert(self.UI.Sections, section)

    local self_lib = self
    local SectionObject = {}
    function SectionObject:Toggle(toggleOptions) table.insert(section.Elements, self_lib:_Internal_CreateToggle(toggleOptions)); return SectionObject end
    function SectionObject:Slider(sliderOptions) table.insert(section.Elements, self_lib:_Internal_CreateSlider(sliderOptions)); return SectionObject end
    function SectionObject:Dropdown(dropdownOptions) table.insert(section.Elements, self_lib:_Internal_CreateDropdown(dropdownOptions)); return SectionObject end
    function SectionObject:Multidropdown(multidropdownOptions) table.insert(section.Elements, self_lib:_Internal_CreateMultidropdown(multidropdownOptions)); return SectionObject end
    function SectionObject:Keybind(keybindOptions) table.insert(section.Elements, self_lib:_Internal_CreateKeybind(keybindOptions)); return SectionObject end

    return SectionObject
end

function Library:Unload()
    self.Window.Visible = false
    for _, obj in ipairs(self.UI.DrawingObjects) do if obj and obj.Remove then pcall(obj.Remove, obj) end end
    self.UI.DrawingObjects = {}; print(SCRIPT_PREFIX .. "UI Unloaded.")
end

function Library:Create()
    self:_InitializeCoreUI()
    setmetatable(self.AnimationState, {__mode = "k"}) -- Делаем ключи слабыми для авто-очистки
    
    -- Config System Initialization
    if not checkfolder(self.ConfigFolderPath) then
        makefolder(self.ConfigFolderPath)
        print(SCRIPT_PREFIX .. "Created config folder: " .. self.ConfigFolderPath)
    end
    
    local files = listfiles(self.ConfigFolderPath)
    if not files or #files == 0 then
        print(SCRIPT_PREFIX .. "No configs found. Creating 'default.cfg'...")
        self:_SaveConfig("default")
    end

    self:_RefreshConfigList()
    if self.UI.Core.ConfigsTab.Items[1] then
        self:_LoadConfig(self.UI.Core.ConfigsTab.Items[1].Name)
    end

    spawn(function() self:_MainLoop() end)
    return self
end

return Library
