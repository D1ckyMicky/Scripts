--[[
    Neverlose.cc Style UI Library for Severe
    Version: 16.1 (Config System - Hotfix)
    Developer: Gemini AI & Dicky_Micky_

    - [FIX] Changed config file extension from .json to .cfg to avoid 'banned file extension' error in Severe.
    - [NEW] Implemented the core config saving/loading system using the file system.
    - [NEW] The library now automatically creates a 'NL_Configs' folder on startup.
    - [NEW] On first launch (or if no configs exist), a 'default.cfg' config is created with the default values of all UI elements.
    - [NEW] The 'Configs' tab now dynamically loads and displays all .cfg files found in the 'NL_Configs' folder.
    - [UPDATE] The 'Save' button now saves the current UI values to the selected config file.
    - [UPDATE] The 'Load' button now loads UI values from the selected config file.
    - [INTERNAL] Removed 'DummyData' in favor of the new dynamic system.
]]

local Library = {}

--================================================================
--[[ PRIVATE: CORE PROPERTIES & CONFIGURATION ]]
--================================================================

Library.AnimationState = {} -- Хранилище для состояний анимации
Library.GlobalAnimation = { IsHiding = false, IsShowing = false, Opacity = 1.0 }
Library.lastUIToggleTime = 0

Library.Window = {
    Visible = true, X = 400, Y = 200, Width = 750, Height = 620,
    SidebarWidth = 187, HeaderHeight = 65, IsDragging = false,
    IsFastDragging = false, -- << [НОВОЕ] Добавь эту строку
    ActiveTab = "", PanelOverlap = 4,
    LastRenderedTab = "",
    Animation = { State = "IDLE", OldTab = nil }
}


Library.ConfigFolderPath = "NL_Configs" -- Новая папка для конфигов

Library.Themes = {
    Blue = {
        Name = "Blue", IsPreset = true,
        Fonts = { Title = 2, Main = 1, Size = 14, TitleSize = 27, TabSize = 18, TabHeaderSize = 12 },
        Colors = { 
            MainBackground = {6, 9, 17, 245}, SectionBackground = {3, 11, 23, 255}, SidebarBackground = {11, 20, 33, 204}, 
            WatermarkBackground = {6, 9, 17, 245}, HotkeysBackground = {3, 11, 23, 215}, -- << НОВЫЙ ЦВЕТ
            Separator = {0, 18, 32, 255}, Accent = {24, 165, 232, 255}, DarkBlue = {3, 23, 51, 255}, 
            DarkGray = {24, 24, 24, 255}, LightGray = {77, 77, 76, 255}, 
            TextPrimary = {234, 239, 245, 255}, TextSecondary = {160, 181, 197, 255}, 
            TabHeader = {100, 120, 140, 255}, GlowColor = {7, 70, 99, 255}, GlowAccent = {24, 165, 232, 255},
            TextLight = {234, 239, 245, 255}, TextDark = {60, 60, 60, 255}
        },
        Transparency = { Solid = 0.9, ActiveTabHighlight = 0.28 },
        Rounding = { Window = 8, Section = 6, Element = 4, Button = 5 }, IconSize = 16
    },
    Black = {
        Name = "Black", IsPreset = true,
        Fonts = { Title = 2, Main = 1, Size = 14, TitleSize = 27, TabSize = 18, TabHeaderSize = 12 },
        Colors = { 
            MainBackground = {6, 6, 9, 247}, SectionBackground = {0, 3, 5, 255}, SidebarBackground = {14, 16, 19, 230}, 
            WatermarkBackground = {6, 6, 9, 247}, HotkeysBackground = {0, 3, 5, 215}, -- << НОВЫЙ ЦВЕТ
            Separator = {11, 11, 11, 255}, Accent = {72, 130, 255, 255}, DarkBlue = {10, 11, 19, 255}, 
            DarkGray = {24, 24, 24, 255}, LightGray = {77, 77, 76, 255}, 
            TextPrimary = {234, 239, 245, 255}, TextSecondary = {181, 181, 194, 255}, 
            TabHeader = {111, 120, 130, 255}, GlowColor = {22, 39, 77, 255}, GlowAccent = {72, 130, 255, 255},
            TextLight = {234, 239, 245, 255}, TextDark = {60, 60, 60, 255}
        },
        Transparency = { Solid = 0.9, ActiveTabHighlight = 0.28 },
        Rounding = { Window = 8, Section = 6, Element = 4, Button = 5 }, IconSize = 16
    },
    White = {
        Name = "White", IsPreset = true,
        Fonts = { Title = 2, Main = 1, Size = 14, TitleSize = 27, TabSize = 18, TabHeaderSize = 12 },
        Colors = { 
            MainBackground = {250, 250, 255, 247}, SectionBackground = {244, 244, 244, 255}, SidebarBackground = {240, 240, 240, 230}, 
            WatermarkBackground = {250, 250, 255, 247}, HotkeysBackground = {244, 244, 244, 215}, -- << НОВЫЙ ЦВЕТ
            Separator = {200, 200, 200, 255}, Accent = {24, 165, 232, 255}, DarkBlue = {220, 220, 220, 255}, 
            DarkGray = {165, 165, 165, 255}, LightGray = {120, 120, 120, 255}, 
            TextPrimary = {10, 10, 10, 255}, TextSecondary = {60, 60, 60, 255}, 
            TabHeader = {100, 100, 100, 255}, GlowColor = {7, 70, 99, 255}, GlowAccent = {24, 165, 232, 255},
            TextLight = {234, 239, 245, 255}, TextDark = {60, 60, 60, 255}
        },
        Transparency = { Solid = 0.9, ActiveTabHighlight = 0.28 },
        Rounding = { Window = 8, Section = 6, Element = 4, Button = 5 }, IconSize = 16
    }
}

Library.ActiveTheme = Library.Themes.Blue
Library.TempTheme = nil
Library.PreEditThemeName = nil

Library.UI = { TabGroups = {}, Sections = {}, Values = {}, DrawingObjects = {}, Popups = {}, ColorPresets = {} }
Library.ObjectsToRemove = {}

local drag_offset = {x = 0, y = 0}
local was_left_pressed = false
local was_right_pressed = false
local is_dragging_something = false
local was_dragging_picker = false -- << ДОБАВЬ ЭТУ СТРОКУ
local lastToggleTime = 0
local toggleDelay = 0.5
local SCRIPT_PREFIX = "[NL UI Lib] "
local lastAutoSaveTime = 0
local autoSaveInterval = 15 -- Интервал в секундах (можно изменить)
local lastBindCheckTime = 0 -- Для глобальной проверки биндов 
local last_slider_key_press_time = 0 
local slider_key_press_delay = 0.04 -- Можешь изменить это значение (в секундах)
local lastMousePos = {x = 0, y = 0}

--================================================================
--[[ PRIVATE: COLOR CONVERSION FUNCTIONS (PLACEHOLDERS) ]]
--================================================================

-- ВСТАВЬТЕ СЮДА ФУНКЦИЮ _HSVtoRGB
function Library:_HSVtoRGB(h, s, v)
    local r, g, b

    local i = math.floor(h * 6)
    local f = h * 6 - i
    local p = v * (1 - s)
    local q = v * (1 - f * s)
    local t = v * (1 - (1 - f) * s)

    i = i % 6

    if i == 0 then r, g, b = v, t, p
    elseif i == 1 then r, g, b = q, v, p
    elseif i == 2 then r, g, b = p, v, t
    elseif i == 3 then r, g, b = p, q, v
    elseif i == 4 then r, g, b = t, p, v
    elseif i == 5 then r, g, b = v, p, q
    end

    -- Возвращаем таблицу {r, g, b} со значениями от 0 до 255,
    -- как того требует библиотека Drawing.
    return { r * 255, g * 255, b * 255 }
end

-- ВСТАВЬТЕ СЮДА ФУНКЦИЮ _RGBtoHSV
function Library:_RGBtoHSV(r, g, b, a)
    r, g, b = r / 255, g / 255, b / 255
    local max, min = math.max(r, g, b), math.min(r, g, b)
    local h, s, v = max, max, max

    local d = max - min
    s = max == 0 and 0 or d / max

    if max == min then
        h = 0
    else
        if max == r then
            h = (g - b) / d + (g < b and 6 or 0)
        elseif max == g then
            h = (b - r) / d + 2
        elseif max == b then
            h = (r - g) / d + 4
        end
        h = h / 6
    end

    return h, s, v, (a or 255) / 255
end

--================================================================
--[[ PRIVATE: HELPER FUNCTIONS ]]
--================================================================

function Library:_CreateDrawingObject(class)
    local success, object = pcall(Drawing.new, class)
    if not success then warn(SCRIPT_PREFIX .. "Failed to create Drawing object of type:", class); return nil end
    table.insert(self.UI.DrawingObjects, object)
    return object
end

function Library:_DeepCopy(original)
    local copy = {}
    for k, v in pairs(original) do
        if type(v) == "table" then
            v = self:_DeepCopy(v)
        end
        copy[k] = v
    end
    return copy
end

function Library:_DarkenColor(color, factor)
    factor = factor or 0.3
    return { math.max(0, math.floor(color[1] * factor)), math.max(0, math.floor(color[2] * factor)), math.max(0, math.floor(color[3] * factor)), color[4] or 255 }
end

function Library:_IsThemeLight(theme)
    local bg = theme.Colors.MainBackground
    if not bg then return false end
    -- Using luminance formula to determine brightness
    local brightness = (bg[1] * 0.299 + bg[2] * 0.587 + bg[3] * 0.114)
    return brightness > 150 -- Threshold for what is considered a "light" background
end

function Library:_getAvatarThumbnail(userId)
    local url = string.format("https://thumbnails.roblox.com/v1/users/avatar-headshot?userIds=%d&size=420x420&format=Png&isCircular=true", userId)
    local success, response = pcall(function() return httpget(url, "application/json") end)
    if success then
        local decoded = JSONDecode(response)
        if decoded and decoded.data and decoded.data[1] and decoded.data[1].imageUrl then
            return decoded.data[1].imageUrl
        end
    end
    return nil
end

function Library:_SafeNumber(value, default) return type(value) == "number" and value or (default or 0) end
function Library:_IsPointInRegion(x, y, region)
    if not region or not region.x1 or not region.x2 or not region.y1 or not region.y2 then return false end
    return x >= self:_SafeNumber(region.x1, 0) and x <= self:_SafeNumber(region.x2, 0) and y >= self:_SafeNumber(region.y1, 0) and y <= self:_SafeNumber(region.y2, 0)
end
function Library:_SetVisibility(object, visible) if object and object.Visible ~= visible then object.Visible = visible end end
function table.find(tbl, value) for i, v in ipairs(tbl) do if v == value then return i end end; return nil end

-- Вставьте эту новую функцию в раздел PRIVATE: HELPER FUNCTIONS
function Library:_CleanupDrawingObjects(tbl)
    for _, v in pairs(tbl) do
        if type(v) == 'table' then
            if v.Remove and type(v.Remove) == 'function' then
                -- НЕ УДАЛЯЕМ СРАЗУ, а добавляем в очередь на удаление
                table.insert(self.ObjectsToRemove, v)
            else
                -- Это обычная таблица, идем глубже
                self:_CleanupDrawingObjects(v)
            end
        end
    end
end

-- Новая функция для плавной смены цвета (анимации)
function Library:_LerpColor(from, to, alpha)
    -- Проверка на случай, если одна из таблиц некорректна
    if type(from) ~= "table" or type(to) ~= "table" then 
        return to or from or {0, 0, 0, 255} 
    end

    -- Интерполяция с использованием значений по умолчанию для каждого канала
    local r = (from[1] or 0) + ((to[1] or 0) - (from[1] or 0)) * alpha
    local g = (from[2] or 0) + ((to[2] or 0) - (from[2] or 0)) * alpha
    local b = (from[3] or 0) + ((to[3] or 0) - (from[3] or 0)) * alpha
    local a = (from[4] or 255) + ((to[4] or 255) - (from[4] or 255)) * alpha
    
    return {r, g, b, a}
end

-- Новая функция для отрисовки подсказки у кнопки Save
-- ЗАМЕНИ НА ЭТОТ КОД
function Library:_RenderSaveTooltip()
    local tooltip = self.UI.Core.SaveTooltip
    local saveBtn = self.UI.Core.HeaderButtons.Save
    local theme = self.ActiveTheme
    
    -- ИСПРАВЛЕНИЕ №1: Подсказка должна быть видна при наведении на кнопку в любой вкладке.
    local shouldBeVisible = saveBtn.IsHovered

    -- Управляем состоянием анимации
    if shouldBeVisible and tooltip.Animation.CurrentOpacity < 1 and not tooltip.Animation.IsOpening then
        tooltip.Animation.IsOpening = true
        tooltip.Animation.IsClosing = false
    elseif not shouldBeVisible and tooltip.Animation.CurrentOpacity > 0 and not tooltip.Animation.IsClosing then
        tooltip.Animation.IsOpening = false
        tooltip.Animation.IsClosing = true
    end

    -- Получаем текущую прозрачность из аниматора
    local masterOpacity = tooltip.Animation.CurrentOpacity
    local isVisible = masterOpacity > 0

    self:_SetVisibility(tooltip.Background, isVisible)
    self:_SetVisibility(tooltip.Border, isVisible)
    self:_SetVisibility(tooltip.ConfigName, isVisible)
    self:_SetVisibility(tooltip.Author, isVisible)

    if isVisible then
        -- Применяем цвета, используя текущую прозрачность для fade-эффекта
        self:_AnimateAndApplyColor(tooltip.Background, theme.Colors.SectionBackground, masterOpacity)
        self:_AnimateAndApplyColor(tooltip.Border, theme.Colors.Separator, masterOpacity)
        self:_AnimateAndApplyColor(tooltip.ConfigName, theme.Colors.TextPrimary, masterOpacity)
        self:_AnimateAndApplyColor(tooltip.Author, theme.Colors.TextSecondary, masterOpacity)
    
        local configName = self.UI.Core.ConfigsTab.LoadedConfigName
        if configName == "" then configName = "default" end
        tooltip.ConfigName.Text = "Config \"" .. configName .. "\""
        tooltip.Author.Text = "Author: " .. (self.UI.Core.PlayerDisplayName.Text or "user")

        local padding = 16
        local configNameWidth = tooltip.ConfigName.TextBounds and tooltip.ConfigName.TextBounds.x or 100
        local authorWidth = tooltip.Author.TextBounds and tooltip.Author.TextBounds.x or 100
        local tooltipW = math.max(configNameWidth, authorWidth) + padding
        local tooltipH = 50

        local btnRegion = saveBtn.ClickRegion
        local tooltipX, tooltipY = btnRegion.x2 + 10, btnRegion.y1

        tooltip.Background.Position = {tooltipX, tooltipY}
        tooltip.Background.Size = {tooltipW, tooltipH}
        tooltip.Border.Position = {tooltipX, tooltipY}
        tooltip.Border.Size = {tooltipW, tooltipH}
        tooltip.ConfigName.Position = {tooltipX + (padding / 2), tooltipY + 8}
        tooltip.Author.Position = {tooltipX + (padding / 2), tooltipY + 28}
        
        -- ИСПРАВЛЕНИЕ №2: Передаём аргументы в функцию свечения в правильном порядке.
        self:_RenderGlowEffect(tooltip.Glow, tooltipX, tooltipY, tooltipW, tooltipH, tooltip.Background.Rounding, theme.Colors.GlowColor, nil, masterOpacity)
    else
        self:_HideGlowEffect(tooltip.Glow)
    end
end

function Library:_AnimateAndApplyColor(drawingObject, targetColor, masterOpacity, ignoreGlobalOpacity)
    if not drawingObject or type(targetColor) ~= "table" then return end

    local finalColor
    -- [[ ИСПРАВЛЕНИЕ: Используем правильный ID "BurgerLow-EndMode" ]]
    if self.Window.IsFastDragging or self.UI.Values["BurgerLow-EndMode"] then
        finalColor = targetColor
    else
        local state = self.AnimationState[drawingObject]
        if not state then
            state = { CurrentColor = self:_DeepCopy(targetColor) }
            self.AnimationState[drawingObject] = state
        end

        local speed_value = self.UI.Values["AboutAnimationSpeed"] or 2.5
        local animationSpeed = speed_value / 16.0

        state.CurrentColor = self:_LerpColor(state.CurrentColor, targetColor, animationSpeed)
        finalColor = state.CurrentColor
    end

    if finalColor then
        drawingObject.Color = {finalColor[1], finalColor[2], finalColor[3]}
        local baseOpacity = (finalColor[4] or 255) / 255

        masterOpacity = (masterOpacity == nil) and 1 or masterOpacity

        local finalOpacityValue = baseOpacity * masterOpacity
        if not ignoreGlobalOpacity then
            local globalOpacity = self.GlobalAnimation and self.GlobalAnimation.Opacity or 1
            finalOpacityValue = finalOpacityValue * globalOpacity
        end

        drawingObject.Opacity = finalOpacityValue
    end
end


function Library:_GetTextColorForBackground(backgroundColor)
    local theme = self.ActiveTheme
    if not backgroundColor or type(backgroundColor) ~= "table" then
        return theme.Colors.TextLight 
    end
    
    local brightness = (backgroundColor[1] * 0.299 + backgroundColor[2] * 0.587 + backgroundColor[3] * 0.114)
    
    return brightness > 140 and theme.Colors.TextDark or theme.Colors.TextLight
end

function Library:_UpdateAnimationStates()
    local still_fading_out = false
    local still_fading_in = false
    local ANIMATION_SLIDE_DISTANCE = 20
    local speed_value = self.UI.Values["AboutAnimationSpeed"] or 2.5
    local animationSpeed = (speed_value * 1.5) / 15.0

    for _, section in ipairs(self.UI.Sections) do
        local anim_state = self.AnimationState[section.Drawing.Background]
        if not anim_state then
            anim_state = { Opacity = 0, YOffset = 0 }
            self.AnimationState[section.Drawing.Background] = anim_state
        end

        local is_on_active_tab = (section.ParentTab == self.Window.ActiveTab)
        local is_on_old_tab = (self.Window.Animation.State == "FADING_OUT" and section.ParentTab == self.Window.Animation.OldTab)
        
        local targetOpacity, targetYOffset
        
        if is_on_old_tab then
            targetOpacity, targetYOffset = 0, ANIMATION_SLIDE_DISTANCE
            if anim_state.Opacity > 0.01 then still_fading_out = true end
        elseif is_on_active_tab and self.Window.Animation.State ~= "FADING_OUT" then
            targetOpacity, targetYOffset = 1, 0
            if anim_state.Opacity < 0.99 then still_fading_in = true end
        else
            targetOpacity, targetYOffset = 0, anim_state.YOffset
        end
        
        -- [[ ИСПРАВЛЕНИЕ: Используем правильный ID "BurgerLow-EndMode" ]]
        if self.UI.Values["BurgerLow-EndMode"] then
            anim_state.Opacity = targetOpacity
            anim_state.YOffset = targetYOffset
        else
            anim_state.Opacity = anim_state.Opacity + (targetOpacity - anim_state.Opacity) * animationSpeed
            anim_state.YOffset = anim_state.YOffset + (targetYOffset - anim_state.YOffset) * animationSpeed
        end
        
        if math.abs(anim_state.Opacity - targetOpacity) < 0.01 then anim_state.Opacity = targetOpacity end
        if math.abs(anim_state.YOffset - targetYOffset) < 0.01 then anim_state.YOffset = targetYOffset end
    end

    if self.Window.Animation.State == "FADING_OUT" and not still_fading_out then
        self.Window.Animation.State = "FADING_IN"
        self.Window.Animation.OldTab = nil
        
        for _, section in ipairs(self.UI.Sections) do
            if section.ParentTab == self.Window.ActiveTab then
                local anim_state = self.AnimationState[section.Drawing.Background]
                if anim_state then
                    anim_state.Opacity = 0
                    anim_state.YOffset = ANIMATION_SLIDE_DISTANCE
                end
                
                for _, el in ipairs(section.Elements) do
                    if el.type == "Toggle" and self.UI.Values[el.id] then
                        el.AnimatedNubOffset = el.Size.height / 2
                    elseif el.type == "Slider" then
                        el.AnimatedValue = el.Min
                    end
                end
            end
        end
    elseif self.Window.Animation.State == "FADING_IN" and not still_fading_in then
        self.Window.Animation.State = "IDLE"
    end
end

function Library:_SetSectionAndElementsVisibility(section, visible)
    -- Сначала обрабатываем собственные объекты секции (фон, заголовок и т.д.)
    for _, obj in pairs(section.Drawing) do
        if obj and obj.Visible ~= nil then self:_SetVisibility(obj, visible) end
    end

    -- Затем обрабатываем все элементы внутри секции
    for _, el in ipairs(section.Elements) do
        for key, val in pairs(el) do
            -- Проверяем, является ли значение в паре объектом для отрисовки
            if type(val) == 'table' and val.Visible ~= nil then
                self:_SetVisibility(val, visible)
            -- Отдельно обрабатываем вложенные списки, как в Dropdown
            elseif (key == 'OptionList' or key == 'Glow') and type(val) == 'table' then
                 for _, nested_obj in ipairs(val) do
                    if nested_obj and nested_obj.Visible ~= nil then self:_SetVisibility(nested_obj, visible) end
                 end
            end
        end
        -- Если мы скрываем секцию, также нужно закрыть все открытые в ней выпадающие списки
        if not visible and el.IsOpen then
            el.IsOpen = false
        end
    end
end

function Library:_EnsureDefaults(data_table, default_table)
    if type(data_table) ~= 'table' or type(default_table) ~= 'table' then
        return self:_DeepCopy(default_table) or {}
    end
    
    local result = self:_DeepCopy(data_table)
    for key, defaultValue in pairs(default_table) do
        if result[key] == nil then
            -- Если ключ полностью отсутствует в загруженных данных, копируем его из шаблона.
            result[key] = defaultValue
        elseif type(defaultValue) == 'table' and type(result[key]) == 'table' then
            -- Если ключ есть, но это тоже таблица, рекурсивно проверяем и её.
            result[key] = self:_EnsureDefaults(result[key], defaultValue)
        end
    end
    return result
end

function Library:_HideSettingsPopupElements(popup)
    if not popup or not popup.ActiveToggle or not popup.ActiveToggle.SettingsElements then
        return
    end
    for _, element in ipairs(popup.ActiveToggle.SettingsElements) do
        if element.type == "Keybind" then
            if element.Label then self:_SetVisibility(element.Label, false) end -- << ИСПРАВЛЕНИЕ
            if element.Button then self:_SetVisibility(element.Button, false) end
            if element.Border then self:_SetVisibility(element.Border, false) end
            if element.ButtonText then self:_SetVisibility(element.ButtonText, false) end
        end
    end
end

-- Вставьте эту новую функцию в раздел PRIVATE: HELPER FUNCTIONS
function Library:_SetDrawingTableVisibility(tbl, visible)
    for _, v in pairs(tbl) do
        if type(v) == 'table' then
            if v.Remove and type(v.Remove) == 'function' then
                -- Это объект отрисовки, меняем его видимость
                self:_SetVisibility(v, visible)
            else
                -- Это обычная таблица, идем глубже
                self:_SetDrawingTableVisibility(v, visible)
            end
        end
    end
end

function Library:_RGBtoHEX(r, g, b, a)
    r, g, b = math.floor(r or 0), math.floor(g or 0), math.floor(b or 0)
    local hex = string.format("#%02X%02X%02X", r, g, b)
    if a and a < 255 then
        hex = hex .. string.format("%02X", math.floor(a))
    end
    return hex
end

function Library:_HEXtoRGB(hex)
    hex = hex:gsub("#", "")
    local r, g, b, a
    if #hex == 6 or #hex == 8 then
        r = tonumber("0x" .. hex:sub(1, 2))
        g = tonumber("0x" .. hex:sub(3, 4))
        b = tonumber("0x" .. hex:sub(5, 6))
        a = (#hex == 8) and tonumber("0x" .. hex:sub(7, 8)) or 255
        if r and g and b then
            return {r, g, b, a}
        end
    end
    return nil -- Возвращаем nil, если HEX некорректный
end

function Library:_UpdatePopupAnimation(popup)
    if not popup.Animation then return end
    local anim = popup.Animation

    if self.UI.Values["BurgerLow-EndMode"] then
        if anim.IsOpening then
            anim.CurrentOpacity = 1
            anim.IsOpening = false
        elseif anim.IsClosing then
            anim.CurrentOpacity = 0
            anim.IsClosing = false
            if popup.IsOpen ~= nil then popup.IsOpen = false end
        end
    else
        local speed_value = self.UI.Values["AboutAnimationSpeed"] or 2.4
        local animationSpeed = (speed_value > 0) and (speed_value / 25.0) or 1 --150 lf
        
        if anim.IsOpening then
            anim.CurrentOpacity = anim.CurrentOpacity + animationSpeed
            if anim.CurrentOpacity >= 1 then
                anim.CurrentOpacity = 1
                anim.IsOpening = false
            end
        elseif anim.IsClosing then
            anim.CurrentOpacity = anim.CurrentOpacity - animationSpeed
            if anim.CurrentOpacity <= 0 then
                anim.CurrentOpacity = 0
                anim.IsClosing = false
                if popup.IsOpen ~= nil then popup.IsOpen = false end
            end
        end
    end
end

function Library:_SplitString(inputstr, sep)
    if sep == nil then sep = "%s" end
    local t = {}
    for str in string.gmatch(inputstr, "([^" .. sep .. "]+)") do
        -- ИЗМЕНЕНИЕ: Убираем лишние пробелы с каждой стороны для каждого элемента
        table.insert(t, str:match("^%s*(.-)%s*$"))
    end
    return t
end

function Library:_CreateSwatchObject(color, isAddButton)
    local picker = self.UI.Popups.ColorPicker
    local z = picker.Background.zIndex + 10
    local swatch = {
        IsAddButton = isAddButton or false,
        Color = color,
        Circle = self:_CreateDrawingObject("Circle"),
        Border = self:_CreateDrawingObject("Circle"),
        ClickRegion = {}
    }

    if swatch.Circle then 
        swatch.Circle.Filled = true; swatch.Circle.zIndex = z; swatch.Circle.Radius = 6;
    end
    if swatch.Border then 
        swatch.Border.Filled = false; swatch.Border.Thickness = 1; swatch.Border.zIndex = z + 1; swatch.Border.Radius = 7;
    end

    if isAddButton then
        swatch.PlusLine1 = self:_CreateDrawingObject("Line")
        swatch.PlusLine2 = self:_CreateDrawingObject("Line")
        if swatch.PlusLine1 then swatch.PlusLine1.Thickness = 1.5; swatch.PlusLine1.zIndex = z + 1; end
        if swatch.PlusLine2 then swatch.PlusLine2.Thickness = 1.5; swatch.PlusLine2.zIndex = z + 1; end
    end
    
    return swatch
end

function Library:_AddColorSwatch(color)
    local picker = self.UI.Popups.ColorPicker
    if #self.UI.ColorPresets >= 7 then return end

    table.insert(self.UI.ColorPresets, color)

    if #picker.Swatches > 0 and picker.Swatches[#picker.Swatches].IsAddButton then
        local oldAddButton = table.remove(picker.Swatches)
        self:_CleanupDrawingObjects(oldAddButton)
    end

    local newSwatch = self:_CreateSwatchObject(color, false)
    -- ---[[ ИСПРАВЛЕНИЕ: Явно задаем цвет созданному объекту ]]
    if newSwatch.Circle then
        newSwatch.Circle.Color = {color[1], color[2], color[3], color[4]}
    end
    table.insert(picker.Swatches, newSwatch)

    if #self.UI.ColorPresets < 7 then
        local newAddButton = self:_CreateSwatchObject(nil, true)
        table.insert(picker.Swatches, newAddButton)
    end
end

function Library:_RemoveColorSwatch(index)
    local picker = self.UI.Popups.ColorPicker
    if not picker.Swatches[index] or picker.Swatches[index].IsAddButton then return end

    -- Удаляем пресет и объект отрисовки
    table.remove(self.UI.ColorPresets, index)
    local swatchToRemove = table.remove(picker.Swatches, index)
    self:_CleanupDrawingObjects(swatchToRemove)

    -- Проверяем, нужно ли добавить кнопку "Add" обратно
    local hasAddButton = false
    for _, s in ipairs(picker.Swatches) do
        if s.IsAddButton then hasAddButton = true; break; end
    end

    if not hasAddButton and #self.UI.ColorPresets < 7 then
        local newAddButton = self:_CreateSwatchObject(nil, true)
        table.insert(picker.Swatches, newAddButton)
    end
end

function Library:_RebuildColorSwatches()
    local picker = self.UI.Popups.ColorPicker
    
    -- Очищаем старые объекты, если они есть
    for _, swatch in ipairs(picker.Swatches) do
        self:_CleanupDrawingObjects(swatch)
    end
    picker.Swatches = {}

    -- Создаем кружки для существующих пресетов
    for _, color in ipairs(self.UI.ColorPresets) do
        table.insert(picker.Swatches, self:_CreateSwatchObject(color, false))
    end

    -- Создаем кнопку "Добавить", если есть место
    if #self.UI.ColorPresets < 7 then
        table.insert(picker.Swatches, self:_CreateSwatchObject(nil, true))
    end
end

function Library:_UpdateAllAnimations()
    local anyAnimationActive = false

    -- Обновляем анимации всех попапов
    self:_UpdatePopupAnimation(self.UI.Core.AboutWindow)
    self:_UpdatePopupAnimation(self.UI.Popups.EditStyle)
    self:_UpdatePopupAnimation(self.UI.Popups.ColorPicker)
    self:_UpdatePopupAnimation(self.UI.Popups.BurgerMenu)
    self:_UpdatePopupAnimation(self.UI.Watermark)
    self:_UpdatePopupAnimation(self.UI.Hotkeys)
    self:_UpdatePopupAnimation(self.UI.Core.ConfigsTab.OptionsPopup) -- << [НОВОЕ] Добавляем попап конфигов
    self:_UpdatePopupAnimation(self.UI.Core.SaveTooltip)
    self:_UpdateSidePanelAnimation(self.UI.Core.HeaderButtons.ViewESP)
    -- << [НОВОЕ] Добавляем попап настроек в цикл обновления анимаций >>
    self:_UpdatePopupAnimation(self.UI.Popups.Settings) 
    self:_UpdatePopupAnimation(self.UI.Watermark)

    -- Проверяем, активна ли анимация хоть одного попапа
    for _, popup in pairs(self.UI.Popups) do
        if popup.Animation and (popup.Animation.IsOpening or popup.Animation.IsClosing) then
            anyAnimationActive = true
            break
        end
    end
    if not anyAnimationActive then
        if self.UI.Core.AboutWindow.Animation.IsOpening or self.UI.Core.AboutWindow.Animation.IsClosing then anyAnimationActive = true end
    end
    if not anyAnimationActive then
        if self.UI.Watermark.Animation.IsOpening or self.UI.Watermark.Animation.IsClosing then anyAnimationActive = true end
    end
    if not anyAnimationActive then
        if self.UI.Hotkeys.Animation.IsOpening or self.UI.Hotkeys.Animation.IsClosing then anyAnimationActive = true end
    end
    -- << [НОВОЕ] Проверяем попап конфигов отдельно
    if not anyAnimationActive then
        if self.UI.Core.ConfigsTab.OptionsPopup.Animation.IsOpening or self.UI.Core.ConfigsTab.OptionsPopup.Animation.IsClosing then anyAnimationActive = true end
    end


    -- Обновляем и проверяем анимацию смены вкладок
    self:_UpdateAnimationStates()
    if self.Window.Animation.State ~= "IDLE" then
        anyAnimationActive = true
    end

    -- Обновляем и проверяем глобальную анимацию (появление/исчезновение UI)
    if self.GlobalAnimation.IsHiding or self.GlobalAnimation.IsShowing then
        anyAnimationActive = true
    end

    if not self.UI.Values["BurgerLow-EndMode"] and not anyAnimationActive then
        for _, section in ipairs(self.UI.Sections) do
            for _, el in ipairs(section.Elements) do
                if el.type == "Toggle" then
                    local is_on = self.UI.Values[el.id]
                    local targetOffset = is_on and (el.Size.width - el.Size.height / 2) or (el.Size.height / 2)
                    if math.abs(el.AnimatedNubOffset - targetOffset) > 0.1 then
                        anyAnimationActive = true; break
                    end
                elseif el.type == "Slider" then
                    local targetValue = self.UI.Values[el.id]
                    if math.abs(el.AnimatedValue - targetValue) > 0.01 then
                        anyAnimationActive = true; break
                    end
                elseif el.type == "Dropdown" or el.type == "Multidropdown" then
                    if el.IsClosing or (el.IsOpen and el.FadeOpacity < 1) then
                        anyAnimationActive = true; break
                    end
                end
            end
            if anyAnimationActive then break end
        end
        
        if not anyAnimationActive then
            local slider_about = self.UI.Core.AboutWindow.AnimationSpeedSlider
            if slider_about then
                 local targetValue = self.UI.Values[slider_about.id]
                 if math.abs(slider_about.AnimatedValue - targetValue) > 0.01 then
                    anyAnimationActive = true
                 end
            end
        end
    end

    return anyAnimationActive
end

function Library:_UpdateSidePanelAnimation(panelController)
    if not panelController.Animation then return end
    local anim = panelController.Animation
    local speed_value = self.UI.Values["AboutAnimationSpeed"] or 2.4
    local animationSpeed = (speed_value > 0) and (speed_value / 25.0) or 1

    if anim.IsOpening then
        anim.CurrentOpacity = math.min(1.0, anim.CurrentOpacity + animationSpeed)
        if anim.CurrentOpacity >= 1.0 then anim.IsOpening = false end
    elseif anim.IsClosing then
        anim.CurrentOpacity = math.max(0.0, anim.CurrentOpacity - animationSpeed)
        if anim.CurrentOpacity <= 0.0 then anim.IsClosing = false end
    end
end

function Library:_ProcessRemovalQueue()
    if #self.ObjectsToRemove > 0 then
        for _, obj in ipairs(self.ObjectsToRemove) do
            pcall(obj.Remove, obj)
        end
        -- Очищаем очередь после обработки
        self.ObjectsToRemove = {}
    end
end


--================================================================
--[[ PRIVATE: GLOW EFFECT HELPERS ]]
--================================================================

function Library:_Internal_CreateGlowSet(zIndex, count)
    local glowSet = {}
    count = count or 20
    for i = 1, count do
        local glowSquare = self:_CreateDrawingObject("Square")
        if glowSquare then
            glowSquare.Filled = true
            glowSquare.zIndex = zIndex - i
            table.insert(glowSet, glowSquare)
        end
    end
    return glowSet
end

function Library:_RenderGlowEffect(glowSet, x, y, width, height, rounding, targetColor, sides, masterOpacity)
    -- [[ ИЗМЕНЕНИЕ: Добавляем проверку на Low-End Mode и опцию Glow ]]
    if self.UI.Values["BurgerLowEndMode"] or not self.UI.Values["BurgerGlow"] then
        self:_HideGlowEffect(glowSet)
        return
    end

    if not glowSet or #glowSet == 0 or not targetColor then return end

    local maxGlowLayers = self.Window.IsFastDragging and 5 or #glowSet

    local globalOpacity = self.GlobalAnimation and self.GlobalAnimation.Opacity or 1
    masterOpacity = masterOpacity or 1

    sides = sides or {top=true, bottom=true, left=true, right=true}

    local glowBaseOpacity = (targetColor[4] or 255) / 255
    local targetGlowRGB = {targetColor[1], targetColor[2], targetColor[3]}

    for i, glowSquare in ipairs(glowSet) do
        if i > maxGlowLayers then
            self:_SetVisibility(glowSquare, false)
        else
            local spread = i * 0.6
            local glowX, glowY, glowW, glowH = x, y, width, height

            if sides.left then glowX = x - spread; glowW = glowW + spread; end
            if sides.right then glowW = glowW + spread; end
            if sides.top then glowY = y - spread; glowH = glowH + spread; end
            if sides.bottom then glowH = glowH + spread; end

            glowSquare.Position = {glowX, glowY}
            glowSquare.Size = {glowW, glowH}
            glowSquare.Rounding = rounding + spread

            local finalColor
            if self.Window.IsFastDragging or self.UI.Values["BurgerLowEndMode"] then
                finalColor = targetGlowRGB
            else
                local state = self.AnimationState[glowSquare]
                if not state then
                    state = { CurrentColor = self:_DeepCopy(targetGlowRGB) }
                    self.AnimationState[glowSquare] = state
                end
                local speed_value = self.UI.Values["AboutAnimationSpeed"] or 2.5
                local animationSpeed = speed_value / 16.0
                state.CurrentColor = self:_LerpColor(state.CurrentColor, targetGlowRGB, animationSpeed)
                finalColor = state.CurrentColor
            end
            
            glowSquare.Color = {finalColor[1], finalColor[2], finalColor[3]}

            local alpha_factor = 0.24 * math.exp(-0.24 * i)
            glowSquare.Opacity = glowBaseOpacity * globalOpacity * alpha_factor * masterOpacity

            self:_SetVisibility(glowSquare, true)
        end
    end
end



function Library:_HideGlowEffect(glowSet)
    if not glowSet then return end
    for _, glowSquare in ipairs(glowSet) do
        self:_SetVisibility(glowSquare, false)
    end
end


--================================================================
--[[ PRIVATE: INITIALIZATION & CORE UI ]]
--================================================================

function Library:_InitializeCoreUI()
    local UI = self.UI; UI.Core = {}

    UI.Core.Sidebar = { Drawing = self:_CreateDrawingObject("Square"), Glow = self:_Internal_CreateGlowSet(0) }
    UI.Core.RightPanel = { Drawing = self:_CreateDrawingObject("Square"), Glow = self:_Internal_CreateGlowSet(0) }
    UI.Core.VerticalSeparator = self:_CreateDrawingObject("Square")
    UI.Core.SidebarHeaderSeparator = self:_CreateDrawingObject("Square")
    UI.Core.RightPanelHeaderSeparator = self:_CreateDrawingObject("Square")
    
    if UI.Core.Sidebar.Drawing then UI.Core.Sidebar.Drawing.Filled = true; UI.Core.Sidebar.Drawing.zIndex = 1; UI.Core.Sidebar.Drawing.Rounding = self.ActiveTheme.Rounding.Window; end
    if UI.Core.RightPanel.Drawing then UI.Core.RightPanel.Drawing.Filled = true; UI.Core.RightPanel.Drawing.zIndex = 1; UI.Core.RightPanel.Drawing.Rounding = self.ActiveTheme.Rounding.Window; end
    if UI.Core.VerticalSeparator then UI.Core.VerticalSeparator.Filled = true; UI.Core.VerticalSeparator.zIndex = 3; end
    if UI.Core.SidebarHeaderSeparator then UI.Core.SidebarHeaderSeparator.Filled = true; UI.Core.SidebarHeaderSeparator.zIndex = 2; end
    if UI.Core.RightPanelHeaderSeparator then UI.Core.RightPanelHeaderSeparator.Filled = true; UI.Core.RightPanelHeaderSeparator.zIndex = 2; end

    UI.Core.Title = self:_CreateDrawingObject("Text"); UI.Core.Title2 = self:_CreateDrawingObject("Text"); UI.Core.Title3 = self:_CreateDrawingObject("Text")
    if UI.Core.Title then UI.Core.Title.Font = self.ActiveTheme.Fonts.Title; UI.Core.Title.Size = self.ActiveTheme.Fonts.TitleSize; UI.Core.Title.Text = "NEVERLOSE"; UI.Core.Title.Center = false; UI.Core.Title.Outline = false; UI.Core.Title.zIndex = 5; end
    if UI.Core.Title2 then UI.Core.Title2.Font = self.ActiveTheme.Fonts.Title; UI.Core.Title2.Size = self.ActiveTheme.Fonts.TitleSize; UI.Core.Title2.Text = "NEVERLOSE"; UI.Core.Title2.Center = false; UI.Core.Title2.Outline = false; UI.Core.Title2.zIndex = 4; end
    if UI.Core.Title3 then UI.Core.Title3.Font = self.ActiveTheme.Fonts.Title; UI.Core.Title3.Size = self.ActiveTheme.Fonts.TitleSize; UI.Core.Title3.Text = "NEVERLOSE"; UI.Core.Title3.Center = false; UI.Core.Title3.Outline = false; UI.Core.Title3.zIndex = 3; end

    UI.Core.SidebarBottomCircle = self:_CreateDrawingObject("Circle"); if UI.Core.SidebarBottomCircle then UI.Core.SidebarBottomCircle.Filled = false; UI.Core.SidebarBottomCircle.Thickness = 3; UI.Core.SidebarBottomCircle.zIndex = 6; UI.Core.SidebarBottomCircle.Radius = 28; end
    UI.Core.PlayerDisplayName = self:_CreateDrawingObject("Text"); if UI.Core.PlayerDisplayName then UI.Core.PlayerDisplayName.Font = self.ActiveTheme.Fonts.Main; UI.Core.PlayerDisplayName.Size = self.ActiveTheme.Fonts.Size + 2; UI.Core.PlayerDisplayName.Text = ""; UI.Core.PlayerDisplayName.Center = false; UI.Core.PlayerDisplayName.Outline = false; UI.Core.PlayerDisplayName.zIndex = 7; end
    UI.Core.TillLabel = self:_CreateDrawingObject("Text"); if UI.Core.TillLabel then UI.Core.TillLabel.Font = self.ActiveTheme.Fonts.Main; UI.Core.TillLabel.Size = self.ActiveTheme.Fonts.Size; UI.Core.TillLabel.Text = "Till:"; UI.Core.TillLabel.Center = false; UI.Core.TillLabel.Outline = false; UI.Core.TillLabel.zIndex = 7; end
    UI.Core.ForeverLabel = self:_CreateDrawingObject("Text"); if UI.Core.ForeverLabel then UI.Core.ForeverLabel.Font = self.ActiveTheme.Fonts.Main; UI.Core.ForeverLabel.Size = self.ActiveTheme.Fonts.Size; UI.Core.ForeverLabel.Text = " Forever"; UI.Core.ForeverLabel.Center = false; UI.Core.ForeverLabel.Outline = false; UI.Core.ForeverLabel.zIndex = 7; end

    UI.Core.HeaderButtons = {
        Save = { Background = self:_CreateDrawingObject("Square"), Border = self:_CreateDrawingObject("Square"), Label = self:_CreateDrawingObject("Text"), Icon = self:_CreateDrawingObject("Image"), ClickRegion = {}, ClickTime = 0, IsHovered = false, CurrentColor = {0,0,0,0} },
        ViewESP = { Background = self:_CreateDrawingObject("Square"), Border = self:_CreateDrawingObject("Square"), Label = self:_CreateDrawingObject("Text"), ClickRegion = {}, ClickTime = 0, IsOpen = false, Animation = { IsOpening = false, IsClosing = false, CurrentOpacity = 0 } },
        CreateNew = { Background = self:_CreateDrawingObject("Square"), Border = self:_CreateDrawingObject("Square"), Label = self:_CreateDrawingObject("Text"), Icon = self:_CreateDrawingObject("Image"), ClickRegion = {}, ClickTime = 0 },
        Settings = { Icon = self:_CreateDrawingObject("Image"), ClickRegion = {} }
    }
    
    UI.Core.SaveTooltip = {
        Background = self:_CreateDrawingObject("Square"),
        Border = self:_CreateDrawingObject("Square"),
        Glow = self:_Internal_CreateGlowSet(49),
        ConfigName = self:_CreateDrawingObject("Text"),
        Author = self:_CreateDrawingObject("Text"),
        Animation = { IsOpening = false, IsClosing = false, CurrentOpacity = 0 } -- << ДОБАВЛЕНО
    }
    
    --[[ ИЗМЕНЕНИЕ: Убираем self.UI.Popups.About отсюда, так как состояние будет храниться в self.UI.Core.AboutWindow ]]

    local function setupHeaderButton(button, text, has_icon)
        if button.Background then button.Background.Filled = true; button.Background.zIndex = 2; button.Background.Rounding = self.ActiveTheme.Rounding.Button; end
        if button.Border then button.Border.Filled = false; button.Border.Thickness = 1; button.Border.zIndex = 3; button.Border.Rounding = self.ActiveTheme.Rounding.Button; end
        if button.Label then button.Label.Font = self.ActiveTheme.Fonts.Main; button.Label.Size = self.ActiveTheme.Fonts.Size; button.Label.Text = text; button.Label.Center = false; button.Label.Outline = false; button.Label.zIndex = 4; end
        if button.Icon and has_icon then button.Icon.Size = {13.33, 13.33}; button.Icon.zIndex = 5; button.Icon.Visible = true;
        else if button.Icon then button.Icon.Visible = false end end
    end
    setupHeaderButton(UI.Core.HeaderButtons.Save, " Save", true)
    setupHeaderButton(UI.Core.HeaderButtons.ViewESP, "View ESP", false)
    setupHeaderButton(UI.Core.HeaderButtons.CreateNew, " Create new", true)
    
    if UI.Core.HeaderButtons.Save.Icon then UI.Core.HeaderButtons.Save.Icon.Url = "https://i.postimg.cc/0QgnsgKT/vaseinko.png"; end
    if UI.Core.HeaderButtons.CreateNew.Icon then UI.Core.HeaderButtons.CreateNew.Icon.Url = "https://i.imgur.com/plus-sign-icon.png"; end -- иконка у create new в header
    if UI.Core.HeaderButtons.Settings.Icon then UI.Core.HeaderButtons.Settings.Icon.Url = "https://i.postimg.cc/QMZSLGTR/image.png"; UI.Core.HeaderButtons.Settings.Icon.Size = {20, 20}; UI.Core.HeaderButtons.Settings.Icon.zIndex = 5; end
    UI.Core.ViewESPImage = self:_CreateDrawingObject("Image")

    local tooltip = UI.Core.SaveTooltip
    if tooltip.Background then tooltip.Background.Filled = true; tooltip.Background.zIndex = 50; tooltip.Background.Rounding = self.ActiveTheme.Rounding.Element; end
    if tooltip.Border then tooltip.Border.Filled = false; tooltip.Border.Thickness = 1; tooltip.Border.zIndex = 51; tooltip.Border.Rounding = self.ActiveTheme.Rounding.Element; end
    if tooltip.ConfigName then tooltip.ConfigName.Font = self.ActiveTheme.Fonts.Main; tooltip.ConfigName.Size = self.ActiveTheme.Fonts.Size + 2; tooltip.ConfigName.zIndex = 51; end
    if tooltip.Author then tooltip.Author.Font = self.ActiveTheme.Fonts.Main; tooltip.Author.Size = self.ActiveTheme.Fonts.Size; tooltip.Author.zIndex = 51; end

    UI.Core.ViewESPPanel = self:_CreateDrawingObject("Square"); if UI.Core.ViewESPPanel then UI.Core.ViewESPPanel.Filled = true; UI.Core.ViewESPPanel.zIndex = 1; UI.Core.ViewESPPanel.Rounding = self.ActiveTheme.Rounding.Window; end
    if UI.Core.ViewESPImage then UI.Core.ViewESPImage.zIndex = 2; UI.Core.ViewESPImage.Visible = false; UI.Core.ViewESPImage.Url = "https://i.postimg.cc/sgvbDYfL/image.png"; UI.Core.ViewESPImage.Rounding = self.ActiveTheme.Rounding.Window - 2; end
    UI.Core.ViewESPPanelBorder = self:_CreateDrawingObject("Square"); if UI.Core.ViewESPPanelBorder then UI.Core.ViewESPPanelBorder.Filled = false; UI.Core.ViewESPPanelBorder.Thickness = 1; UI.Core.ViewESPPanelBorder.zIndex = 3; UI.Core.ViewESPPanelBorder.Rounding = self.ActiveTheme.Rounding.Window; end

    self:_InitializeAboutWindow()
    self:_InitializeSettingsPopup()
    self:_InitializeEditStyleWindow()
    self:_InitializeColorPickerWindow()
    self:_InitializeConfigsTab()
    self:_InitializeBurgerMenu()
    self:_InitializeWatermark() 
    self:_InitializeHotkeys() 

    local Players = game:FindService("Players")
    if Players and Players.localPlayer then
        local localPlayerName = Players.localPlayer.Name
        UI.Core.PlayerDisplayName.Text = localPlayerName
        if UI.Core.AboutWindow.InfoRegisteredToValue then UI.Core.AboutWindow.InfoRegisteredToValue.Text = " " .. localPlayerName end
        local userId = Players.localPlayer.UserId
        if userId and userId > 0 then
            local avatarUrl; pcall(function() avatarUrl = self:_getAvatarThumbnail(userId) end)
            if avatarUrl then
                UI.Core.SidebarAvatar = self:_CreateDrawingObject("Image")
                if UI.Core.SidebarAvatar then UI.Core.SidebarAvatar.Size = {56, 56}; UI.Core.SidebarAvatar.Position = {0, 0}; UI.Core.SidebarAvatar.Opacity = 1; UI.Core.SidebarAvatar.Visible = true; UI.Core.SidebarAvatar.zIndex = 4; UI.Core.SidebarAvatar.Url = avatarUrl; UI.Core.SidebarAvatar.Rounding = 28; end
            end
        end
    end
    
    UI.Core.HeaderButtons.Save.CurrentColor = self:_DeepCopy(self.ActiveTheme.Colors.MainBackground)
end

function Library:_InitializeBurgerMenu()
    local z = 30
    local headerButtons = self.UI.Core.HeaderButtons

    headerButtons.BurgerMenu = {
        Line1 = self:_CreateDrawingObject("Line"),
        Line2 = self:_CreateDrawingObject("Line"),
        Line3 = self:_CreateDrawingObject("Line"),
        ClickRegion = {},
        Pos = {x = 0, y = 0}
    }
    if headerButtons.BurgerMenu.Line1 then headerButtons.BurgerMenu.Line1.Thickness = 2; headerButtons.BurgerMenu.Line1.zIndex = 5; end
    if headerButtons.BurgerMenu.Line2 then headerButtons.BurgerMenu.Line2.Thickness = 2; headerButtons.BurgerMenu.Line2.zIndex = 5; end
    if headerButtons.BurgerMenu.Line3 then headerButtons.BurgerMenu.Line3.Thickness = 2; headerButtons.BurgerMenu.Line3.zIndex = 5; end

    local popup = { IsOpen = false, Animation = { IsOpening = false, IsClosing = false, CurrentOpacity = 0 } };
    self.UI.Popups.BurgerMenu = popup
    popup.Pos = {x=0, y=0}
    popup.Background = self:_CreateDrawingObject("Square"); if popup.Background then popup.Background.Filled = true; popup.Background.zIndex = z; popup.Background.Rounding = self.ActiveTheme.Rounding.Section; end
    popup.Border = self:_CreateDrawingObject("Square"); if popup.Border then popup.Border.Filled = false; popup.Border.Thickness = 1; popup.Border.zIndex = z + 1; popup.Border.Rounding = self.ActiveTheme.Rounding.Section; end
    popup.Glow = self:_Internal_CreateGlowSet(z - 1)

    popup.Items = {}
    -- [[ ИЗМЕНЕНИЕ: Добавляем "Glow" и "Low-End Mode" ]]
    local itemNames = {"Watermark", "Hotkeys", "Glow", "Low-End Mode"}

    for _, name in ipairs(itemNames) do
        local id = "Burger" .. name:gsub(" ", "") -- Убираем пробелы для ID
        
        -- [[ ИЗМЕНЕНИЕ: Устанавливаем значения по умолчанию ]]
        if self.UI.Values[id] == nil then
            if name == "Glow" then
                self.UI.Values[id] = true -- Glow включен по умолчанию
            else
                self.UI.Values[id] = false
            end
        end

        local item = {
            id = id,
            Name = name,
            Icon = self:_CreateDrawingObject("Image"),
            Label = self:_CreateDrawingObject("Text"),
            CheckmarkLine1 = self:_CreateDrawingObject("Line"),
            CheckmarkLine2 = self:_CreateDrawingObject("Line"),
            Highlight = self:_CreateDrawingObject("Square"),
            ClickRegion = {}
        }

        if item.Icon then
            item.Icon.Size = {17, 17};
            item.Icon.zIndex = z + 2;
            -- [[ ИЗМЕНЕНИЕ: Добавляем иконки для новых опций ]]
            if name == "Watermark" then
                item.Icon.Url = "https://i.postimg.cc/hhFQJgcn/image.png"
            elseif name == "Hotkeys" then
                item.Icon.Url = "https://i.postimg.cc/0jSdXVN8/image.png"
            elseif name == "Glow" then
                item.Icon.Url = "https://i.postimg.cc/qMCsGww0/image.png" -- Иконка свечения
            elseif name == "Low-End Mode" then
                item.Icon.Url = "https://i.postimg.cc/jd04w0mc/badpc.png" -- Иконка легкости
            end
        end
        if item.Label then item.Label.Font = self.ActiveTheme.Fonts.Main; item.Label.Size = self.ActiveTheme.Fonts.Size + 1; item.Label.Text = name; item.Label.zIndex = z + 2; end
        if item.CheckmarkLine1 then item.CheckmarkLine1.Thickness = 2; item.CheckmarkLine1.zIndex = z + 3; end
        if item.CheckmarkLine2 then item.CheckmarkLine2.Thickness = 2; item.CheckmarkLine2.zIndex = z + 3; end
        if item.Highlight then item.Highlight.Filled = true; item.Highlight.zIndex = z + 1; item.Highlight.Rounding = self.ActiveTheme.Rounding.Element; end

        table.insert(popup.Items, item)
    end
end


function Library:_InitializeAboutWindow()
    local about = {}; 
    self.UI.Core.AboutWindow = about; 
    local about_z = 32

    -- [[ ИЗМЕНЕНИЕ: Добавляем состояние и анимацию сюда ]]
    about.IsOpen = false
    about.Animation = { IsOpening = false, IsClosing = false, CurrentOpacity = 0 }
    
    about.StyleCircles = {}
    about.HoveredThemeCircle = { Name = nil, HoverStartTime = 0 }
    about.Background = self:_CreateDrawingObject("Square"); if about.Background then about.Background.Filled = true; about.Background.zIndex = 30; about.Background.Rounding = self.ActiveTheme.Rounding.Section; end
    about.Border = self:_CreateDrawingObject("Square"); if about.Border then about.Border.Filled = false; about.Border.Thickness = 1; about.Border.zIndex = 31; about.Border.Rounding = self.ActiveTheme.Rounding.Section; end
    about.Glow = self:_Internal_CreateGlowSet(29)
    about.HeaderIcon = self:_CreateDrawingObject("Image"); if about.HeaderIcon then about.HeaderIcon.Url = "https://i.postimg.cc/QMZSLGTR/image.png"; about.HeaderIcon.Size = {16, 16}; about.HeaderIcon.zIndex = about_z; end
    about.HeaderTitle = self:_CreateDrawingObject("Text"); if about.HeaderTitle then about.HeaderTitle.Font = self.ActiveTheme.Fonts.Main; about.HeaderTitle.Size = self.ActiveTheme.Fonts.Size + 2; about.HeaderTitle.Text = "About Neverlose"; about.HeaderTitle.Center = false; about.HeaderTitle.zIndex = about_z; end
    about.CloseButton = { Line1 = self:_CreateDrawingObject("Line"), Line2 = self:_CreateDrawingObject("Line"), ClickRegion = {} }; if about.CloseButton.Line1 then about.CloseButton.Line1.Thickness = 2; about.CloseButton.Line1.zIndex = about_z; end; if about.CloseButton.Line2 then about.CloseButton.Line2.Thickness = 2; about.CloseButton.Line2.zIndex = about_z; end

    local separatorThickness = 2
    about.Separator1 = self:_CreateDrawingObject("Line"); if about.Separator1 then about.Separator1.Thickness = separatorThickness; about.Separator1.zIndex = 31; end
    about.MainTitle = self:_CreateDrawingObject("Text"); if about.MainTitle then about.MainTitle.Font = self.ActiveTheme.Fonts.Title; about.MainTitle.Size = 27; about.MainTitle.Text = "NEVERLOSE.CC"; about.MainTitle.Center = true; about.MainTitle.zIndex = about_z; end
    about.Separator2 = self:_CreateDrawingObject("Line"); if about.Separator2 then about.Separator2.Thickness = separatorThickness; about.Separator2.zIndex = 31; end

    local function setupInfoText(label_text, value_text)
        local label = self:_CreateDrawingObject("Text"); local value = self:_CreateDrawingObject("Text")
        if label then label.Font = self.ActiveTheme.Fonts.Main; label.Size = self.ActiveTheme.Fonts.Size + 2; label.Text = label_text; label.Center = false; label.zIndex = about_z; end
        if value then value.Font = self.ActiveTheme.Fonts.Main; value.Size = self.ActiveTheme.Fonts.Size + 2; value.Text = value_text; value.Center = false; value.zIndex = about_z; end
        return label, value
    end
    about.InfoVersionLabel, about.InfoVersionValue = setupInfoText("Version:", " 1.0.0")
    about.InfoBuildDateLabel, about.InfoBuildDateValue = setupInfoText("Build date:", " Aug 11 2025")
    about.InfoBuildTypeLabel, about.InfoBuildTypeValue = setupInfoText("Build type:", " Beta")
    about.InfoRegisteredToLabel, about.InfoRegisteredToValue = setupInfoText("Registered to:", "")
    about.InfoSubscriptionLabel, about.InfoSubscriptionValue = setupInfoText("Subscription till:", " FOREVER")

    about.FooterText = self:_CreateDrawingObject("Text"); if about.FooterText then about.FooterText.Font = self.ActiveTheme.Fonts.Main; about.FooterText.Size = self.ActiveTheme.Fonts.Size - 1; about.FooterText.Text = "neverlose.cc © 2025"; about.FooterText.Center = true; about.FooterText.zIndex = about_z; end
    about.Separator3 = self:_CreateDrawingObject("Line"); if about.Separator3 then about.Separator3.Thickness = separatorThickness; about.Separator3.zIndex = 31; end
    about.CreditText = self:_CreateDrawingObject("Text"); if about.CreditText then about.CreditText.Font = self.ActiveTheme.Fonts.Main; about.CreditText.Size = self.ActiveTheme.Fonts.Size; about.CreditText.Text = "UI by Dicky_Micky_"; about.CreditText.Center = true; about.CreditText.zIndex = about_z; end

    about.AutoSaveToggle = self:_Internal_CreateToggle({ id = "AboutAutoSave", Name = "Auto Save", Default = false, zIndex = about_z });

    about.ToggleUIKeybind = self:_Internal_CreateKeybind({ id = "ToggleUIBind", Name = "Toggle UI", Default = "insert", zIndex = about_z })

    about.AnimationSpeedSlider = self:_Internal_CreateSlider({ id = "AboutAnimationSpeed", Name = "Animation Speed", Min = 0, Max = 5, Default = 2.4, Increment = 0.1, zIndex = about_z });

    about.StyleLabel, _ = setupInfoText("Style", "");

    local tooltip_z = 60
    about.Tooltip = { Background = self:_CreateDrawingObject("Square"), Text = self:_CreateDrawingObject("Text") }
    if about.Tooltip.Background then about.Tooltip.Background.Filled = true; about.Tooltip.Background.zIndex = tooltip_z; about.Tooltip.Background.Rounding = self.ActiveTheme.Rounding.Element; end
    if about.Tooltip.Text then about.Tooltip.Text.Font = self.ActiveTheme.Fonts.Main; about.Tooltip.Text.Size = self.ActiveTheme.Fonts.Size; about.Tooltip.Text.Center = false; about.Tooltip.Text.zIndex = tooltip_z + 1; end

    self:_RebuildStyleCircles()
    self.UI.Values["AboutSelectedStyle"] = "Blue"
end

function Library:_RebuildStyleCircles()
    local about = self.UI.Core.AboutWindow
    local about_z = 32

    for _, circle in ipairs(about.StyleCircles) do
        if circle.Circle then circle.Circle:Remove() end
        if circle.Border then circle.Border:Remove() end
        if circle.Inner then circle.Inner:Remove() end
        if circle.PlusLine1 then circle.PlusLine1:Remove() end
        if circle.PlusLine2 then circle.PlusLine2:Remove() end
    end
    about.StyleCircles = {}

    local function addCircle(theme, isAddButton)
        local circleObj = {
            Name = theme.Name,
            IsAddButton = isAddButton or false,
            Circle = self:_CreateDrawingObject("Circle"),
            Border = self:_CreateDrawingObject("Circle"),
            ClickRegion = {}
        }

        if circleObj.Circle then 
            circleObj.Circle.Filled = true; 
            circleObj.Circle.zIndex = about_z; 
            circleObj.Circle.Radius = 9; 
            local c = (theme.Colors and theme.Colors.MainBackground) or {40,40,40,255};
            circleObj.Circle.Color = {c[1], c[2], c[3]};
            circleObj.Circle.Opacity = (c[4] or 255) / 255;
        end
        if circleObj.Border then circleObj.Border.Filled = false; circleObj.Border.Thickness = 2; circleObj.Border.zIndex = about_z + 1; circleObj.Border.Radius = 11; circleObj.Border.Visible = false; end

        if isAddButton then
            circleObj.PlusLine1 = self:_CreateDrawingObject("Line"); if circleObj.PlusLine1 then circleObj.PlusLine1.Thickness = 2; circleObj.PlusLine1.zIndex = about_z + 1; end
            circleObj.PlusLine2 = self:_CreateDrawingObject("Line"); if circleObj.PlusLine2 then circleObj.PlusLine2.Thickness = 2; circleObj.PlusLine2.zIndex = about_z + 1; end
        else
            circleObj.Inner = self:_CreateDrawingObject("Circle"); if circleObj.Inner then 
                circleObj.Inner.Filled = true; 
                circleObj.Inner.zIndex = about_z + 1; 
                circleObj.Inner.Radius = 4;
                local c = theme.Colors.Accent;
                circleObj.Inner.Color = {c[1], c[2], c[3]};
                circleObj.Inner.Opacity = (c[4] or 255) / 255;
            end
        end
        table.insert(about.StyleCircles, circleObj)
    end

    local themeOrder = {}
    local customThemeNames = {}
    for themeName, themeData in pairs(self.Themes) do
        if not themeData.IsPreset then
            table.insert(customThemeNames, themeName)
        end
    end
    table.sort(customThemeNames)

    -- Build the final list in display order (which will be rendered right-to-left)
    table.insert(themeOrder, {Name = "Add"}) -- Slot 1
    table.insert(themeOrder, self.Themes.Black) -- Slot 2
    table.insert(themeOrder, self.Themes.White) -- Slot 3
    table.insert(themeOrder, self.Themes.Blue) -- Slot 4
    for _, themeName in ipairs(customThemeNames) do -- Slots 5+
        table.insert(themeOrder, self.Themes[themeName])
    end
    
    for _, themeData in ipairs(themeOrder) do
        addCircle(themeData, themeData.Name == "Add")
    end
end

function Library:_InitializeSettingsPopup()
    local popup = {}; self.UI.Popups.Settings = popup; local z = 20
    popup.IsOpen = false; popup.Pos = {x=0, y=0}
    popup.Animation = { IsOpening = false, IsClosing = false, CurrentOpacity = 0 }
    popup.ActiveToggle = nil -- Ссылка на Toggle, чьи настройки открыты 

    -- Создаем базовые элементы окна: фон, границу и свечение [cite: 46, 47]
    popup.Background = self:_CreateDrawingObject("Square"); if popup.Background then popup.Background.Filled = true; popup.Background.zIndex = z; popup.Background.Rounding = self.ActiveTheme.Rounding.Section; end
    popup.Border = self:_CreateDrawingObject("Square"); if popup.Border then popup.Border.Filled = false; popup.Border.Thickness = 1; popup.Border.zIndex = z + 1; popup.Border.Rounding = self.ActiveTheme.Rounding.Section; end
    popup.Glow = self:_Internal_CreateGlowSet(z - 1)
    
    -- Создаем заголовок и разделитель [cite: 46]
    popup.Title = self:_CreateDrawingObject("Text"); if popup.Title then popup.Title.Font = self.ActiveTheme.Fonts.Main; popup.Title.Size = self.ActiveTheme.Fonts.Size + 4; popup.Title.Text = "Settings"; popup.Title.Center = false; popup.Title.Outline = false; popup.Title.zIndex = z + 2; end
    popup.Separator = self:_CreateDrawingObject("Line"); if popup.Separator then popup.Separator.Thickness = 2; popup.Separator.zIndex = z + 1; end

    popup.ClickRegion = {}
end

function Library:_InitializeEditStyleWindow()
    -- [[ ИЗМЕНЕНИЕ: Добавляем Animation table ]]
    local style_window = { IsOpen = false, Animation = { IsOpening = false, IsClosing = false, CurrentOpacity = 0 } }; 
    self.UI.Popups.EditStyle = style_window; 
    local z = 40
    style_window.IsEditingName = false
    style_window.last_key_press_time = 0
    style_window.key_press_delay = 0.05
    style_window.is_in_repeat = false
    style_window.last_key_pressed = ""
    style_window.ColorItems = {}
    style_window.EditingTheme = {}
    style_window.EditingThemeName = ""

    style_window.Background = self:_CreateDrawingObject("Square"); if style_window.Background then style_window.Background.Filled = true; style_window.Background.zIndex = z; style_window.Background.Rounding = self.ActiveTheme.Rounding.Section; end
    style_window.Border = self:_CreateDrawingObject("Square"); if style_window.Border then style_window.Border.Filled = false; style_window.Border.Thickness = 1; style_window.Border.zIndex = z + 1; style_window.Border.Rounding = self.ActiveTheme.Rounding.Section; end
    style_window.Glow = self:_Internal_CreateGlowSet(z - 1)
    
    style_window.HeaderIcon = self:_CreateDrawingObject("Square"); if style_window.HeaderIcon then style_window.HeaderIcon.Filled = true; style_window.HeaderIcon.zIndex = z + 2; style_window.HeaderIcon.Size = {18, 18}; end
    
    style_window.HeaderTitle = self:_CreateDrawingObject("Text"); if style_window.HeaderTitle then style_window.HeaderTitle.Font = self.ActiveTheme.Fonts.Main; style_window.HeaderTitle.Size = self.ActiveTheme.Fonts.Size + 3; style_window.HeaderTitle.Text = "Edit Style"; style_window.HeaderTitle.Center = false; style_window.HeaderTitle.zIndex = z + 2; end
    style_window.CloseButton = { Line1 = self:_CreateDrawingObject("Line"), Line2 = self:_CreateDrawingObject("Line"), ClickRegion = {} }; if style_window.CloseButton.Line1 then style_window.CloseButton.Line1.Thickness = 2; style_window.CloseButton.Line1.zIndex = z + 2; end; if style_window.CloseButton.Line2 then style_window.CloseButton.Line2.Thickness = 2; style_window.CloseButton.Line2.zIndex = z + 2; end
    style_window.Separator1 = self:_CreateDrawingObject("Line"); if style_window.Separator1 then style_window.Separator1.Thickness = 2; style_window.Separator1.zIndex = z + 1; end
    
    style_window.StyleNameLabel = self:_CreateDrawingObject("Text"); if style_window.StyleNameLabel then style_window.StyleNameLabel.Font = self.ActiveTheme.Fonts.Main; style_window.StyleNameLabel.Size = self.ActiveTheme.Fonts.Size + 1; style_window.StyleNameLabel.Text = "Style name"; style_window.StyleNameLabel.Center = false; style_window.StyleNameLabel.zIndex = z + 2; end
    style_window.StyleNameInputBg = self:_CreateDrawingObject("Square"); if style_window.StyleNameInputBg then style_window.StyleNameInputBg.Filled = true; style_window.StyleNameInputBg.zIndex = z + 2; style_window.StyleNameInputBg.Rounding = self.ActiveTheme.Rounding.Element; end
    style_window.StyleNameInputText = self:_CreateDrawingObject("Text"); if style_window.StyleNameInputText then style_window.StyleNameInputText.Font = self.ActiveTheme.Fonts.Main; style_window.StyleNameInputText.Size = self.ActiveTheme.Fonts.Size + 1; style_window.StyleNameInputText.Text = "Style"; style_window.StyleNameInputText.Center = false; style_window.StyleNameInputText.zIndex = z + 3; end
    style_window.StyleNameInputCursor = self:_CreateDrawingObject("Line"); if style_window.StyleNameInputCursor then style_window.StyleNameInputCursor.Thickness = 1.5; style_window.StyleNameInputCursor.zIndex = z + 4; end
    style_window.StyleNameInputClickRegion = {}
    
    style_window.Separator2 = self:_CreateDrawingObject("Line"); if style_window.Separator2 then style_window.Separator2.Thickness = 2; style_window.Separator2.zIndex = z + 1; end
    
    local color_order = {
        "Accent", "GlowColor", "GlowAccent", "MainBackground", "SectionBackground",
        "SidebarBackground", "WatermarkBackground", "HotkeysBackground", "DarkBlue", "DarkGray", "LightGray",
        "Separator", "TabHeader", "TextDark", "TextLight"
    }
    for _, colorName in ipairs(color_order) do
        local item = {
            Name = colorName,
            Label = self:_CreateDrawingObject("Text"),
            ColorCircle = self:_CreateDrawingObject("Circle"),
            ColorBorder = self:_CreateDrawingObject("Circle"),
            ClickRegion = {}
        }
        if item.Label then item.Label.Font = self.ActiveTheme.Fonts.Main; item.Label.Size = self.ActiveTheme.Fonts.Size + 1; item.Label.Text = colorName; item.Label.Center = false; item.Label.zIndex = z + 2; end
        if item.ColorCircle then item.ColorCircle.Filled = true; item.ColorCircle.zIndex = z + 2; item.ColorCircle.Radius = 8; end
        if item.ColorBorder then item.ColorBorder.Filled = false; item.ColorBorder.Thickness = 1; item.ColorBorder.zIndex = z + 3; item.ColorBorder.Radius = 9; end
        table.insert(style_window.ColorItems, item)
    end

    style_window.Separator3 = self:_CreateDrawingObject("Line"); if style_window.Separator3 then style_window.Separator3.Thickness = 2; style_window.Separator3.zIndex = z + 1; end

    style_window.RealTimeToggle = self:_Internal_CreateToggle({id = "EditStyleRealTime", Name = "real-time changes", Default = false, zIndex = z + 2})
    style_window.CancelButton = { Background = self:_CreateDrawingObject("Square"), Border = self:_CreateDrawingObject("Square"), IconLine1 = self:_CreateDrawingObject("Line"), IconLine2 = self:_CreateDrawingObject("Line"), Label = self:_CreateDrawingObject("Text"), ClickRegion = {} }
    style_window.SaveButton = { Background = self:_CreateDrawingObject("Square"), Label = self:_CreateDrawingObject("Text"), Icon = self:_CreateDrawingObject("Image"), ClickRegion = {} }

    if style_window.CancelButton.Background then style_window.CancelButton.Background.Filled = true; style_window.CancelButton.Background.zIndex = z + 2; style_window.CancelButton.Background.Rounding = self.ActiveTheme.Rounding.Button; end
    if style_window.CancelButton.Border then style_window.CancelButton.Border.Filled = false; style_window.CancelButton.Border.Thickness = 1; style_window.CancelButton.Border.zIndex = z + 3; style_window.CancelButton.Border.Rounding = self.ActiveTheme.Rounding.Button; end
    if style_window.CancelButton.IconLine1 then style_window.CancelButton.IconLine1.Thickness = 2; style_window.CancelButton.IconLine1.zIndex = z + 4; end
    if style_window.CancelButton.IconLine2 then style_window.CancelButton.IconLine2.Thickness = 2; style_window.CancelButton.IconLine2.zIndex = z + 4; end
    if style_window.CancelButton.Label then style_window.CancelButton.Label.Font = self.ActiveTheme.Fonts.Main; style_window.CancelButton.Label.Size = self.ActiveTheme.Fonts.Size; style_window.CancelButton.Label.Text = "Cancel"; style_window.CancelButton.Label.Center = false; style_window.CancelButton.Label.zIndex = z + 4; end

    if style_window.SaveButton.Background then style_window.SaveButton.Background.Filled = true; style_window.SaveButton.Background.zIndex = z + 2; style_window.SaveButton.Background.Rounding = self.ActiveTheme.Rounding.Button; end
    if style_window.SaveButton.Label then style_window.SaveButton.Label.Font = self.ActiveTheme.Fonts.Main; style_window.SaveButton.Label.Size = self.ActiveTheme.Fonts.Size; style_window.SaveButton.Label.Text = "Save"; style_window.SaveButton.Label.Center = false; style_window.SaveButton.Label.zIndex = z + 3; end
    if style_window.SaveButton.Icon then style_window.SaveButton.Icon.Url = "https://i.postimg.cc/0QgnsgKT/vaseinko.png"; style_window.SaveButton.Icon.Size = {13.33, 13.33}; style_window.SaveButton.Icon.zIndex = z + 3; end
end

function Library:_InitializeColorPickerWindow()
    local picker = { IsOpen = false, Animation = { IsOpening = false, IsClosing = false, CurrentOpacity = 0 } }; 
    self.UI.Popups.ColorPicker = picker; 
    local z = 50
    picker.EditingColorName = nil
    picker.EditingValueID = nil
    picker.Pos = {x=0, y=0}

    picker.h, picker.s, picker.v, picker.a = 0, 1, 1, 1
    picker.isDraggingHue = false
    picker.isDraggingOpacity = false
    picker.isDraggingSaturationValue = false
    picker.pressStartedInside = false

    picker.Mode = "HEX" 
    picker.InputText = ""
    picker.IsEditing = false
    picker.last_key_press_time = 0
    picker.key_press_delay = 0.05
    picker.is_in_repeat = false
    picker.last_key_pressed = ""

    picker.Background = self:_CreateDrawingObject("Square"); if picker.Background then picker.Background.Filled = true; picker.Background.zIndex = z; picker.Background.Rounding = self.ActiveTheme.Rounding.Window; end
    picker.Border = self:_CreateDrawingObject("Square"); if picker.Border then picker.Border.Filled = false; picker.Border.Thickness = 1; picker.Border.zIndex = z; picker.Border.Rounding = self.ActiveTheme.Rounding.Window; end
    picker.Glow = self:_Internal_CreateGlowSet(z - 1)
    picker.ColorSquare = self:_CreateDrawingObject("Square"); if picker.ColorSquare then picker.ColorSquare.Filled = true; picker.ColorSquare.zIndex = z + 1; picker.ColorSquare.Rounding = self.ActiveTheme.Rounding.Element; end
    picker.GradientOverlay = self:_CreateDrawingObject("Image"); if picker.GradientOverlay then picker.GradientOverlay.Url = "https://pixeldrain.com/api/filesystem/6mLiDUiK"; picker.GradientOverlay.zIndex = z + 2; picker.GradientOverlay.Rounding = self.ActiveTheme.Rounding.Element; end
    picker.SaturationValueNub = self:_CreateDrawingObject("Circle"); if picker.SaturationValueNub then picker.SaturationValueNub.Filled = false; picker.SaturationValueNub.Thickness = 2; picker.SaturationValueNub.Radius = 5; picker.SaturationValueNub.zIndex = z + 3; end

    picker.HueSlider = self:_CreateDrawingObject("Image"); if picker.HueSlider then picker.HueSlider.Url = "https://i.postimg.cc/RFMkBnt5/image.png"; picker.HueSlider.zIndex = z + 1; picker.HueSlider.Rounding = 4; end
    picker.HueNub = self:_CreateDrawingObject("Circle"); if picker.HueNub then picker.HueNub.Filled = true; picker.HueNub.Radius = 4; picker.HueNub.zIndex = z + 3; end
    picker.HueNubBorder = self:_CreateDrawingObject("Circle"); if picker.HueNubBorder then picker.HueNubBorder.Filled = false; picker.HueNubBorder.Thickness = 2; picker.HueNubBorder.Radius = 4; picker.HueNubBorder.zIndex = z + 2; end

    picker.OpacitySliderBackground = self:_CreateDrawingObject("Square"); if picker.OpacitySliderBackground then picker.OpacitySliderBackground.Filled = true; picker.OpacitySliderBackground.zIndex = z + 1; picker.OpacitySliderBackground.Rounding = 4; end
    picker.OpacitySliderGradient = self:_CreateDrawingObject("Image"); if picker.OpacitySliderGradient then picker.OpacitySliderGradient.Url = "https://pixeldrain.com/api/filesystem/2py1vehq"; picker.OpacitySliderGradient.zIndex = z + 2; picker.OpacitySliderGradient.Rounding = 4; end
    picker.OpacityNub = self:_CreateDrawingObject("Circle"); if picker.OpacityNub then picker.OpacityNub.Filled = true; picker.OpacityNub.Radius = 4; picker.OpacityNub.zIndex = z + 3; end
    picker.OpacityNubBorder = self:_CreateDrawingObject("Circle"); if picker.OpacityNubBorder then picker.OpacityNubBorder.Filled = false; picker.OpacityNubBorder.Thickness = 2; picker.OpacityNubBorder.Radius = 4; picker.OpacityNubBorder.zIndex = z + 2; end

    local inputZ = z + 10
    picker.Dropdown = {
        Button = self:_CreateDrawingObject("Square"),
        ButtonText = self:_CreateDrawingObject("Text"),
        ArrowLine1 = self:_CreateDrawingObject("Line"),
        ArrowLine2 = self:_CreateDrawingObject("Line"),
        PopupBg = self:_CreateDrawingObject("Square"),
        Border = self:_CreateDrawingObject("Square"),
        IsOpen = false,
        IsClosing = false,
        FadeOpacity = 0.0,
        Glow = self:_Internal_CreateGlowSet(inputZ + 4),
        Options = {},
        ClickRegion = {}
    }
    if picker.Dropdown.Button then picker.Dropdown.Button.Filled = true; picker.Dropdown.Button.zIndex = inputZ; picker.Dropdown.Button.Rounding = self.ActiveTheme.Rounding.Element; end
    if picker.Dropdown.ButtonText then picker.Dropdown.ButtonText.Font = self.ActiveTheme.Fonts.Main; picker.Dropdown.ButtonText.Size = self.ActiveTheme.Fonts.Size + 3; picker.Dropdown.ButtonText.zIndex = inputZ + 1; end
    if picker.Dropdown.ArrowLine1 then picker.Dropdown.ArrowLine1.Thickness = 2; picker.Dropdown.ArrowLine1.zIndex = inputZ + 2; end
    if picker.Dropdown.ArrowLine2 then picker.Dropdown.ArrowLine2.Thickness = 2; picker.Dropdown.ArrowLine2.zIndex = inputZ + 2; end
    if picker.Dropdown.PopupBg then picker.Dropdown.PopupBg.Filled = true; picker.Dropdown.PopupBg.zIndex = inputZ + 5; picker.Dropdown.PopupBg.Rounding = self.ActiveTheme.Rounding.Section; end
    if picker.Dropdown.Border then picker.Dropdown.Border.Filled = false; picker.Dropdown.Border.Thickness = 1; picker.Dropdown.Border.zIndex = inputZ + 6; picker.Dropdown.Border.Rounding = self.ActiveTheme.Rounding.Section; end

    for _, mode in ipairs({"HEX", "RGBA"}) do
        local option = { 
            Text = self:_CreateDrawingObject("Text"), 
            Highlight = self:_CreateDrawingObject("Square"),
            ClickRegion = {} 
        }
        if option.Text then option.Text.Font = self.ActiveTheme.Fonts.Main; option.Text.Size = self.ActiveTheme.Fonts.Size; option.Text.Text = mode; option.Text.zIndex = inputZ + 7; end
        if option.Highlight then option.Highlight.Filled = true; option.Highlight.zIndex = inputZ + 6; option.Highlight.Rounding = self.ActiveTheme.Rounding.Element; end
        table.insert(picker.Dropdown.Options, option)
    end

    picker.Input = {
        Background = self:_CreateDrawingObject("Square"),
        Text = self:_CreateDrawingObject("Text"),
        Cursor = self:_CreateDrawingObject("Line"),
        ClickRegion = {}
    }
    if picker.Input.Background then picker.Input.Background.Filled = true; picker.Input.Background.zIndex = inputZ; picker.Input.Background.Rounding = self.ActiveTheme.Rounding.Element; end
    if picker.Input.Text then picker.Input.Text.Font = self.ActiveTheme.Fonts.Main; picker.Input.Text.Size = self.ActiveTheme.Fonts.Size + 3; picker.Input.Text.zIndex = inputZ + 1; end
    if picker.Input.Cursor then picker.Input.Cursor.Thickness = 1.5; picker.Input.Cursor.zIndex = inputZ + 2; end

    picker.SaturationValueRegion = {}
    picker.HueSliderRegion = {}
    picker.OpacitySliderRegion = {}
    
    -- [[ ДОБАВЛЕНО: Инициализация пресетов ]]
    picker.Swatches = {}
    self:_RebuildColorSwatches()
end


function Library:_InitializeWatermark()
    -- [[ ИЗМЕНЕНИЕ: Добавляем Animation table ]]
    local wm = { Animation = { IsOpening = false, IsClosing = false, CurrentOpacity = 0 } }; 
    self.UI.Watermark = wm; 
    local z = 100

    wm.Position = {x = 20, y = 20}
    wm.IsDragging = false
    wm.DragOffset = {x = 0, y = 0}
    wm.Rounding = 13

    wm.DragArea = self:_CreateDrawingObject("Square")
    wm.LogoBg = self:_CreateDrawingObject("Square")
    wm.InfoBg = self:_CreateDrawingObject("Square")
    
    wm.LogoText1 = self:_CreateDrawingObject("Text")
    wm.LogoText2 = self:_CreateDrawingObject("Text")
    wm.LogoText3 = self:_CreateDrawingObject("Text")

    wm.Items = {}
    local itemData = {
        Player = { Icon = "https://i.postimg.cc/xd9xJV1L/player-ne-fill.png", Text = "" },
        Config = { Icon = "https://i.postimg.cc/3Rsbw44x/dsawdsaaaaaaaaa.png", Text = "" },
        Ping = { Icon = "https://i.postimg.cc/43tcgYg5/ping-logogl.png", Text = "0 ms" },
        Fps = { Icon = "https://i.postimg.cc/4dPmftFz/fepese.png", Text = "0 fps" }
    }

    for name, data in pairs(itemData) do
        local item = {
            Icon = self:_CreateDrawingObject("Image"),
            Text = self:_CreateDrawingObject("Text")
        }
        if item.Icon then 
            item.Icon.Url = data.Icon; item.Icon.Size = {22, 22}; item.Icon.zIndex = z + 4;
        end
        if item.Text then 
            item.Text.Font = self.ActiveTheme.Fonts.Main; item.Text.Size = self.ActiveTheme.Fonts.Size + 5; 
            item.Text.Text = data.Text; item.Text.zIndex = z + 4;
        end
        wm.Items[name] = item
    end

    if wm.DragArea then wm.DragArea.Filled = true; wm.DragArea.Opacity = 0; wm.DragArea.zIndex = z + 5; end
    if wm.LogoBg then wm.LogoBg.Filled = true; wm.LogoBg.zIndex = z; wm.LogoBg.Rounding = wm.Rounding; end
    if wm.InfoBg then wm.InfoBg.Filled = true; wm.InfoBg.zIndex = z; wm.InfoBg.Rounding = wm.Rounding; end

    local function setupLogoText(textObj, zIndex)
        if textObj then
            textObj.Font = self.ActiveTheme.Fonts.Title; textObj.Size = self.ActiveTheme.Fonts.Size + 8;
            textObj.Text = "NL"; textObj.Center = true; textObj.zIndex = zIndex;
        end
    end
    setupLogoText(wm.LogoText3, z + 1)
    setupLogoText(wm.LogoText2, z + 2) 
    setupLogoText(wm.LogoText1, z + 3) 
end

function Library:_InitializeHotkeys()
    local hk = { Animation = { IsOpening = false, IsClosing = false, CurrentOpacity = 0 } }; 
    self.UI.Hotkeys = hk; 
    local z = 110

    hk.Position = {x = 20, y = 80} 
    hk.ActiveBinds = {}
    
    -- [[ ДОБАВЬ ЭТИ ДВЕ СТРОКИ ]]
    hk.IsDragging = false
    hk.DragOffset = {x = 0, y = 0}

    hk.Title = {
        Background = self:_CreateDrawingObject("Square"),
        Icon = self:_CreateDrawingObject("Image"),
        Separator = self:_CreateDrawingObject("Line"),
        Text = self:_CreateDrawingObject("Text")
    }
    
    if hk.Title.Background then hk.Title.Background.Filled = true; hk.Title.Background.zIndex = z; hk.Title.Background.Rounding = 13; end
    if hk.Title.Icon then hk.Title.Icon.Url = "https://i.postimg.cc/0jSdXVN8/image.png"; hk.Title.Icon.Size = {26, 24}; hk.Title.Icon.zIndex = z + 1; end
    if hk.Title.Separator then hk.Title.Separator.Thickness = 2.5; hk.Title.Separator.zIndex = z + 1; end
    if hk.Title.Text then hk.Title.Text.Font = self.ActiveTheme.Fonts.Main; hk.Title.Text.Size = self.ActiveTheme.Fonts.Size + 9; hk.Title.Text.Text = " Hotkeys"; hk.Title.Text.zIndex = z + 1; end
end

--================================================================
--[[ PRIVATE: CONFIG SYSTEM ]]
--================================================================

function Library:_GetConfigPath(name)
    return self.ConfigFolderPath .. "\\" .. name .. ".cfg"
end

function Library:_SaveConfig(name)
    local configData = {
        Values = {},
        Themes = {},
        ActiveThemeName = self.ActiveTheme.Name
    }

    for id, value in pairs(self.UI.Values) do
        if not string.find(id, "About") and id ~= "ConfigIncludeStyle" then
            configData.Values[id] = value
        end
    end

    if self.UI.Values["ConfigIncludeStyle"] then
        print(SCRIPT_PREFIX .. "Saving custom themes...") -- Строка для отладки
        for themeName, themeData in pairs(self.Themes) do
            if not themeData.IsPreset then
                -- [ДОБАВЛЕНО] Печатаем в консоль каждую найденную кастомную тему
                print(SCRIPT_PREFIX .. "Found custom theme to save: " .. themeName)
                
                local sanitizedTheme = {
                    Colors = self:_DeepCopy(themeData.Colors),
                    Rounding = self:_DeepCopy(themeData.Rounding),
                    Transparency = self:_DeepCopy(themeData.Transparency),
                    IconSize = themeData.IconSize
                }
                configData.Themes[themeName] = sanitizedTheme
            end
        end
    end

    local success, encodedData = pcall(JSONEncode, configData)
    if success then
        writefile(self:_GetConfigPath(name), encodedData)
        print(SCRIPT_PREFIX .. "Config '" .. name .. "' saved successfully.")
        self.UI.Core.ConfigsTab.NeedsRefresh = true
    else
        warn(SCRIPT_PREFIX .. "Failed to encode config data for '" .. name .. "'.")
    end
end

function Library:_LoadConfig(name)
    local filePath = self:_GetConfigPath(name)
    if not checkfile(filePath) then warn(SCRIPT_PREFIX .. "Config file not found: " .. name); return end
    local success, fileContent = pcall(readfile, filePath)
    if not success or not fileContent then warn(SCRIPT_PREFIX .. "Failed to read config file: " .. name); return end
    local success, decodedData = pcall(JSONDecode, fileContent)
    if not success or not decodedData then warn(SCRIPT_PREFIX .. "Failed to decode config JSON: " .. name); return end

    do
        local themesToRemove = {}
        for themeName, themeData in pairs(self.Themes) do
            if not themeData.IsPreset then
                table.insert(themesToRemove, themeName)
            end
        end
        for _, themeNameToRemove in ipairs(themesToRemove) do
            self.Themes[themeNameToRemove] = nil
        end
    end

    if decodedData.Themes then
        for themeName, savedThemeData in pairs(decodedData.Themes) do
            local baseTheme = self.Themes.Blue
            local fullTheme = self:_EnsureDefaults(savedThemeData, baseTheme)

            fullTheme.Name = themeName
            fullTheme.IsPreset = false
            fullTheme.Fonts = self:_DeepCopy(baseTheme.Fonts)

            if fullTheme.Transparency and fullTheme.Transparency.ActiveTabHighlight == 0 then
                fullTheme.Transparency.ActiveTabHighlight = baseTheme.Transparency.ActiveTabHighlight
            end

            self.Themes[themeName] = fullTheme
        end
    end
    self:_RebuildStyleCircles()

    if decodedData.Values then
        for id, value in pairs(decodedData.Values) do
            if self.UI.Values[id] ~= nil then
                self.UI.Values[id] = value
                for _, section in ipairs(self.UI.Sections) do
                    for _, element in ipairs(section.Elements) do
                        if element.id == id and element.Callback then
                            pcall(element.Callback, value)
                            break
                        end
                    end
                end
            end
        end
    end

    if decodedData.ActiveThemeName and self.Themes[decodedData.ActiveThemeName] then
        self.ActiveTheme = self.Themes[decodedData.ActiveThemeName]
        self.UI.Values.AboutSelectedStyle = decodedData.ActiveThemeName
    else
        self.ActiveTheme = self.Themes.Blue
        self.UI.Values.AboutSelectedStyle = "Blue"
    end

    self.UI.Core.ConfigsTab.LoadedConfigName = name
    print(SCRIPT_PREFIX .. "Config '" .. name .. "' loaded successfully.")

end


function Library:_InitializeConfigsTab()
    local configs = {}; self.UI.Core.ConfigsTab = configs; local z = 4

    configs.LoadedConfigName = ""
    configs.Items = {}
    configs.NeedsRefresh = false

    configs.MyItemsLabel = self:_CreateDrawingObject("Text")
    if configs.MyItemsLabel then
        configs.MyItemsLabel.Font = self.ActiveTheme.Fonts.Main; configs.MyItemsLabel.Size = self.ActiveTheme.Fonts.Size + 2; configs.MyItemsLabel.Text = "- My items"; configs.MyItemsLabel.Center = false; configs.MyItemsLabel.zIndex = z;
    end

    -- [[ ИЗМЕНЕНИЕ: Дополняем объект скроллбара новыми полями состояния ]]
    configs.Scrollbar = {
        Background = self:_CreateDrawingObject("Square"),
        Nub = self:_CreateDrawingObject("Square"),
        -- Новые поля для управления логикой
        IsDraggingNub = false,      -- Флаг, показывающий, тащим ли мы ползунок
        ScrollOffset = 0,           -- Текущее смещение контента в пикселях
        DragStartMouseY = 0,        -- Позиция Y мыши в начале перетаскивания
        DragStartOffset = 0,        -- Смещение контента в начале перетаскивания
        NubClickRegion = {}         -- Область нажатия для самого ползунка
    }
    -- [[ КОНЕЦ ИЗМЕНЕНИЙ ]]

    if configs.Scrollbar.Background then configs.Scrollbar.Background.Filled = true; configs.Scrollbar.Background.zIndex = z + 2; configs.Scrollbar.Background.Rounding = 2; end
    if configs.Scrollbar.Nub then configs.Scrollbar.Nub.Filled = true; configs.Scrollbar.Nub.zIndex = z + 3; configs.Scrollbar.Nub.Rounding = 2; end

    -- [[ НАЧАЛО ИЗМЕНЕНИЙ ]]
    configs.OptionsPopup = {
        IsOpen = false, ItemIndex = nil, Pos = {x=0, y=0}, ClickRegion = {},
        -- Добавляем таблицу для анимации
        Animation = { IsOpening = false, IsClosing = false, CurrentOpacity = 0 },

        Background = self:_CreateDrawingObject("Square"),
        Border = self:_CreateDrawingObject("Square"),
        Glow = self:_Internal_CreateGlowSet(z + 10),
        IncludeStyleToggle = self:_Internal_CreateToggle({ id = "ConfigIncludeStyle", Name = "Include Style", Default = true, zIndex = z + 12 }),

        -- Добавляем новые элементы
        Separator = self:_CreateDrawingObject("Line"),
        DeleteButton = {
            Background = self:_CreateDrawingObject("Square"),
            Border = self:_CreateDrawingObject("Square"),
            Icon = self:_CreateDrawingObject("Image"),
            Label = self:_CreateDrawingObject("Text"),
            ClickRegion = {},
            IsHovered = false
        }
    }
    -- [[ КОНЕЦ ИЗМЕНЕНИЙ ]]

    local popup = configs.OptionsPopup
    if popup.Background then popup.Background.Filled = true; popup.Background.zIndex = z + 11; popup.Background.Rounding = self.ActiveTheme.Rounding.Section; end
    if popup.Border then popup.Border.Filled = false; popup.Border.Thickness = 1; popup.Border.zIndex = z + 12; popup.Border.Rounding = self.ActiveTheme.Rounding.Section; end
    
    -- [[ НОВОЕ: Настройка новых элементов ]]
    if popup.Separator then popup.Separator.Thickness = 2; popup.Separator.zIndex = z + 12; end
    
    local delBtn = popup.DeleteButton
    if delBtn.Background then delBtn.Background.Filled = true; delBtn.Background.zIndex = z + 12; delBtn.Background.Rounding = self.ActiveTheme.Rounding.Button; end
    if delBtn.Border then delBtn.Border.Filled = false; delBtn.Border.Thickness = 1; delBtn.Border.zIndex = z + 13; delBtn.Border.Rounding = self.ActiveTheme.Rounding.Button; end
    if delBtn.Icon then delBtn.Icon.Size = {18, 18}; delBtn.Icon.zIndex = z + 13; delBtn.Icon.Url = "https://i.postimg.cc/Bb6VL5RD/udalitkonfig.png"; end
    if delBtn.Label then delBtn.Label.Font = self.ActiveTheme.Fonts.Main; delBtn.Label.Size = self.ActiveTheme.Fonts.Size + 1; delBtn.Label.Text = " Delete config"; delBtn.Label.Center = false; delBtn.Label.zIndex = z + 13; end
end


-- Вставьте эту новую функцию в раздел PRIVATE: CONFIG SYSTEM
function Library:_CreateNewConfig()
    local baseName = "New config"
    local newName = baseName
    local i = 1
    
    while checkfile(self:_GetConfigPath(newName)) do
        newName = baseName .. " (" .. i .. ")"
        i = i + 1
    end
    
    print(SCRIPT_PREFIX .. "Creating new config: " .. newName)
    self:_SaveConfig(newName)
end

function Library:_RefreshConfigList()
    local configs = self.UI.Core.ConfigsTab
    
    for _, item in ipairs(configs.Items) do
        self:_CleanupDrawingObjects(item.Drawing)
    end
    configs.Items = {}

    local files = listfiles(self.ConfigFolderPath)
    if not files then return end

    local localPlayerName = "user"
    local p = game:FindService("Players")
    if p and p.localPlayer then
        localPlayerName = p.localPlayer.Name
    end

    for _, fileName in ipairs(files) do
        if string.sub(fileName, -4) == ".cfg" then
            local configName = string.sub(fileName, 1, -5)
            local item = {
                Name = configName,
                Modified = "N/A",
                Author = localPlayerName,
                -- [[ НОВОЕ: Добавляем LastVisibleY для хранения последней позиции ]]
                Animation = { CurrentOpacity = 0.0, LastVisibleY = 0 },
                Drawing = {
                    Background = self:_CreateDrawingObject("Square"),
                    Border = self:_CreateDrawingObject("Square"),
                    Name = self:_CreateDrawingObject("Text"),
                    Modified = self:_CreateDrawingObject("Text"),
                    Author = self:_CreateDrawingObject("Text"),
                    OptionsButton = {
                        Dot1 = self:_CreateDrawingObject("Circle"), Dot2 = self:_CreateDrawingObject("Circle"), Dot3 = self:_CreateDrawingObject("Circle"),
                        ClickRegion = {}
                    },
                    LoadButton = {
                        Background = self:_CreateDrawingObject("Square"),
                        Icon = self:_CreateDrawingObject("Image"),
                        Label = self:_CreateDrawingObject("Text"),
                        ClickRegion = {}
                    },
                    SaveButton = {
                        Background = self:_CreateDrawingObject("Square"), Border = self:_CreateDrawingObject("Square"),
                        Icon = self:_CreateDrawingObject("Image"), Label = self:_CreateDrawingObject("Text"),
                        ClickRegion = {}
                    }
                }
            }
            
            local d = item.Drawing; local z = 4
            if d.Background then d.Background.Filled = true; d.Background.zIndex = z; d.Background.Rounding = self.ActiveTheme.Rounding.Section; end
            if d.Border then d.Border.Filled = false; d.Border.Thickness = 1; d.Border.zIndex = z + 1; d.Border.Rounding = self.ActiveTheme.Rounding.Section; end
            if d.Name then d.Name.Font = self.ActiveTheme.Fonts.Main; d.Name.Size = self.ActiveTheme.Fonts.Size + 2; d.Name.Center = false; d.Name.zIndex = z + 1; end
            if d.Modified then d.Modified.Font = self.ActiveTheme.Fonts.Main; d.Modified.Size = self.ActiveTheme.Fonts.Size; d.Modified.Center = false; d.Modified.zIndex = z + 1; end
            if d.Author then d.Author.Font = self.ActiveTheme.Fonts.Main; d.Author.Size = self.ActiveTheme.Fonts.Size; d.Author.zIndex = z + 1; end
            if d.OptionsButton.Dot1 then d.OptionsButton.Dot1.Filled = true; d.OptionsButton.Dot1.Radius = 1.5; d.OptionsButton.Dot1.zIndex = z + 2; end
            if d.OptionsButton.Dot2 then d.OptionsButton.Dot2.Filled = true; d.OptionsButton.Dot2.Radius = 1.5; d.OptionsButton.Dot2.zIndex = z + 2; end
            if d.OptionsButton.Dot3 then d.OptionsButton.Dot3.Filled = true; d.OptionsButton.Dot3.Radius = 1.5; d.OptionsButton.Dot3.zIndex = z + 2; end
            if d.LoadButton.Background then d.LoadButton.Background.Filled = true; d.LoadButton.Background.zIndex = z + 2; d.LoadButton.Background.Rounding = self.ActiveTheme.Rounding.Button; end
            if d.LoadButton.Icon then d.LoadButton.Icon.Size = {14, 14}; d.LoadButton.Icon.zIndex = z + 3; d.LoadButton.Icon.Url = "https://i.postimg.cc/W3YTY7Hf/image.png"; end
            if d.LoadButton.Label then d.LoadButton.Label.Font = self.ActiveTheme.Fonts.Main; d.LoadButton.Label.Size = self.ActiveTheme.Fonts.Size; d.LoadButton.Label.Text = "Load"; d.LoadButton.Label.Center = false; d.LoadButton.Label.zIndex = z + 3; end
            if d.SaveButton.Background then d.SaveButton.Filled = true; d.SaveButton.zIndex = z + 2; d.SaveButton.Rounding = self.ActiveTheme.Rounding.Button; end
            if d.SaveButton.Border then d.SaveButton.Border.Filled = false; d.SaveButton.Border.Thickness = 1; d.SaveButton.Border.zIndex = z + 3; d.SaveButton.Border.Rounding = self.ActiveTheme.Rounding.Button; end
            if d.SaveButton.Icon then d.SaveButton.Icon.Size = {13.33, 13.33}; d.SaveButton.Icon.zIndex = z + 3; d.SaveButton.Icon.Url = "https://i.postimg.cc/0QgnsgKT/vaseinko.png"; end 
            if d.SaveButton.Label then d.SaveButton.Label.Font = self.ActiveTheme.Fonts.Main; d.SaveButton.Label.Size = self.ActiveTheme.Fonts.Size; d.SaveButton.Label.Text = "Save"; d.SaveButton.Label.Center = false; d.SaveButton.Label.zIndex = z + 3; end
            table.insert(configs.Items, item)
        end
    end
end

--================================================================
--[[ PRIVATE: THEME MANAGEMENT ]]
--================================================================

function Library:_revert_realtime_changes()
    if self.UI.Values.EditStyleRealTime and self.PreEditThemeName then
        self.ActiveTheme = self.Themes[self.PreEditThemeName] or self.Themes.Blue
        self.UI.Values.AboutSelectedStyle = self.ActiveTheme.Name
    end
    self.TempTheme = nil
    self.PreEditThemeName = nil
    self.UI.Values.EditStyleRealTime = false
end

--================================================================
--[[ PRIVATE: RENDERING & INPUT HANDLING ]]
--================================================================

function Library:_RenderBurgerMenuPopup(mouse_pos)
    local popup = self.UI.Popups.BurgerMenu
    local masterOpacity = popup.Animation.CurrentOpacity
    local theme = self.ActiveTheme

    if masterOpacity <= 0 then
        self:_SetVisibility(popup.Background, false)
        self:_SetVisibility(popup.Border, false)
        self:_HideGlowEffect(popup.Glow)
        for _, item in ipairs(popup.Items) do
            self:_SetVisibility(item.Icon, false)
            self:_SetVisibility(item.Label, false)
            self:_SetVisibility(item.Highlight, false)
            self:_SetVisibility(item.CheckmarkLine1, false)
            self:_SetVisibility(item.CheckmarkLine2, false)
        end
        return
    end
    
    local allVisible = masterOpacity > 0
    self:_SetVisibility(popup.Background, allVisible)
    self:_SetVisibility(popup.Border, allVisible)

    self:_AnimateAndApplyColor(popup.Background, theme.Colors.SectionBackground, masterOpacity)
    self:_AnimateAndApplyColor(popup.Border, theme.Colors.Separator, masterOpacity)

    local pW, itemHeight, padding = 180, 30, 10
    local pH = (#popup.Items * itemHeight) + (padding * 2)
    local pX = (popup.Pos and popup.Pos.x) or 0
    local pY = (popup.Pos and popup.Pos.y) or 0

    popup.ClickRegion = {x1=pX, y1=pY, x2=pX+pW, y2=pY+pH}
    popup.Background.Position = {pX, pY}; popup.Background.Size = {pW, pH}
    popup.Border.Position = {pX, pY}; popup.Border.Size = {pW, pH}
    self:_RenderGlowEffect(popup.Glow, pX, pY, pW, pH, popup.Background.Rounding, theme.Colors.GlowColor, nil, masterOpacity)
    
    local hasSelection = false
    for _, item in ipairs(popup.Items) do if self.UI.Values[item.id] then hasSelection = true; break end end
    
    local currentY = pY + padding
    for i, item in ipairs(popup.Items) do
        self:_SetVisibility(item.Label, allVisible)
        self:_SetVisibility(item.Highlight, allVisible)
        self:_SetVisibility(item.Icon, allVisible)

        item.ClickRegion = {x1=pX, y1=currentY, x2=pX+pW, y2=currentY+itemHeight-1}
        local isHovered = (popup.HoveredItemIndex == i)
        
        if isHovered then
            item.Highlight.Opacity = 0.4 * masterOpacity
            self:_AnimateAndApplyColor(item.Highlight, theme.Colors.Separator, masterOpacity)
        else
            item.Highlight.Opacity = 0
        end
        item.Highlight.Position = {pX + 5, currentY + 2}; item.Highlight.Size = {pW - 10, itemHeight - 4}

        local isSelected = self.UI.Values[item.id]
        local targetTextColor = isSelected and theme.Colors.Accent or theme.Colors.TextPrimary
        local targetIconColor = isSelected and theme.Colors.Accent or theme.Colors.TextSecondary

        self:_AnimateAndApplyColor(item.Icon, targetIconColor, masterOpacity)
        self:_AnimateAndApplyColor(item.Label, targetTextColor, masterOpacity)
        
        self:_SetVisibility(item.CheckmarkLine1, isSelected and allVisible)
        self:_SetVisibility(item.CheckmarkLine2, isSelected and allVisible)
        
        local startX = pX + (hasSelection and 30 or 15)
        
        if isSelected then
            local checkCenterY = currentY + (itemHeight / 2)
            item.CheckmarkLine1.From = {pX + 12, checkCenterY}; item.CheckmarkLine1.To = {pX + 15, checkCenterY + 3}
            item.CheckmarkLine2.From = {pX + 15, checkCenterY + 3}; item.CheckmarkLine2.To = {pX + 19, checkCenterY - 4}
            self:_AnimateAndApplyColor(item.CheckmarkLine1, theme.Colors.Accent, masterOpacity)
            self:_AnimateAndApplyColor(item.CheckmarkLine2, theme.Colors.Accent, masterOpacity)
        end
        
        item.Icon.Position = {startX, currentY + (itemHeight / 2) - (item.Icon.Size.y / 2)}
        local labelX = startX + item.Icon.Size.x + 8
        item.Label.Position = {labelX, currentY + (itemHeight / 2) - (item.Label.Size / 2)}
        
        currentY = currentY + itemHeight
    end
end

function Library:_RenderAboutWindow(mouse_pos)
    local about = self.UI.Core.AboutWindow
    
    local function setAboutVisibility(tbl, visible)
        for key, obj in pairs(tbl) do
            if type(obj) == 'table' then
                if obj.Visible ~= nil then self:_SetVisibility(obj, visible)
                elseif obj.Label and (obj.Back or obj.Button or (obj.LeftFill and obj.Nub) or obj.Border) then
                    self:_SetVisibility(obj.Label, visible);
                    if obj.Back then self:_SetVisibility(obj.Back, visible); self:_SetVisibility(obj.Nub, visible); end
                    if obj.LeftFill then 
                        self:_SetVisibility(obj.LeftFill, visible); self:_SetVisibility(obj.Nub, visible); 
                        -- Добавляем новые элементы слайдера
                        if obj.ValueInputBg then self:_SetVisibility(obj.ValueInputBg, visible) end
                        if obj.ValueInputBorder then self:_SetVisibility(obj.ValueInputBorder, visible) end
                        if obj.ValueText then self:_SetVisibility(obj.ValueText, visible) end
                    end
                    if obj.Button then self:_SetVisibility(obj.Button, visible); self:_SetVisibility(obj.ButtonText, visible); end
                    if obj.ArrowLine1 then self:_SetVisibility(obj.ArrowLine1, visible); self:_SetVisibility(obj.ArrowLine2, visible); end
                    if obj.Border then self:_SetVisibility(obj.Border, visible) end
                elseif key ~= "ClickRegion" and key ~= "StyleCircles" and key ~= "Glow" and key ~= "Tooltip" and key ~= "HoveredThemeCircle" and key ~= "Animation" then
                     setAboutVisibility(obj, visible)
                end
            end
        end
    end

    local masterOpacity = about.Animation.CurrentOpacity
    local theme = self.ActiveTheme
    local isThemeLight = self:_IsThemeLight(theme)
    
    if masterOpacity <= 0 then
        self:_HideGlowEffect(about.Glow)
        if about.AnimationSpeedSlider and about.AnimationSpeedSlider.Glow then self:_HideGlowEffect(about.AnimationSpeedSlider.Glow) end
        setAboutVisibility(about, false)
        self:_SetVisibility(about.Tooltip.Background, false)
        self:_SetVisibility(about.Tooltip.Text, false)
        for _, circle in ipairs(about.StyleCircles) do
            self:_SetVisibility(circle.Circle, false); self:_SetVisibility(circle.Border, false);
            if circle.Inner then self:_SetVisibility(circle.Inner, false) end
            if circle.PlusLine1 then self:_SetVisibility(circle.PlusLine1, false); self:_SetVisibility(circle.PlusLine2, false) end
        end
        return
    end

    setAboutVisibility(about, true)
    
    self:_AnimateAndApplyColor(about.Background, theme.Colors.SectionBackground, masterOpacity)
    self:_AnimateAndApplyColor(about.Border, theme.Colors.Separator, masterOpacity)
    self:_AnimateAndApplyColor(about.HeaderIcon, theme.Colors.TextSecondary, masterOpacity)
    self:_AnimateAndApplyColor(about.HeaderTitle, theme.Colors.TextPrimary, masterOpacity)
    self:_AnimateAndApplyColor(about.CloseButton.Line1, theme.Colors.TextSecondary, masterOpacity)
    self:_AnimateAndApplyColor(about.CloseButton.Line2, theme.Colors.TextSecondary, masterOpacity)
    self:_AnimateAndApplyColor(about.Separator1, theme.Colors.Separator, masterOpacity)
    self:_AnimateAndApplyColor(about.MainTitle, theme.Colors.TextPrimary, masterOpacity)
    self:_AnimateAndApplyColor(about.Separator2, theme.Colors.Separator, masterOpacity)
    self:_AnimateAndApplyColor(about.InfoVersionLabel, theme.Colors.TextSecondary, masterOpacity); self:_AnimateAndApplyColor(about.InfoVersionValue, theme.Colors.Accent, masterOpacity)
    self:_AnimateAndApplyColor(about.InfoBuildDateLabel, theme.Colors.TextSecondary, masterOpacity); self:_AnimateAndApplyColor(about.InfoBuildDateValue, theme.Colors.Accent, masterOpacity)
    self:_AnimateAndApplyColor(about.InfoBuildTypeLabel, theme.Colors.TextSecondary, masterOpacity); self:_AnimateAndApplyColor(about.InfoBuildTypeValue, theme.Colors.Accent, masterOpacity)
    self:_AnimateAndApplyColor(about.InfoRegisteredToLabel, theme.Colors.TextSecondary, masterOpacity); self:_AnimateAndApplyColor(about.InfoRegisteredToValue, theme.Colors.Accent, masterOpacity)
    self:_AnimateAndApplyColor(about.InfoSubscriptionLabel, theme.Colors.TextSecondary, masterOpacity); self:_AnimateAndApplyColor(about.InfoSubscriptionValue, theme.Colors.Accent, masterOpacity)
    self:_AnimateAndApplyColor(about.FooterText, theme.Colors.TextSecondary, masterOpacity)
    self:_AnimateAndApplyColor(about.Separator3, theme.Colors.Separator, masterOpacity)
    self:_AnimateAndApplyColor(about.CreditText, theme.Colors.TextSecondary, masterOpacity)
    self:_AnimateAndApplyColor(about.StyleLabel, theme.Colors.TextSecondary, masterOpacity)
    
    for _, circle in ipairs(about.StyleCircles) do
        self:_SetVisibility(circle.Circle, true); self:_SetVisibility(circle.Border, self.UI.Values.AboutSelectedStyle == circle.Name)
        if circle.Inner then self:_SetVisibility(circle.Inner, true) end
        if circle.PlusLine1 then self:_SetVisibility(circle.PlusLine1, true); self:_SetVisibility(circle.PlusLine2, true) end
        self:_AnimateAndApplyColor(circle.Border, theme.Colors.Accent, masterOpacity)
        if circle.PlusLine1 then self:_AnimateAndApplyColor(circle.PlusLine1, theme.Colors.TextSecondary, masterOpacity) end
        if circle.PlusLine2 then self:_AnimateAndApplyColor(circle.PlusLine2, theme.Colors.TextSecondary, masterOpacity) end
    end
    self:_AnimateAndApplyColor(about.AutoSaveToggle.Label, theme.Colors.TextSecondary, masterOpacity)
    
    local slider = about.AnimationSpeedSlider; 
    self:_AnimateAndApplyColor(slider.Label, theme.Colors.TextSecondary, masterOpacity); 
    self:_AnimateAndApplyColor(slider.Back, theme.Colors.DarkBlue, masterOpacity);
    self:_AnimateAndApplyColor(slider.LeftFill, theme.Colors.Accent, masterOpacity); 
    self:_AnimateAndApplyColor(slider.Nub, theme.Colors.Accent, masterOpacity); 
    
    local winW, winH = 360, 500
    local winX, winY = self.Window.X + (self.Window.Width / 2) - (winW / 2), self.Window.Y + (self.Window.Height / 2) - (winH / 2)
    about.ClickRegion = {x1 = winX, y1 = winY, x2 = winX + winW, y2 = winY + winH}
    about.Background.Position = {winX, winY}; about.Background.Size = {winW, winH}
    about.Border.Position = {winX, winY}; about.Border.Size = {winW, winH}
    if about.Glow then self:_RenderGlowEffect(about.Glow, winX, winY, winW, winH, about.Background.Rounding, theme.Colors.GlowColor, nil, masterOpacity) end
    about.HeaderIcon.Position = {winX + 15, winY + 12}
    about.HeaderTitle.Position = {winX + 15 + about.HeaderIcon.Size.x + 8, winY + 13}
    about.CloseButton.Line1.From = {winX + winW - 25, winY + 12}; about.CloseButton.Line1.To = {winX + winW - 15, winY + 22}
    about.CloseButton.Line2.From = {winX + winW - 25, winY + 22}; about.CloseButton.Line2.To = {winX + winW - 15, winY + 12}
    about.CloseButton.ClickRegion = {x1 = winX + winW - 30, y1 = winY + 10, x2 = winX + winW - 10, y2 = winY + 25}
    local currentY = winY + 40
    about.Separator1.From = {winX + 10, currentY}; about.Separator1.To = {winX + winW - 10, currentY}
    currentY = currentY + 25
    about.MainTitle.Position = {winX + winW / 2, currentY}
    currentY = currentY + 40
    about.Separator2.From = {winX + 10, currentY}; about.Separator2.To = {winX + winW - 10, currentY}
    currentY = currentY + 20
    local infoX = winX + 30
    local function renderInfoLine(y, label, value) if label and value then label.Position = {infoX, y}; if label.TextBounds then value.Position = {infoX + label.TextBounds.x + 5, y} end; return y + 25; end; return y; end
    currentY = renderInfoLine(currentY, about.InfoVersionLabel, about.InfoVersionValue)
    currentY = renderInfoLine(currentY, about.InfoBuildDateLabel, about.InfoBuildDateValue)
    currentY = renderInfoLine(currentY, about.InfoBuildTypeLabel, about.InfoBuildTypeValue)
    currentY = renderInfoLine(currentY, about.InfoRegisteredToLabel, about.InfoRegisteredToValue)
    currentY = renderInfoLine(currentY, about.InfoSubscriptionLabel, about.InfoSubscriptionValue)
    about.FooterText.Position = {winX + winW / 2, currentY}
    currentY = currentY + 50; about.Separator3.From = {winX + 10, currentY}; about.Separator3.To = {winX + winW - 10, currentY}; currentY = currentY + 15
    local controlX = winX + 20; local controlW = winW - 40; local controlSpacing = 35
    local rightEdge = winX + winW - 25
    
    local toggle = about.AutoSaveToggle
    local toggleY = currentY - 1
    toggle.Label.Position = {controlX, currentY}; 
    local toggleBackX = rightEdge - toggle.Size.width; 
    toggle.Back.Position = {toggleBackX, toggleY}; 
    toggle.Back.Size = {toggle.Size.width, toggle.Size.height}; 
    toggle.ClickRegion = {x1 = toggleBackX, y1 = toggleY, x2 = toggleBackX + toggle.Size.width, y2 = toggleY + toggle.Size.height}; 
    local is_on = self.UI.Values[toggle.id]
    local nubY = toggleY + toggle.Size.height / 2
    local targetBackColor, targetNubColor; 
    if is_on then
        if isThemeLight then
            targetBackColor = theme.Colors.Accent
            targetNubColor = theme.Colors.SectionBackground
        else
            targetBackColor = self:_DarkenColor(theme.Colors.Accent, 0.3)
            targetNubColor = theme.Colors.Accent
        end
    else 
        targetBackColor = theme.Colors.DarkGray
        targetNubColor = theme.Colors.LightGray
    end
    
    local speed_value = self.UI.Values["AboutAnimationSpeed"] or 2.5
    local animationSpeed = speed_value / 25.0 -- lf 10
    local targetOffset = is_on and (toggle.Size.width - toggle.Size.height / 2) or (toggle.Size.height / 2)
    toggle.AnimatedNubOffset = toggle.AnimatedNubOffset + (targetOffset - toggle.AnimatedNubOffset) * animationSpeed
    toggle.Nub.Position = {toggleBackX + toggle.AnimatedNubOffset, nubY}

    self:_AnimateAndApplyColor(toggle.Back, targetBackColor, masterOpacity); 
    self:_AnimateAndApplyColor(toggle.Nub, targetNubColor, masterOpacity);
    
    currentY = currentY + controlSpacing
    
    local keybind = about.ToggleUIKeybind
    local keybindY = currentY - 4
    self:_AnimateAndApplyColor(keybind.Label, theme.Colors.TextSecondary, masterOpacity)
    keybind.Label.Position = {controlX, keybindY + 5}
    local bindButtonX = rightEdge - keybind.Size.width
    local buttonBackgroundColor = keybind.IsListening and theme.Colors.Accent or theme.Colors.DarkBlue
    local buttonTextColor = keybind.IsListening and self:_GetTextColorForBackground(buttonBackgroundColor) or theme.Colors.TextPrimary
    local buttonBorderColor = keybind.IsListening and theme.Colors.Accent or theme.Colors.Separator
    self:_AnimateAndApplyColor(keybind.Button, buttonBackgroundColor, masterOpacity)
    self:_AnimateAndApplyColor(keybind.Border, buttonBorderColor, masterOpacity)
    self:_AnimateAndApplyColor(keybind.ButtonText, buttonTextColor, masterOpacity)
    keybind.Button.Position = {bindButtonX, keybindY}; keybind.Button.Size = {keybind.Size.width, keybind.Size.height}
    keybind.Border.Position = {bindButtonX, keybindY}; keybind.Border.Size = {keybind.Size.width, keybind.Size.height}
    keybind.ButtonText.Text = keybind.IsListening and "..." or string.upper(self.UI.Values[keybind.id] or "none")
    keybind.ButtonText.Position = { bindButtonX + (keybind.Size.width / 2), keybindY + (keybind.Size.height / 2) - (keybind.ButtonText.Size / 2) }
    keybind.ClickRegion = {x1 = bindButtonX, y1 = keybindY, x2 = bindButtonX + keybind.Size.width, y2 = keybindY + keybind.Size.height}

    currentY = currentY + controlSpacing

    -- [[ НАЧАЛО БЛОКА ИЗМЕНЕНИЙ: Обновленный рендеринг слайдера ]]
    self:_SetVisibility(slider.ValueInputCursor, slider.IsEditing and math.sin(tick() * 5) > 0)
    slider.Label.Position = {controlX, currentY}

    local valueBoxW, valueBoxH = 45, 22
    local valueBoxX = rightEdge - valueBoxW
    slider.ValueInputBg.Position = {valueBoxX, currentY - 4}; slider.ValueInputBg.Size = {valueBoxW, valueBoxH}
    slider.ValueInputBorder.Position = {valueBoxX, currentY - 4}; slider.ValueInputBorder.Size = {valueBoxW, valueBoxH}
    slider.ValueInputClickRegion = {x1 = valueBoxX, y1 = currentY - 4, x2 = valueBoxX + valueBoxW, y2 = currentY - 4 + valueBoxH}
    
    local sliderBackX = controlX + 140
    local sliderBackWidth = (valueBoxX - 10) - sliderBackX
    slider.Back.Position = {sliderBackX, currentY + 8}; slider.Back.Size = {sliderBackWidth, 2}; slider.ClickRegion = { x1 = sliderBackX, y1 = currentY - 2, x2 = sliderBackX + sliderBackWidth, y2 = currentY + 18 };
    
    local speed_value_slider = self.UI.Values["AboutAnimationSpeed"] or 2.5
    local anim_speed_slider = speed_value_slider / 15.0
    slider.AnimatedValue = slider.AnimatedValue + (self.UI.Values[slider.id] - slider.AnimatedValue) * anim_speed_slider

    local value_percentage = math.clamp((slider.AnimatedValue - slider.Min) / (slider.Max - slider.Min), 0, 1)
    local nubX = sliderBackX + sliderBackWidth * value_percentage
    slider.LeftFill.Position = {sliderBackX, currentY + 8}; slider.LeftFill.Size = {nubX - sliderBackX, 2}; slider.Nub.Position = {nubX, currentY + 9}

    local borderColor = slider.IsEditing and theme.Colors.Accent or theme.Colors.Separator
    self:_AnimateAndApplyColor(slider.ValueInputBg, theme.Colors.DarkBlue, masterOpacity)
    self:_AnimateAndApplyColor(slider.ValueInputBorder, borderColor, masterOpacity)
    self:_AnimateAndApplyColor(slider.ValueInputCursor, theme.Colors.Accent, masterOpacity)

    slider.ValueText.Text = slider.IsEditing and slider.InputText or string.format("%.1f", self.UI.Values[slider.id])
    slider.ValueText.Position = {valueBoxX + valueBoxW / 2, currentY - 4 + (valueBoxH / 2) - (slider.ValueText.Size / 2)}
    self:_AnimateAndApplyColor(slider.ValueText, theme.Colors.TextPrimary, masterOpacity)

    if slider.ValueText.TextBounds and slider.IsEditing then
        local cursorX = slider.ValueText.Position.x + slider.ValueText.TextBounds.x / 2 + 1
        local cursorY = slider.ValueText.Position.y - 2
        slider.ValueInputCursor.From = {cursorX, cursorY}
        slider.ValueInputCursor.To = {cursorX, cursorY + slider.ValueText.Size + 4}
    end

    local glowWidth = nubX - sliderBackX; local glowHeight = 6
    if glowWidth > 0 and slider.Glow then
        self:_RenderGlowEffect(slider.Glow, sliderBackX, currentY + 9 - (glowHeight / 2), glowWidth, glowHeight, slider.LeftFill.Rounding, theme.Colors.GlowAccent, nil, masterOpacity) 
    elseif slider.Glow then 
        self:_HideGlowEffect(slider.Glow) 
    end
    -- [[ КОНЕЦ БЛОКА ИЗМЕНЕНИЙ ]]

    currentY = currentY + controlSpacing
    
    local styleY = currentY + 4
    about.StyleLabel.Position = {controlX, styleY}; 
    local maxPerRow = 8; local circleSpacing = 30; local circleStartX = rightEdge
    for i, circle in ipairs(about.StyleCircles) do
        local slotIndex = i - 1; local col = slotIndex % maxPerRow; local row = math.floor(slotIndex / maxPerRow)
        local circleX = circleStartX - (col * circleSpacing); local circleY = styleY + 5 + (row * circleSpacing)
        circle.Circle.Position = {circleX, circleY}; circle.Border.Position = {circleX, circleY}
        if circle.Inner then circle.Inner.Position = {circleX, circleY} end
        if circle.PlusLine1 then circle.PlusLine1.From = {circleX - 4, circleY}; circle.PlusLine1.To = {circleX + 4, circleY}; circle.PlusLine2.From = {circleX, circleY - 4}; circle.PlusLine2.To = {circleX, circleY + 4}; end
        
        if not circle.IsAddButton and self.Themes[circle.Name] then
            local themeForCircle = self.Themes[circle.Name]
            self:_AnimateAndApplyColor(circle.Circle, themeForCircle.Colors.MainBackground, masterOpacity)
            if circle.Inner then
                self:_AnimateAndApplyColor(circle.Inner, themeForCircle.Colors.Accent, masterOpacity)
            end
        else
            self:_AnimateAndApplyColor(circle.Circle, {40, 40, 40, 255}, masterOpacity)
        end

        circle.ClickRegion = {x1 = circleX - 10, y1 = circleY - 5, x2 = circleX + 10, y2 = circleY + 15}
    end

    self:_SetVisibility(about.Tooltip.Background, false)
    self:_SetVisibility(about.Tooltip.Text, false)
    if about.HoveredThemeCircle.Name and (tick() - about.HoveredThemeCircle.HoverStartTime > 1) then
        local tooltip = about.Tooltip; local text = about.HoveredThemeCircle.Name; tooltip.Text.Text = text
        if tooltip.Text.TextBounds then
            local ttW = tooltip.Text.TextBounds.x + 16; local ttH = tooltip.Text.TextBounds.y + 10; local ttX = mouse_pos.x + 15; local ttY = mouse_pos.y
            tooltip.Background.Position = {ttX, ttY}; tooltip.Background.Size = {ttW, ttH}; tooltip.Text.Position = {ttX + 8, ttY + 5}
            self:_SetVisibility(tooltip.Background, true); self:_SetVisibility(tooltip.Text, true)
            self:_AnimateAndApplyColor(about.Tooltip.Background, theme.Colors.MainBackground, masterOpacity)
            self:_AnimateAndApplyColor(about.Tooltip.Text, theme.Colors.TextPrimary, masterOpacity)
        end
    end
    about.CreditText.Position = {winX + winW / 2, winY + winH - 25}
end

function Library:_RenderSettingsPopup()
    local popup = self.UI.Popups.Settings
    local theme = self.ActiveTheme
    local masterOpacity = popup.Animation.CurrentOpacity
    local z = 20

    -- [[ ГЛАВНЫЙ ФИКС: Логика полного скрытия, как в других попапах ]]
    if masterOpacity <= 0 then
        -- Прячем основные элементы самого попапа
        self:_SetVisibility(popup.Background, false)
        self:_SetVisibility(popup.Border, false)
        self:_SetVisibility(popup.Title, false)
        self:_SetVisibility(popup.Separator, false)
        self:_HideGlowEffect(popup.Glow)
        
        -- Прячем вложенные элементы (кейбинды), если они ещё не спрятаны
        self:_HideSettingsPopupElements(popup) 
        
        -- Сбрасываем состояние только после того, как всё гарантированно скрыто
        if popup.IsOpen then popup.IsOpen = false end
        if popup.ActiveToggle then popup.ActiveToggle = nil end
        
        return -- Прекращаем отрисовку
    end

    -- Если попап видим, делаем видимыми его базовые элементы
    self:_SetVisibility(popup.Background, true); self:_SetVisibility(popup.Border, true); self:_SetVisibility(popup.Title, true); self:_SetVisibility(popup.Separator, true);

    self:_AnimateAndApplyColor(popup.Background, theme.Colors.SectionBackground, masterOpacity)
    self:_AnimateAndApplyColor(popup.Border, theme.Colors.Separator, masterOpacity)
    self:_AnimateAndApplyColor(popup.Separator, theme.Colors.Separator, masterOpacity)

    popup.Title.Text = popup.ActiveToggle.Name .. " Settings"
    self:_AnimateAndApplyColor(popup.Title, theme.Colors.TextPrimary, masterOpacity)
    -- [[ ФИКС #2: Устанавливаем zIndex для заголовка, чтобы он был НАД фоном ]]
    popup.Title.zIndex = z + 2

    local pX, pY = popup.Pos.x, popup.Pos.y
    local pW = 250
    local currentY = pY + 8
    if popup.Title then popup.Title.Position = {pX + 10, currentY}; end
    currentY = currentY + popup.Title.Size + 8
    if popup.Separator then popup.Separator.From = {pX + 10, currentY}; popup.Separator.To = {pX + pW - 10, currentY}; end
    currentY = currentY + 15

    if popup.ActiveToggle and popup.ActiveToggle.SettingsElements then
        for _, element in ipairs(popup.ActiveToggle.SettingsElements) do
            if element.type == "Keybind" then
                local keybind = element
                self:_SetVisibility(keybind.Label, true); self:_SetVisibility(keybind.Button, true); self:_SetVisibility(keybind.Border, true); self:_SetVisibility(keybind.ButtonText, true)

                -- [[ ФИКС #2: Устанавливаем zIndex для всех элементов кейбинда ]]
                keybind.Label.zIndex = z + 2
                keybind.Button.zIndex = z + 2
                keybind.Border.zIndex = z + 3
                keybind.ButtonText.zIndex = z + 3

                local buttonBackgroundColor = keybind.IsListening and theme.Colors.Accent or theme.Colors.DarkBlue
                local buttonTextColor = keybind.IsListening and self:_GetTextColorForBackground(buttonBackgroundColor) or theme.Colors.TextPrimary
                local buttonBorderColor = keybind.IsListening and theme.Colors.Accent or theme.Colors.Separator

                self:_AnimateAndApplyColor(keybind.Label, theme.Colors.TextSecondary, masterOpacity)
                self:_AnimateAndApplyColor(keybind.Button, buttonBackgroundColor, masterOpacity)
                self:_AnimateAndApplyColor(keybind.Border, buttonBorderColor, masterOpacity)
                self:_AnimateAndApplyColor(keybind.ButtonText, buttonTextColor, masterOpacity)

                keybind.Label.Position = { pX + 15, currentY }
                local bindButtonX = pX + pW - keybind.Size.width - 15
                keybind.Button.Position = {bindButtonX, currentY - 5}; keybind.Button.Size = {keybind.Size.width, keybind.Size.height};
                keybind.Border.Position = {bindButtonX, currentY - 5}; keybind.Border.Size = {keybind.Size.width, keybind.Size.height};
                keybind.ButtonText.Text = keybind.IsListening and "..." or string.upper(self.UI.Values[keybind.id] or "none")
                keybind.ButtonText.Position = { bindButtonX + (keybind.Size.width / 2), currentY - 5 + (keybind.Size.height / 2) - (keybind.ButtonText.Size / 2) }
                keybind.ClickRegion = {x1 = bindButtonX, y1 = currentY - 5, x2 = bindButtonX + keybind.Size.width, y2 = currentY - 5 + keybind.Size.height}
                currentY = currentY + 35
            end
        end
    end

    local totalHeight = currentY - pY
    popup.ClickRegion = {x1 = pX, y1 = pY, x2 = pX + pW, y2 = pY + totalHeight}
    if popup.Background then popup.Background.Position = {pX, pY}; popup.Background.Size = {pW, totalHeight}; end
    if popup.Border then popup.Border.Position = {pX, pY}; popup.Border.Size = {pW, totalHeight}; end
    
    if popup.Glow then self:_RenderGlowEffect(popup.Glow, pX, pY, pW, totalHeight, popup.Background.Rounding, theme.Colors.GlowColor, nil, masterOpacity) end
end

function Library:_RenderEditStyleWindow()
    local style_window = self.UI.Popups.EditStyle
    local masterOpacity = style_window.Animation.CurrentOpacity
    local theme = self.ActiveTheme
    local isThemeLight = self:_IsThemeLight(theme)

    if masterOpacity <= 0 then
        self:_HideGlowEffect(style_window.Glow)
        self:_SetDrawingTableVisibility(style_window, false)
        return
    end

    local allVisible = masterOpacity > 0
    self:_SetDrawingTableVisibility(style_window, allVisible)
    self:_SetVisibility(style_window.StyleNameInputCursor, allVisible and style_window.IsEditingName and math.sin(tick() * 10) > 0)
    
    self:_AnimateAndApplyColor(style_window.Background, theme.Colors.SectionBackground, masterOpacity)
    self:_AnimateAndApplyColor(style_window.Border, theme.Colors.Separator, masterOpacity)
    self:_AnimateAndApplyColor(style_window.HeaderTitle, theme.Colors.TextPrimary, masterOpacity)
    self:_AnimateAndApplyColor(style_window.CloseButton.Line1, theme.Colors.TextSecondary, masterOpacity)
    self:_AnimateAndApplyColor(style_window.CloseButton.Line2, theme.Colors.TextSecondary, masterOpacity)
    self:_AnimateAndApplyColor(style_window.Separator1, theme.Colors.Separator, masterOpacity)
    self:_AnimateAndApplyColor(style_window.Separator2, theme.Colors.Separator, masterOpacity)
    self:_AnimateAndApplyColor(style_window.Separator3, theme.Colors.Separator, masterOpacity)
    self:_AnimateAndApplyColor(style_window.StyleNameLabel, theme.Colors.TextSecondary, masterOpacity)
    self:_AnimateAndApplyColor(style_window.StyleNameInputBg, theme.Colors.DarkBlue, masterOpacity)
    self:_AnimateAndApplyColor(style_window.StyleNameInputText, theme.Colors.TextPrimary, masterOpacity)
    self:_AnimateAndApplyColor(style_window.StyleNameInputCursor, theme.Colors.Accent, masterOpacity)
    for _, item in ipairs(style_window.ColorItems) do 
        self:_AnimateAndApplyColor(item.Label, theme.Colors.TextSecondary, masterOpacity); 
        self:_AnimateAndApplyColor(item.ColorBorder, theme.Colors.LightGray, masterOpacity); 
    end
    self:_AnimateAndApplyColor(style_window.RealTimeToggle.Label, theme.Colors.TextSecondary, masterOpacity)
    
    local cancelBtnBgColor = theme.Colors.MainBackground
    local cancelBtnTextColor = self:_GetTextColorForBackground(cancelBtnBgColor)
    self:_AnimateAndApplyColor(style_window.CancelButton.Background, cancelBtnBgColor, masterOpacity)
    self:_AnimateAndApplyColor(style_window.CancelButton.Border, theme.Colors.Separator, masterOpacity)
    self:_AnimateAndApplyColor(style_window.CancelButton.IconLine1, cancelBtnTextColor, masterOpacity)
    self:_AnimateAndApplyColor(style_window.CancelButton.IconLine2, cancelBtnTextColor, masterOpacity)
    self:_AnimateAndApplyColor(style_window.CancelButton.Label, cancelBtnTextColor, masterOpacity)
    
    local saveButtonAccentColor = theme.Colors.Accent
    self:_AnimateAndApplyColor(style_window.SaveButton.Background, saveButtonAccentColor, masterOpacity)
    local saveButtonTextColor = self:_GetTextColorForBackground(saveButtonAccentColor)
    self:_AnimateAndApplyColor(style_window.SaveButton.Label, saveButtonTextColor, masterOpacity)
    self:_AnimateAndApplyColor(style_window.SaveButton.Icon, saveButtonTextColor, masterOpacity)

    local winW, winH = 300, 570
    local winX, winY = self.Window.X + self.Window.Width + 15, self.Window.Y
    
    style_window.ClickRegion = {x1 = winX, y1 = winY, x2 = winX + winW, y2 = winY + winH}
    style_window.Background.Position = {winX, winY}; style_window.Background.Size = {winW, winH}
    style_window.Border.Position = {winX, winY}; style_window.Border.Size = {winW, winH}
    self:_RenderGlowEffect(style_window.Glow, winX, winY, winW, winH, style_window.Background.Rounding, theme.Colors.GlowColor, nil, masterOpacity)

    local headerY = winY + 12
    local accentIconColor = style_window.EditingTheme.Colors.Accent or {255,255,255,255}
    self:_AnimateAndApplyColor(style_window.HeaderIcon, accentIconColor, masterOpacity)
    style_window.HeaderIcon.Position = {winX + 15, headerY}
    style_window.HeaderTitle.Position = {winX + 15 + style_window.HeaderIcon.Size.x + 8, headerY + 1}
    
    style_window.CloseButton.Line1.From = {winX + winW - 25, headerY}; style_window.CloseButton.Line1.To = {winX + winW - 15, headerY + 10}
    style_window.CloseButton.Line2.From = {winX + winW - 25, headerY + 10}; style_window.CloseButton.Line2.To = {winX + winW - 15, headerY}
    style_window.CloseButton.ClickRegion = {x1 = winX + winW - 30, y1 = winY + 10, x2 = winX + winW - 10, y2 = winY + 25}

    local currentY = winY + 40
    style_window.Separator1.From = {winX + 10, currentY}; style_window.Separator1.To = {winX + winW - 10, currentY}
    
    currentY = currentY + 15
    style_window.StyleNameLabel.Position = {winX + 15, currentY}
    local inputW = 150; local inputH = 25
    local inputX = winX + winW - inputW - 15
    style_window.StyleNameInputBg.Position = {inputX, currentY - 5}; style_window.StyleNameInputBg.Size = {inputW, inputH}
    style_window.StyleNameInputText.Position = {inputX + 8, currentY - 5 + (inputH/2) - (style_window.StyleNameInputText.Size / 2)}
    style_window.StyleNameInputClickRegion = {x1 = inputX, y1 = currentY - 5, x2 = inputX + inputW, y2 = currentY - 5 + inputH}
    
    if style_window.StyleNameInputText.TextBounds then
        local cursorX = inputX + 8 + style_window.StyleNameInputText.TextBounds.x
        local cursorY = currentY - 5 + 4
        style_window.StyleNameInputCursor.From = {cursorX, cursorY}
        style_window.StyleNameInputCursor.To = {cursorX, cursorY + inputH - 8}
    end

    currentY = currentY + 30
    style_window.Separator2.From = {winX + 10, currentY}; style_window.Separator2.To = {winX + winW - 10, currentY}
    
    currentY = currentY + 15
    for _, item in ipairs(style_window.ColorItems) do
        item.Label.Position = {winX + 15, currentY}
        local circleX = winX + winW - 30
        
        local c = style_window.EditingTheme.Colors[item.Name] or {255,0,255,255}
        self:_AnimateAndApplyColor(item.ColorCircle, c, masterOpacity)

        item.ColorCircle.Position = {circleX, currentY + 7}
        item.ColorBorder.Position = {circleX, currentY + 7}
        
        item.ClickRegion = {x1 = circleX - 11, y1 = currentY - 4, x2 = circleX + 11, y2 = currentY + 18}
        
        currentY = currentY + 25
    end
    
    currentY = currentY + 5
    style_window.Separator3.From = {winX + 10, currentY}; style_window.Separator3.To = {winX + winW - 10, currentY}

    currentY = currentY + 15
    local saveBtn = style_window.SaveButton; local saveBtnW, saveBtnH = 80, 28
    local saveBtnX, saveBtnY = winX + winW - saveBtnW - 15, currentY
    saveBtn.Background.Position = {saveBtnX, saveBtnY}; saveBtn.Background.Size = {saveBtnW, saveBtnH}
    local saveIconX = saveBtnX + 12; local saveIconY = saveBtnY + (saveBtnH / 2) - (saveBtn.Icon.Size.y / 2)
    saveBtn.Icon.Position = {saveIconX, saveIconY}
    saveBtn.Label.Position = {saveIconX + saveBtn.Icon.Size.x + 8, saveBtnY + (saveBtnH / 2) - (saveBtn.Label.Size / 2)}
    saveBtn.ClickRegion = {x1 = saveBtnX, y1 = saveBtnY, x2 = saveBtnX + saveBtnW, y2 = saveBtnY + saveBtnH}

    local cancelBtn = style_window.CancelButton; local cancelBtnW, cancelBtnH = 90, 28
    local cancelBtnX = saveBtnX - cancelBtnW - 10; local cancelBtnY = currentY
    cancelBtn.Background.Position = {cancelBtnX, cancelBtnY}; cancelBtn.Background.Size = {cancelBtnW, cancelBtnH}
    cancelBtn.Border.Position = {cancelBtnX, cancelBtnY}; cancelBtn.Border.Size = {cancelBtnW, cancelBtnH}
    local cancelIconCenterX, cancelIconCenterY = cancelBtnX + 15, cancelBtnY + cancelBtnH / 2
    cancelBtn.IconLine1.From = {cancelIconCenterX - 4, cancelIconCenterY - 4}; cancelBtn.IconLine1.To = {cancelIconCenterX + 4, cancelIconCenterY + 4}
    cancelBtn.IconLine2.From = {cancelIconCenterX - 4, cancelIconCenterY + 4}; cancelBtn.IconLine2.To = {cancelIconCenterX + 4, cancelIconCenterY - 4}
    cancelBtn.Label.Position = {cancelIconCenterX + 10, cancelBtnY + (cancelBtnH / 2) - (cancelBtn.Label.Size / 2)}
    cancelBtn.ClickRegion = {x1 = cancelBtnX, y1 = cancelBtnY, x2 = cancelBtnX + cancelBtnW, y2 = cancelBtnY + cancelBtnH}
    
    currentY = currentY + saveBtnH + 15 
    local toggleY = currentY
    local toggle = style_window.RealTimeToggle
    toggle.Label.Position = {winX + 15, toggleY + 5}
    if toggle.Label.TextBounds then
      local toggleBackX = winX + 15 + toggle.Label.TextBounds.x + 10
      local toggleBackY = toggleY + 2
      toggle.Back.Position = {toggleBackX, toggleBackY}; 
      toggle.Back.Size = {toggle.Size.width, toggle.Size.height}; 
      toggle.ClickRegion = {x1 = toggleBackX, y1 = toggleBackY, x2 = toggleBackX + toggle.Size.width, y2 = toggleBackY + toggle.Size.height}
      
      local is_on = self.UI.Values[toggle.id]
      local nubY = toggleBackY + toggle.Size.height/2
      local targetBackColor, targetNubColor
      if is_on then
          if isThemeLight then
              targetBackColor = theme.Colors.Accent
              targetNubColor = theme.Colors.SectionBackground
          else
              targetBackColor = self:_DarkenColor(theme.Colors.Accent, 0.3)
              targetNubColor = theme.Colors.Accent
          end
      else
          targetBackColor = theme.Colors.DarkGray
          targetNubColor = theme.Colors.LightGray
      end
      
      local speed_value = self.UI.Values["AboutAnimationSpeed"] or 2.5
      local animationSpeed = speed_value / 25.0 -- lf 10
      local targetOffset = is_on and (toggle.Size.width - toggle.Size.height / 2) or (toggle.Size.height / 2)
      toggle.AnimatedNubOffset = toggle.AnimatedNubOffset + (targetOffset - toggle.AnimatedNubOffset) * animationSpeed
      toggle.Nub.Position = {toggleBackX + toggle.AnimatedNubOffset, nubY}

      self:_AnimateAndApplyColor(toggle.Back, targetBackColor, masterOpacity)
      self:_AnimateAndApplyColor(toggle.Nub, targetNubColor, masterOpacity)
    end
end


function Library:_RenderColorPickerWindow()
    local picker = self.UI.Popups.ColorPicker
    local masterOpacity = picker.Animation.CurrentOpacity

    if masterOpacity <= 0 then
        self:_HideGlowEffect(picker.Glow)
        self:_SetDrawingTableVisibility(picker, false)
        return
    end

    local allVisible = masterOpacity > 0
    self:_SetDrawingTableVisibility(picker, allVisible)
    self:_SetVisibility(picker.Input.Cursor, allVisible and picker.IsEditing and math.sin(tick() * 5) > 0)
    
    local theme = self.ActiveTheme
    local padding = 10
    local squareSize = 160
    local sliderHeight = 4
    local sliderSpacing = 10
    local inputRowHeight = 25
    local swatchRowHeight = 18

    local pickerW = squareSize + (padding * 2)
    local pickerH = squareSize + (padding * 4) + (sliderHeight * 2) + (sliderSpacing * 2) + (inputRowHeight * 2) + swatchRowHeight
    local pickerX, pickerY = picker.Pos.x, picker.Pos.y
    
    picker.ClickRegion = {x1 = pickerX, y1 = pickerY, x2 = pickerX + pickerW, y2 = pickerY + pickerH}
    picker.Background.Position = {pickerX, pickerY}; picker.Background.Size = {pickerW, pickerH}
    self:_AnimateAndApplyColor(picker.Background, theme.Colors.SectionBackground, masterOpacity)
    picker.Border.Position = {pickerX, pickerY}; picker.Border.Size = {pickerW, pickerH}
    self:_AnimateAndApplyColor(picker.Border, theme.Colors.Separator, masterOpacity)
    self:_RenderGlowEffect(picker.Glow, pickerX, pickerY, pickerW, pickerH, picker.Background.Rounding, theme.Colors.GlowColor, nil, masterOpacity)
    
    local squareX = pickerX + padding; local squareY = pickerY + padding
    picker.ColorSquare.Position = {squareX, squareY}; picker.ColorSquare.Size = {squareSize, squareSize}
    local pureHue = self:_HSVtoRGB(picker.h, 1, 1); 
    picker.ColorSquare.Color = {pureHue[1], pureHue[2], pureHue[3]}
    picker.ColorSquare.Opacity = masterOpacity
    picker.GradientOverlay.Position = {squareX, squareY}; picker.GradientOverlay.Size = {squareSize, squareSize}
    picker.GradientOverlay.Opacity = masterOpacity
    local svNubX = squareX + (picker.s * squareSize); local svNubY = squareY + ((1 - picker.v) * squareSize)
    picker.SaturationValueNub.Position = {svNubX, svNubY}; 
    picker.SaturationValueNub.Color = picker.v > 0.5 and {0,0,0} or {255,255,255}
    picker.SaturationValueNub.Opacity = masterOpacity
    picker.SaturationValueRegion = {x1 = squareX, y1 = squareY, x2 = squareX + squareSize, y2 = squareY + squareSize}
    
    local currentY = squareY + squareSize + sliderSpacing
    picker.HueSlider.Position = {squareX, currentY}; picker.HueSlider.Size = {squareSize, sliderHeight}
    picker.HueSlider.Opacity = masterOpacity
    local hueNubX = squareX + (picker.h * squareSize); local hueNubY = currentY + sliderHeight / 2
    picker.HueNub.Position = {hueNubX, hueNubY}; picker.HueNubBorder.Position = {hueNubX, hueNubY}
    local hueNubColor = self:_HSVtoRGB(picker.h, 1, 1); 
    picker.HueNub.Color = {hueNubColor[1], hueNubColor[2], hueNubColor[3]}; 
    picker.HueNubBorder.Color = {0, 0, 0}
    picker.HueNub.Opacity = masterOpacity
    picker.HueNubBorder.Opacity = masterOpacity
    picker.HueSliderRegion = {x1 = squareX, y1 = currentY, x2 = squareX + squareSize, y2 = currentY + sliderHeight}
    
    currentY = currentY + sliderHeight + sliderSpacing
    picker.OpacitySliderBackground.Position = {squareX, currentY}; picker.OpacitySliderBackground.Size = {squareSize, sliderHeight}
    local opacityBgColor = self:_HSVtoRGB(picker.h, picker.s, picker.v); 
    picker.OpacitySliderBackground.Color = {opacityBgColor[1], opacityBgColor[2], opacityBgColor[3]}
    picker.OpacitySliderBackground.Opacity = masterOpacity
    picker.OpacitySliderGradient.Position = {squareX, currentY}; picker.OpacitySliderGradient.Size = {squareSize, sliderHeight}
    picker.OpacitySliderGradient.Opacity = masterOpacity
    local opacityNubX = squareX + (picker.a * squareSize); local opacityNubY = currentY + sliderHeight / 2
    picker.OpacityNub.Position = {opacityNubX, opacityNubY}; picker.OpacityNubBorder.Position = {opacityNubX, opacityNubY}; 
    picker.OpacityNub.Color = {255, 255, 255}; picker.OpacityNubBorder.Color = {0, 0, 0}
    picker.OpacityNub.Opacity = masterOpacity
    picker.OpacityNubBorder.Opacity = masterOpacity
    picker.OpacitySliderRegion = {x1 = squareX, y1 = currentY, x2 = squareX + squareSize, y2 = currentY + sliderHeight}

    currentY = currentY + sliderHeight + sliderSpacing
    local dd = picker.Dropdown
    dd.ClickRegion = {x1 = squareX, y1 = currentY, x2 = squareX + squareSize, y2 = currentY + inputRowHeight}
    dd.Button.Position = {squareX, currentY}; dd.Button.Size = {squareSize, inputRowHeight}
    self:_AnimateAndApplyColor(dd.Button, theme.Colors.DarkBlue, masterOpacity)
    dd.ButtonText.Text = picker.Mode
    dd.ButtonText.Position = {squareX + 8, currentY + inputRowHeight/2 - dd.ButtonText.Size/2}
    self:_AnimateAndApplyColor(dd.ButtonText, theme.Colors.TextPrimary, masterOpacity)
    local arrowX, arrowY = squareX + squareSize - 15, currentY + inputRowHeight/2
    dd.ArrowLine1.From = {arrowX - 3, arrowY - 1}; dd.ArrowLine1.To = {arrowX, arrowY + 2};
    dd.ArrowLine2.From = {arrowX, arrowY + 2}; dd.ArrowLine2.To = {arrowX + 3, arrowY - 1};
    self:_AnimateAndApplyColor(dd.ArrowLine1, theme.Colors.TextSecondary, masterOpacity); 
    self:_AnimateAndApplyColor(dd.ArrowLine2, theme.Colors.TextSecondary, masterOpacity)
    
    currentY = currentY + inputRowHeight + 5
    local input = picker.Input
    input.ClickRegion = {x1 = squareX, y1 = currentY, x2 = squareX + squareSize, y2 = currentY + inputRowHeight}
    input.Background.Position = {squareX, currentY}; input.Background.Size = {squareSize, inputRowHeight}
    self:_AnimateAndApplyColor(input.Background, theme.Colors.DarkBlue, masterOpacity)
    
    local text_to_show
    if picker.IsEditing then
        text_to_show = picker.Mode == "HEX" and ("#" .. picker.InputText) or picker.InputText
    else
        local rgb = self:_HSVtoRGB(picker.h, picker.s, picker.v)
        if picker.Mode == "HEX" then
            text_to_show = self:_RGBtoHEX(rgb[1], rgb[2], rgb[3], picker.a * 255)
        else 
            text_to_show = string.format("%d, %d, %d, %d", math.floor(rgb[1]), math.floor(rgb[2]), math.floor(rgb[3]), math.floor(picker.a * 255))
        end
    end

    input.Text.Text = text_to_show
    local max_text_width = squareSize - 16
    if input.Text.TextBounds and input.Text.TextBounds.x > max_text_width then
        local temp_text = text_to_show
        while input.Text.TextBounds and input.Text.TextBounds.x > max_text_width and #temp_text > 0 do
            temp_text = string.sub(temp_text, 1, -2)
            input.Text.Text = temp_text .. "..."
        end
    end
    
    input.Text.Position = {squareX + 8, currentY + inputRowHeight/2 - input.Text.Size/2}
    self:_AnimateAndApplyColor(input.Text, theme.Colors.TextPrimary, masterOpacity)
    
    if input.Text.TextBounds and picker.IsEditing then
        local cursorX = input.Text.Position.x + input.Text.TextBounds.x + 2
        input.Cursor.From = {cursorX, currentY + 4}
        input.Cursor.To = {cursorX, currentY + inputRowHeight - 4}
        self:_AnimateAndApplyColor(input.Cursor, theme.Colors.Accent, masterOpacity)
    end
    
    currentY = currentY + inputRowHeight + 15
    local swatchSpacing = 22
    local currentSwatchX = squareX + 10
    
    for _, swatch in ipairs(picker.Swatches) do
        swatch.Circle.Position = {currentSwatchX, currentY}
        swatch.Border.Position = {currentSwatchX, currentY}
        swatch.ClickRegion = {x1 = currentSwatchX - 10, y1 = currentY - 10, x2 = currentSwatchX + 10, y2 = currentY + 10}

        self:_AnimateAndApplyColor(swatch.Border, theme.Colors.Separator, masterOpacity)
        if swatch.IsAddButton then
            self:_AnimateAndApplyColor(swatch.Circle, theme.Colors.DarkBlue, masterOpacity)
            swatch.PlusLine1.From = {currentSwatchX - 3, currentY}; swatch.PlusLine1.To = {currentSwatchX + 3, currentY}
            swatch.PlusLine2.From = {currentSwatchX, currentY - 3}; swatch.PlusLine2.To = {currentSwatchX, currentY + 3}
            self:_AnimateAndApplyColor(swatch.PlusLine1, theme.Colors.TextSecondary, masterOpacity)
            self:_AnimateAndApplyColor(swatch.PlusLine2, theme.Colors.TextSecondary, masterOpacity)
        else
            swatch.Circle.Opacity = ((swatch.Color[4] or 255) / 255) * masterOpacity
        end

        currentSwatchX = currentSwatchX + swatchSpacing
    end

    -- ---[[ НАЧАЛО ИСПРАВЛЕНИЯ: Финальная версия логики анимации дропдауна ]]
    local speed_value = self.UI.Values["AboutAnimationSpeed"] or 2.4
    local animationSpeed = (speed_value / 1.5) / 10.0
    
    local targetOpacity = (dd.IsOpen and not dd.IsClosing) and 1 or 0
    dd.FadeOpacity = dd.FadeOpacity + (targetOpacity - dd.FadeOpacity) * animationSpeed
    
    if math.abs(targetOpacity - dd.FadeOpacity) < 0.01 then
        dd.FadeOpacity = targetOpacity
        if dd.IsClosing then dd.IsClosing = false end
    end

    if dd.FadeOpacity > 0 then
        local finalOpacity = masterOpacity * dd.FadeOpacity
        local optionHeight = 25
        local popupHeight = (#dd.Options * optionHeight) + 10
        
        local buttonCenterY = dd.ClickRegion.y1 + (inputRowHeight / 2)
        local popupY = buttonCenterY - (popupHeight / 2)
        dd.PopupClickRegion = {x1=dd.ClickRegion.x1, y1=popupY, x2=dd.ClickRegion.x1+squareSize, y2=popupY+popupHeight}

        self:_SetVisibility(dd.PopupBg, true)
        self:_SetVisibility(dd.Border, true)
        
        dd.PopupBg.Position = {dd.ClickRegion.x1, popupY}; dd.PopupBg.Size = {squareSize, popupHeight}
        self:_AnimateAndApplyColor(dd.PopupBg, theme.Colors.SectionBackground, finalOpacity)
        dd.Border.Position = {dd.ClickRegion.x1, popupY}; dd.Border.Size = {squareSize, popupHeight}
        self:_AnimateAndApplyColor(dd.Border, theme.Colors.Separator, finalOpacity)
        
        self:_RenderGlowEffect(dd.Glow, dd.ClickRegion.x1, popupY, squareSize, popupHeight, dd.PopupBg.Rounding, theme.Colors.GlowColor, nil, finalOpacity)

        local currentOptionY = popupY + 5
        for i, option in ipairs(dd.Options) do
            self:_SetVisibility(option.Text, true)
            self:_SetVisibility(option.Highlight, true)

            option.ClickRegion = {x1 = dd.ClickRegion.x1, y1 = currentOptionY, x2 = dd.ClickRegion.x1 + squareSize, y2 = currentOptionY + optionHeight}
            option.Text.Position = {dd.ClickRegion.x1 + 10, currentOptionY + optionHeight/2 - option.Text.Size/2}
            
            local isSelected = (picker.Mode == option.Text.Text)
            local targetTextColor = isSelected and theme.Colors.Accent or theme.Colors.TextPrimary
            self:_AnimateAndApplyColor(option.Text, targetTextColor, finalOpacity)
            
            option.Highlight.Position = {dd.ClickRegion.x1 + 5, currentOptionY}; option.Highlight.Size = {squareSize - 10, optionHeight}
            local isHovered = (picker.HoveredDropdownIndex == i)
            if isHovered then
                self:_AnimateAndApplyColor(option.Highlight, theme.Colors.Separator, finalOpacity * 0.4)
            else
                option.Highlight.Opacity = 0
            end
            currentOptionY = currentOptionY + optionHeight
        end
    else
        dd.PopupClickRegion = nil
        self:_SetVisibility(dd.PopupBg, false)
        self:_SetVisibility(dd.Border, false)
        for _, option in ipairs(dd.Options) do
            self:_SetVisibility(option.Text, false)
            self:_SetVisibility(option.Highlight, false)
        end
        self:_HideGlowEffect(dd.Glow)
    end
    -- ---[[ КОНЕЦ ИСПРАВЛЕНИЯ ]]
end


function Library:_RenderLoop()
    local speed_value = self.UI.Values["AboutAnimationSpeed"] or 2.4
    local animationSpeed = (speed_value > 0) and (speed_value / 10.0) or 1
    
    if self.GlobalAnimation.IsHiding then
        self.GlobalAnimation.Opacity = self.GlobalAnimation.Opacity - animationSpeed
        if self.GlobalAnimation.Opacity <= 0 then
            self.GlobalAnimation.Opacity = 0
            self.GlobalAnimation.IsHiding = false
        end
    elseif self.GlobalAnimation.IsShowing then
        self.GlobalAnimation.Opacity = self.GlobalAnimation.Opacity + animationSpeed
        if self.GlobalAnimation.Opacity >= 1 then
            self.GlobalAnimation.Opacity = 1
            self.GlobalAnimation.IsShowing = false
        end
    end

    -- [[ Блок обновления анимаций ]]
    -- [[ ИСПРАВЛЕНИЕ: Указываем правильный путь к объекту About Window ]]
    self:_UpdatePopupAnimation(self.UI.Core.AboutWindow)
    self:_UpdatePopupAnimation(self.UI.Popups.EditStyle)
    self:_UpdatePopupAnimation(self.UI.Popups.ColorPicker)
    self:_UpdatePopupAnimation(self.UI.Popups.BurgerMenu)
    
    if not self.Window.Visible then return end

    if self.Window.ActiveTab ~= self.Window.LastRenderedTab and self.Window.LastRenderedTab ~= "" then
        self.Window.Animation.State = "FADING_OUT"
        self.Window.Animation.OldTab = self.Window.LastRenderedTab
    end

    if self.UI.Core.ConfigsTab.NeedsRefresh then
        self:_RefreshConfigList()
        self.UI.Core.ConfigsTab.NeedsRefresh = false
    end

    if self.UI.Values["AboutAutoSave"] and self.UI.Core.ConfigsTab.LoadedConfigName ~= "" then
        if tick() - lastAutoSaveTime > autoSaveInterval then
            self:_SaveConfig(self.UI.Core.ConfigsTab.LoadedConfigName)
            lastAutoSaveTime = tick()
        end
    end

    self:_UpdateAnimationStates()

    local mouse_pos = getmouseposition()
    if not mouse_pos then return end

    local Core = self.UI.Core
    local theme = self.ActiveTheme
    local isThemeLight = self:_IsThemeLight(theme)
    local windowX, windowY = self:_SafeNumber(self.Window.X, 0), self:_SafeNumber(self.Window.Y, 0)
    local sidebarWidth, headerHeight = self:_SafeNumber(self.Window.SidebarWidth, 0), self:_SafeNumber(self.Window.HeaderHeight, 0)
    local rightPanelX = windowX + sidebarWidth - self.Window.PanelOverlap

    self:_SetVisibility(Core.Sidebar.Drawing, true); self:_SetVisibility(Core.RightPanel.Drawing, true); self:_SetVisibility(Core.VerticalSeparator, true); self:_SetVisibility(Core.SidebarHeaderSeparator, true); self:_SetVisibility(Core.RightPanelHeaderSeparator, true); self:_SetVisibility(Core.Title, true); self:_SetVisibility(Core.SidebarBottomCircle, true); if Core.SidebarAvatar then self:_SetVisibility(Core.SidebarAvatar, true) end; self:_SetVisibility(Core.PlayerDisplayName, true); self:_SetVisibility(Core.TillLabel, true); self:_SetVisibility(Core.ForeverLabel, true)
    self:_SetVisibility(Core.Title2, not isThemeLight); self:_SetVisibility(Core.Title3, not isThemeLight)

    self:_AnimateAndApplyColor(Core.Sidebar.Drawing, theme.Colors.SidebarBackground)
    self:_AnimateAndApplyColor(Core.RightPanel.Drawing, theme.Colors.MainBackground)
    self:_AnimateAndApplyColor(Core.VerticalSeparator, theme.Colors.Separator)
    self:_AnimateAndApplyColor(Core.SidebarHeaderSeparator, theme.Colors.Separator)
    self:_AnimateAndApplyColor(Core.RightPanelHeaderSeparator, theme.Colors.Separator)
    self:_AnimateAndApplyColor(Core.Title, theme.Colors.TextPrimary)
    self:_AnimateAndApplyColor(Core.Title2, theme.Colors.Accent)
    self:_AnimateAndApplyColor(Core.Title3, theme.Colors.SectionBackground)
    self:_AnimateAndApplyColor(Core.SidebarBottomCircle, theme.Colors.Separator)
    self:_AnimateAndApplyColor(Core.PlayerDisplayName, theme.Colors.TextPrimary)
    self:_AnimateAndApplyColor(Core.TillLabel, theme.Colors.TextSecondary)
    self:_AnimateAndApplyColor(Core.ForeverLabel, theme.Colors.Accent)
    if Core.SidebarAvatar then self:_AnimateAndApplyColor(Core.SidebarAvatar, {255, 255, 255, 255}) end

    if Core.Sidebar.Drawing then Core.Sidebar.Drawing.Position = {windowX, windowY}; Core.Sidebar.Drawing.Size = {sidebarWidth, self.Window.Height}; end
    if Core.RightPanel.Drawing then Core.RightPanel.Drawing.Position = {rightPanelX, windowY}; Core.RightPanel.Drawing.Size = {self.Window.Width - sidebarWidth + self.Window.PanelOverlap, self.Window.Height}; end

    self:_RenderGlowEffect(Core.Sidebar.Glow, windowX, windowY, sidebarWidth, self.Window.Height, Core.Sidebar.Drawing.Rounding, theme.Colors.GlowColor, {top=true, bottom=true, left=true, right=true})
    self:_RenderGlowEffect(Core.RightPanel.Glow, rightPanelX, windowY, self.Window.Width - sidebarWidth + self.Window.PanelOverlap, self.Window.Height, Core.RightPanel.Drawing.Rounding, theme.Colors.GlowColor, {top=true, bottom=true, left=false, right=true})

    if Core.VerticalSeparator then Core.VerticalSeparator.Position = {rightPanelX, windowY}; Core.VerticalSeparator.Size = {4, self.Window.Height}; end
    if Core.SidebarHeaderSeparator then Core.SidebarHeaderSeparator.Position = {windowX, windowY + self.Window.Height - 100 + 14}; Core.SidebarHeaderSeparator.Size = {sidebarWidth, 4}; end
    if Core.RightPanelHeaderSeparator then Core.RightPanelHeaderSeparator.Position = {rightPanelX, windowY + headerHeight}; Core.RightPanelHeaderSeparator.Size = {self.Window.Width - sidebarWidth + self.Window.PanelOverlap, 4}; end
    if Core.Title then Core.Title.Position = {windowX + 11, windowY + 25}; end
    if Core.Title2 then Core.Title2.Position = {windowX + 9, windowY + 26}; end
    if Core.Title3 then Core.Title3.Position = {windowX + 7, windowY + 24}; end
    if Core.SidebarBottomCircle then local circleX = windowX + 8 + Core.SidebarBottomCircle.Radius; local circleY = windowY + self.Window.Height - 44; Core.SidebarBottomCircle.Position = {circleX, circleY}; end
    if Core.SidebarAvatar then local avatarSize = 56; local avatarX = windowX + 8; local avatarY = windowY + self.Window.Height - 44 - avatarSize / 2; Core.SidebarAvatar.Position = {avatarX, avatarY}; Core.SidebarAvatar.Size = {avatarSize, avatarSize}; end
    if Core.PlayerDisplayName then local textX = windowX + 15 + Core.SidebarBottomCircle.Radius * 2 + 5; local textY = windowY + self.Window.Height - 56; Core.PlayerDisplayName.Position = {textX, textY}; end
    if Core.TillLabel then local textX = windowX + 15 + Core.SidebarBottomCircle.Radius * 2 + 5; local textY = windowY + self.Window.Height - 40; Core.TillLabel.Position = {textX, textY}; end
    if Core.ForeverLabel then local textX = windowX + 8 + Core.SidebarBottomCircle.Radius * 2 + 30; local textY = windowY + self.Window.Height - 40; Core.ForeverLabel.Position = {textX, textY}; end

    do
        local startX, startY = rightPanelX + 35, windowY + (headerHeight / 2)
        local function renderHeaderButton(button, x, y, width, height, has_icon, is_accent)
             self:_SetVisibility(button.Background, true); self:_SetVisibility(button.Border, true); self:_SetVisibility(button.Label, true); if button.Icon then self:_SetVisibility(button.Icon, button.Icon.Visible) end
             button.Background.Position = {x, y}; button.Background.Size = {width, height};
             button.Border.Position = {x, y}; button.Border.Size = {width, height};
             local isHovered = self:_IsPointInRegion(mouse_pos.x, mouse_pos.y, button.ClickRegion)
             button.IsHovered = isHovered
             local targetBgColor, targetTextColor
            if button == Core.HeaderButtons.CreateNew then
                -- Логика для кнопки "Create New" остается без изменений
                local baseColor = theme.Colors.Accent
                local opacity = isHovered and 255 or (255 * 0.6)
                targetBgColor = {baseColor[1], baseColor[2], baseColor[3], opacity}
                targetTextColor = self:_GetTextColorForBackground(baseColor)
            else
                -- Новая логика для кнопок "Save" и "View ESP"
                if isHovered then
                    if isThemeLight then
                        targetBgColor = theme.Colors.Accent -- Обычный акцентный цвет для светлой темы
                    else
                        targetBgColor = self:_DarkenColor(theme.Colors.Accent, 0.5) -- Затемненный для темной
                    end
                    targetTextColor = self:_GetTextColorForBackground(targetBgColor) -- Авто-подбор цвета текста
                else
                    -- Цвет по умолчанию (когда нет наведения)
                    targetBgColor = is_accent and theme.Colors.Accent or theme.Colors.MainBackground
                    targetTextColor = is_accent and self:_GetTextColorForBackground(theme.Colors.Accent) or theme.Colors.TextPrimary
                end
            end
             local targetBorderColor = (tick() - (button.ClickTime or 0) < 0.1 or (button.IsOpen)) and theme.Colors.Accent or theme.Colors.Separator
             self:_AnimateAndApplyColor(button.Background, targetBgColor)
             self:_AnimateAndApplyColor(button.Border, targetBorderColor)
             self:_AnimateAndApplyColor(button.Label, targetTextColor)
             if button.Icon then self:_AnimateAndApplyColor(button.Icon, targetTextColor) end
             if has_icon and button.Icon then local iconX, iconY = x + 12, y + (height / 2) - (button.Icon.Size.y / 2); button.Icon.Position = {iconX, iconY}; local labelX, labelY = iconX + button.Icon.Size.x + 5, y + (height / 2) - (button.Label.Size / 2); button.Label.Position = {labelX, labelY}; button.Label.Center = false else button.Label.Position = {x + width / 2, y + (height / 2) - (button.Label.Size / 2)}; button.Label.Center = true end
             button.ClickRegion = {x1 = x, y1 = y, x2 = x + width, y2 = y + height}
        end

        local btnWidth, btnHeight, spacing = 75, 30, 15
        local createNewBtnWidth = 120
        local btnY = startY - (btnHeight / 2)
        local currentX = startX
        renderHeaderButton(Core.HeaderButtons.Save, currentX, btnY, btnWidth, btnHeight, true, false)
        currentX = currentX + btnWidth + spacing
        renderHeaderButton(Core.HeaderButtons.ViewESP, currentX, btnY, btnWidth, btnHeight, false, false)
        currentX = currentX + btnWidth + spacing
        if self.Window.ActiveTab == "Configs" then
            renderHeaderButton(Core.HeaderButtons.CreateNew, currentX, btnY, createNewBtnWidth, btnHeight, true, true)
        else
            self:_SetVisibility(Core.HeaderButtons.CreateNew.Background, false); self:_SetVisibility(Core.HeaderButtons.CreateNew.Border, false); self:_SetVisibility(Core.HeaderButtons.CreateNew.Label, false); self:_SetVisibility(Core.HeaderButtons.CreateNew.Icon, false);
        end

        local settingsIcon = Core.HeaderButtons.Settings.Icon
        local settingsX = rightPanelX + (self.Window.Width - sidebarWidth + self.Window.PanelOverlap) - settingsIcon.Size.x - 20
        local settingsY = startY - (settingsIcon.Size.y / 2)
        self:_SetVisibility(settingsIcon, true); settingsIcon.Position = {settingsX, settingsY}; Core.HeaderButtons.Settings.ClickRegion = {x1 = settingsX, y1 = settingsY, x2 = settingsX + settingsIcon.Size.x, y2 = settingsY + settingsIcon.Size.y}
        self:_AnimateAndApplyColor(settingsIcon, theme.Colors.TextSecondary)

        local burger = Core.HeaderButtons.BurgerMenu
        local burgerX = settingsX - 25
        local burgerY = startY
        self:_SetVisibility(burger.Line1, true); self:_SetVisibility(burger.Line2, true); self:_SetVisibility(burger.Line3, true)
        burger.Line1.From = {burgerX - 8, burgerY - 5}; burger.Line1.To = {burgerX + 8, burgerY - 5}
        burger.Line2.From = {burgerX - 8, burgerY};     burger.Line2.To = {burgerX + 8, burgerY}
        burger.Line3.From = {burgerX - 8, burgerY + 5}; burger.Line3.To = {burgerX + 8, burgerY + 5}
        burger.ClickRegion = {x1 = burgerX - 10, y1 = burgerY - 10, x2 = burgerX + 10, y2 = burgerY + 10}
        
        local burgerColor = self.UI.Popups.BurgerMenu.IsOpen and theme.Colors.Accent or theme.Colors.TextSecondary
        self:_AnimateAndApplyColor(burger.Line1, burgerColor); self:_AnimateAndApplyColor(burger.Line2, burgerColor); self:_AnimateAndApplyColor(burger.Line3, burgerColor)
    end

    -- ЗАМЕНИ БЛОК ESP В _RenderLoop() НА ЭТОТ КОД
    do
        local espButton = Core.HeaderButtons.ViewESP
        local anim = espButton.Animation

        -- Управляем запуском анимации на основе флага IsOpen
        if espButton.IsOpen and anim.CurrentOpacity < 1 and not anim.IsOpening then
            anim.IsOpening = true
            anim.IsClosing = false
        elseif not espButton.IsOpen and anim.CurrentOpacity > 0 and not anim.IsClosing then
            anim.IsOpening = false
            anim.IsClosing = true
        end

        local masterOpacity = anim.CurrentOpacity
        local isVisible = masterOpacity > 0

        -- Устанавливаем видимость для всех элементов
        self:_SetVisibility(Core.ViewESPPanel, isVisible)
        self:_SetVisibility(Core.ViewESPPanelBorder, isVisible)
        if Core.ViewESPImage then
            self:_SetVisibility(Core.ViewESPImage, isVisible)
        end

        -- Если панель хоть немного видна, отрисовываем и позиционируем её
        if isVisible then
            local panelX = windowX + self.Window.Width + 11

            self:_AnimateAndApplyColor(Core.ViewESPPanel, theme.Colors.SectionBackground, masterOpacity)
            self:_AnimateAndApplyColor(Core.ViewESPPanelBorder, theme.Colors.Separator, masterOpacity)

            Core.ViewESPPanel.Position = {panelX, windowY}
            Core.ViewESPPanel.Size = {200, 310}
            Core.ViewESPPanelBorder.Position = {panelX, windowY}
            Core.ViewESPPanelBorder.Size = {200, 310}

            if Core.ViewESPImage then
                self:_AnimateAndApplyColor(Core.ViewESPImage, {255, 255, 255}, masterOpacity) -- Убрал альфа-канал, т.к. он управляется masterOpacity
                local imageX, imageY = panelX + 3, windowY + 3
                Core.ViewESPImage.Position = {imageX, imageY}
                Core.ViewESPImage.Size = {194, 304}
            end
        end
    end

    self:_RenderTabs(windowX, windowY + headerHeight, sidebarWidth)

    if self.Window.ActiveTab == "Configs" then
        for _, section in ipairs(self.UI.Sections) do
            local anim_state = self.AnimationState[section.Drawing.Background]
            if anim_state and anim_state.IsVisible then
                self:_SetSectionAndElementsVisibility(section, false)
                anim_state.IsVisible = false
            end
        end
        self:_RenderConfigsTab(rightPanelX, windowY, headerHeight)
    else
        local configsTab = self.UI.Core.ConfigsTab
        if configsTab.MyItemsLabel.Visible then
            self:_SetVisibility(configsTab.MyItemsLabel, false)
            self:_SetVisibility(configsTab.Scrollbar.Background, false)
            self:_SetVisibility(configsTab.Scrollbar.Nub, false)
            for _, item in ipairs(configsTab.Items) do
                self:_SetDrawingTableVisibility(item.Drawing, false)
            end
        end
        self:_RenderSections(rightPanelX, windowY, headerHeight)
    end

    self:_RenderSaveTooltip()
    self:_RenderConfigOptionsPopup()
    self:_RenderSettingsPopup()
    self:_RenderAboutWindow(mouse_pos)
    self:_RenderEditStyleWindow()
    self:_RenderColorPickerWindow()
    self:_RenderBurgerMenuPopup(mouse_pos)

    self.Window.LastRenderedTab = self.Window.ActiveTab

    if not self.GlobalAnimation.IsHiding and self.GlobalAnimation.Opacity <= 0 then
        self.Window.Visible = false
    end
end

function Library:_RenderTabs(x, y, width)
    local sidebarWidth = self:_SafeNumber(width, 187) 
    
    local currentY = y + 8
    local theme = self.ActiveTheme
    local globalOpacity = self.GlobalAnimation and self.GlobalAnimation.Opacity or 1

    for _, group in ipairs(self.UI.TabGroups) do
        if group.Header then
            self:_SetVisibility(group.Header, true)
            self:_AnimateAndApplyColor(group.Header, theme.Colors.TabHeader)
            group.Header.Position = {x + 25, currentY}
        end
        currentY = currentY + theme.Fonts.TabHeaderSize + 10

        for _, tab in ipairs(group.Tabs) do
            local tabHeight = theme.Fonts.TabSize + 10
            local is_active = (self.Window.ActiveTab == tab.Name)
            local target_text_color = is_active and theme.Colors.TextPrimary or theme.Colors.TextSecondary
            local startX = x + 25

            if tab.Icon then
                self:_SetVisibility(tab.Icon, true)
                tab.Icon.Position = {startX, currentY + (tabHeight / 2) - (theme.IconSize / 2)}
                local iconColor = theme.Colors.Accent
                self:_AnimateAndApplyColor(tab.Icon, iconColor)
                startX = startX + theme.IconSize + 8
            end

            if tab.Text then
                self:_SetVisibility(tab.Text, true)
                tab.Text.Position = {startX, currentY + (tabHeight / 2) - (tab.Text.Size / 2)}
                self:_AnimateAndApplyColor(tab.Text, target_text_color)
            end

            tab.ClickRegion = {x1 = x + 10, y1 = currentY, x2 = x + sidebarWidth - 10, y2 = currentY + tabHeight}

            if tab.Highlight then
                tab.Highlight.Position = {x + 10, currentY}
                tab.Highlight.Size = {sidebarWidth - 20, tabHeight}
                
                local state = self.AnimationState[tab.Highlight]
                if not state then
                    local initialOpacity = is_active and (theme.Transparency.ActiveTabHighlight or 0.28) or 0
                    state = { CurrentOpacity = initialOpacity }
                    self.AnimationState[tab.Highlight] = state
                end

                local targetOpacity = is_active and (theme.Transparency.ActiveTabHighlight or 0.28) or 0
                local speed_value = self.UI.Values["AboutAnimationSpeed"] or 2.4
                local animationSpeed = speed_value / 16.0

                state.CurrentOpacity = state.CurrentOpacity + (targetOpacity - state.CurrentOpacity) * animationSpeed
                
                -- ИСПОЛЬЗУЕМ _AnimateAndApplyColor И ПЕРЕДАЁМ АНИМИРОВАННУЮ ПРОЗРАЧНОСТЬ
                self:_AnimateAndApplyColor(tab.Highlight, theme.Colors.Accent, state.CurrentOpacity)
            end

            currentY = currentY + tabHeight + 5
        end
        currentY = currentY + 15
    end
end

function Library:_RenderSingleSection(section, sectionX, sectionY, columnWidth, yOffset, masterOpacity)
    local theme = self.ActiveTheme
    local isThemeLight = self:_IsThemeLight(theme)
    local animatedY = sectionY + yOffset

    local sDrawing = section.Drawing
    for _, obj in pairs(sDrawing) do self:_SetVisibility(obj, true) end
    self:_AnimateAndApplyColor(sDrawing.Background, theme.Colors.SectionBackground, masterOpacity)
    self:_AnimateAndApplyColor(sDrawing.Border, theme.Colors.Separator, masterOpacity)
    self:_AnimateAndApplyColor(sDrawing.Title, theme.Colors.TextPrimary, masterOpacity)
    self:_AnimateAndApplyColor(sDrawing.Separator, theme.Colors.Separator, masterOpacity)

    sDrawing.Background.Position = {sectionX, animatedY}
    sDrawing.Border.Position = {sectionX, animatedY}
    sDrawing.Title.Position = {sectionX + 10, animatedY + 8}
    local separatorY_abs = sDrawing.Title.Position.y + sDrawing.Title.Size + 5
    sDrawing.Separator.From = {sectionX + 10, separatorY_abs}; sDrawing.Separator.To = {sectionX + columnWidth - 10, separatorY_abs}

    local elementY_offset = (separatorY_abs - animatedY) + 15

    for _, el in ipairs(section.Elements) do
        self:_SetVisibility(el.Label, true)
        if el.type == "Toggle" then
            self:_SetVisibility(el.Back, true); self:_SetVisibility(el.Nub, true)
            local currentElementY = animatedY + elementY_offset; self:_AnimateAndApplyColor(el.Label, theme.Colors.TextSecondary, masterOpacity); el.Label.Position = {sectionX + 10, currentElementY}
            local toggleBackX = sectionX + columnWidth - el.Size.width - 15; local toggleBackY = currentElementY - 1
            el.Back.Position = {toggleBackX, toggleBackY}; el.Back.Size = {el.Size.width, el.Size.height}; el.ClickRegion = {x1 = toggleBackX, y1 = toggleBackY, x2 = toggleBackX + el.Size.width, y2 = toggleBackY + el.Size.height}
            local is_on = self.UI.Values[el.id]; local nubY = toggleBackY + el.Size.height / 2; local targetBackColor, targetNubColor
            if is_on then if isThemeLight then targetBackColor = theme.Colors.Accent; targetNubColor = theme.Colors.SectionBackground else targetBackColor = self:_DarkenColor(theme.Colors.Accent, 0.3); targetNubColor = theme.Colors.Accent end else targetBackColor = theme.Colors.DarkGray; targetNubColor = theme.Colors.LightGray end
            
            local targetOffset = is_on and (el.Size.width - el.Size.height / 2) or (el.Size.height / 2)
            
            -- [[ ИСПРАВЛЕНИЕ: Используем правильный ID "BurgerLow-EndMode" ]]
            if self.UI.Values["BurgerLow-EndMode"] then
                el.AnimatedNubOffset = targetOffset
            else
                local speed_value = self.UI.Values["AboutAnimationSpeed"] or 2.5
                local animationSpeed = speed_value / 10.0
                el.AnimatedNubOffset = el.AnimatedNubOffset + (targetOffset - el.AnimatedNubOffset) * animationSpeed
            end
            
            el.Nub.Position = {toggleBackX + el.AnimatedNubOffset, nubY}

            self:_AnimateAndApplyColor(el.Back, targetBackColor, masterOpacity); self:_AnimateAndApplyColor(el.Nub, targetNubColor, masterOpacity)
            local iconAreaX = toggleBackX - 7
            if el.HasColor and el.ColorCircle then self:_SetVisibility(el.ColorCircle, true); self:_SetVisibility(el.ColorBorder, true); local colorValue = self.UI.Values[el.HasColor.id]; self:_AnimateAndApplyColor(el.ColorCircle, colorValue, masterOpacity); self:_AnimateAndApplyColor(el.ColorBorder, theme.Colors.LightGray, masterOpacity); local radius = el.ColorCircle.Radius; local iconWidth = radius * 2; local iconX = iconAreaX - iconWidth; el.ColorCircle.Position = {iconX + radius, currentElementY + 9}; el.ColorBorder.Position = {iconX + radius, currentElementY + 9}; el.ColorClickRegion = {x1 = iconX, y1 = currentElementY, x2 = iconX + iconWidth, y2 = currentElementY + 18}; iconAreaX = iconX - 7
            else if el.ColorCircle then self:_SetVisibility(el.ColorCircle, false) end; if el.ColorBorder then self:_SetVisibility(el.ColorBorder, false) end end
            if el.HasSettings and el.SettingsIcon then self:_SetVisibility(el.SettingsIcon, true); self:_AnimateAndApplyColor(el.SettingsIcon, theme.Colors.TextSecondary, masterOpacity); local iconX = iconAreaX - el.SettingsIcon.Size.x; el.SettingsIcon.Position = {iconX, currentElementY}; el.SettingsClickRegion = {x1 = iconX, y1 = currentElementY, x2 = iconX + el.SettingsIcon.Size.x, y2 = currentElementY + el.SettingsIcon.Size.y}
            else if el.SettingsIcon then self:_SetVisibility(el.SettingsIcon, false) end end
            elementY_offset = elementY_offset + 35
        elseif el.type == "Slider" then
            self:_SetVisibility(el.Back, true); self:_SetVisibility(el.LeftFill, true); self:_SetVisibility(el.Nub, true); self:_SetVisibility(el.ValueText, true); self:_SetVisibility(el.ValueInputBg, true); self:_SetVisibility(el.ValueInputBorder, true)
            self:_SetVisibility(el.ValueInputCursor, el.IsEditing and math.sin(tick() * 5) > 0)

            local currentElementY = animatedY + elementY_offset
            self:_AnimateAndApplyColor(el.Label, theme.Colors.TextSecondary, masterOpacity); el.Label.Position = {sectionX + 10, currentElementY}
            
            local valueBoxW, valueBoxH = 45, 22
            local valueBoxX = sectionX + columnWidth - valueBoxW - 10
            el.ValueInputBg.Position = {valueBoxX, currentElementY - 4}; el.ValueInputBg.Size = {valueBoxW, valueBoxH}
            el.ValueInputBorder.Position = {valueBoxX, currentElementY - 4}; el.ValueInputBorder.Size = {valueBoxW, valueBoxH}
            el.ValueInputClickRegion = {x1 = valueBoxX, y1 = currentElementY - 4, x2 = valueBoxX + valueBoxW, y2 = currentElementY - 4 + valueBoxH}
            
            local sliderBackX = sectionX + 100
            local sliderBackWidth = (valueBoxX - 10) - sliderBackX
            el.Back.Position = {sliderBackX, currentElementY + 8}; el.Back.Size = {sliderBackWidth, 2}; el.ClickRegion = { x1 = sliderBackX, y1 = currentElementY - 2, x2 = sliderBackX + sliderBackWidth, y2 = currentElementY + 18 };
            
            -- [[ ИСПРАВЛЕНИЕ: Используем правильный ID "BurgerLow-EndMode" ]]
            if self.UI.Values["BurgerLow-EndMode"] then
                el.AnimatedValue = self.UI.Values[el.id]
            else
                local speed_value = self.UI.Values["AboutAnimationSpeed"] or 2.5
                local animationSpeed = speed_value / 15.0
                el.AnimatedValue = el.AnimatedValue + (self.UI.Values[el.id] - el.AnimatedValue) * animationSpeed
            end
            
            local value_percentage = math.clamp((el.AnimatedValue - el.Min) / (el.Max - el.Min), 0, 1)
            local nubX = sliderBackX + sliderBackWidth * value_percentage
            el.LeftFill.Position = {sliderBackX, currentElementY + 8}; el.LeftFill.Size = {nubX - sliderBackX, 2}; el.Nub.Position = {nubX, currentElementY + 9}
            
            local borderColor = el.IsEditing and theme.Colors.Accent or theme.Colors.Separator
            self:_AnimateAndApplyColor(el.ValueInputBg, theme.Colors.DarkBlue, masterOpacity)
            self:_AnimateAndApplyColor(el.ValueInputBorder, borderColor, masterOpacity)
            self:_AnimateAndApplyColor(el.ValueInputCursor, theme.Colors.Accent, masterOpacity)

            el.ValueText.Text = el.IsEditing and el.InputText or tostring(math.floor(self.UI.Values[el.id] or el.Min))
            el.ValueText.Position = {valueBoxX + valueBoxW / 2, currentElementY - 4 + (valueBoxH / 2) - (el.ValueText.Size / 2)}
            self:_AnimateAndApplyColor(el.ValueText, theme.Colors.TextPrimary, masterOpacity)

            if el.ValueText.TextBounds and el.IsEditing then
                local cursorX = el.ValueText.Position.x + el.ValueText.TextBounds.x / 2 + 1
                local cursorY = el.ValueText.Position.y - 2
                el.ValueInputCursor.From = {cursorX, cursorY}
                el.ValueInputCursor.To = {cursorX, cursorY + el.ValueText.Size + 4}
            end

            local glowWidth = nubX - sliderBackX; local glowHeight = 6
            if glowWidth > 0 and el.Glow then
                self:_RenderGlowEffect(el.Glow, sliderBackX, currentElementY + 9 - (glowHeight / 2), glowWidth, glowHeight, el.LeftFill.Rounding, theme.Colors.GlowAccent, {top=true, bottom=true, left=true, right=false}, masterOpacity)
            elseif el.Glow then 
                self:_HideGlowEffect(el.Glow) 
            end

            self:_AnimateAndApplyColor(el.Back, theme.Colors.DarkBlue, masterOpacity); self:_AnimateAndApplyColor(el.LeftFill, theme.Colors.Accent, masterOpacity); self:_AnimateAndApplyColor(el.Nub, theme.Colors.Accent, masterOpacity)
            elementY_offset = elementY_offset + 35
        elseif el.type == "Dropdown" or el.type == "Multidropdown" then
            self:_SetVisibility(el.Button, true); self:_SetVisibility(el.ButtonText, true); self:_SetVisibility(el.ArrowLine1, true); self:_SetVisibility(el.ArrowLine2, true)
            local currentElementY = animatedY + elementY_offset; self:_AnimateAndApplyColor(el.Label, theme.Colors.TextSecondary, masterOpacity); el.Label.Position = {sectionX + 10, currentElementY + 5}
            local dropdownButtonX, dropdownButtonY = sectionX + columnWidth - el.Size.width - 15, currentElementY; el.Button.Position = {dropdownButtonX, dropdownButtonY}; el.Button.Size = {el.Size.width, el.Size.height}
            local textToShow = (el.type == "Dropdown") and self.UI.Values[el.id] or (#self.UI.Values[el.id] == 0 and "..." or table.concat(self.UI.Values[el.id], ", ")); if #textToShow > 11 then textToShow = string.sub(textToShow, 1, 10) .. "..." end
            el.ButtonText.Position = { dropdownButtonX + 5, dropdownButtonY + el.Size.height / 2 - el.ButtonText.Size / 2 }; el.ButtonText.Text = textToShow
            local arrowX, arrowY = dropdownButtonX + el.Size.width - 15, dropdownButtonY + el.Size.height / 2; el.ArrowLine1.From = {arrowX, arrowY - 2}; el.ArrowLine1.To = {arrowX + 5, arrowY + 3}; el.ArrowLine2.From = {arrowX + 5, arrowY + 3}; el.ArrowLine2.To = {arrowX + 10, arrowY - 2}
            el.ClickRegion = { x1 = dropdownButtonX, y1 = dropdownButtonY, x2 = dropdownButtonX + el.Size.width, y2 = dropdownButtonY + el.Size.height }
            self:_AnimateAndApplyColor(el.Button, theme.Colors.DarkBlue, masterOpacity); self:_AnimateAndApplyColor(el.ButtonText, theme.Colors.TextPrimary, masterOpacity); self:_AnimateAndApplyColor(el.ArrowLine1, theme.Colors.TextPrimary, masterOpacity); self:_AnimateAndApplyColor(el.ArrowLine2, theme.Colors.TextPrimary, masterOpacity)
            elementY_offset = elementY_offset + 35
            if el.IsOpen or el.IsClosing then
                local speed_value = self.UI.Values["AboutAnimationSpeed"] or 2.4; local animationSpeed = (speed_value / 1.5) / 10.0
                
                -- [[ ИСПРАВЛЕНИЕ: Используем правильный ID "BurgerLow-EndMode" ]]
                if self.UI.Values["BurgerLow-EndMode"] then
                    el.FadeOpacity = (el.IsOpen and not el.IsClosing) and 1 or 0
                    if el.FadeOpacity == 0 then el.IsClosing = false end
                else
                    if el.IsOpen and not el.IsClosing then el.FadeOpacity = math.min(1, el.FadeOpacity + animationSpeed) elseif el.IsClosing then el.FadeOpacity = math.max(0, el.FadeOpacity - animationSpeed); if el.FadeOpacity == 0 then el.IsClosing = false end end
                end

                if el.FadeOpacity > 0 then
                    local finalOpacity = masterOpacity * el.FadeOpacity; local popupWidth = 150; local optionHeight = 25; local popupHeight = (#el.Options * optionHeight) + 10
                    local popupX = dropdownButtonX + (el.Size.width / 2) - (popupWidth / 2); local popupY = dropdownButtonY + (el.Size.height / 2) - (popupHeight / 2)
                    el.PopupClickRegion = {x1 = popupX, y1 = popupY, x2 = popupX + popupWidth, y2 = popupY + popupHeight}
                    self:_SetVisibility(el.OptionBackground, true); self:_SetVisibility(el.Border, true)
                    self:_AnimateAndApplyColor(el.OptionBackground, theme.Colors.SectionBackground, finalOpacity); self:_AnimateAndApplyColor(el.Border, theme.Colors.Separator, finalOpacity)
                    el.OptionBackground.Position = {popupX, popupY}; el.OptionBackground.Size = {popupWidth, popupHeight}; el.Border.Position = {popupX, popupY}; el.Border.Size = {popupWidth, popupHeight}
                    
                    if not self.UI.Values["BurgerLow-EndMode"] then
                        local glowFinalOpacity = 0
                        if el.IsOpen and not el.IsClosing then local threshold = 0.5; if el.FadeOpacity > threshold then local glowProgress = (el.FadeOpacity - threshold) / (1.0 - threshold); glowFinalOpacity = masterOpacity * glowProgress end elseif el.IsClosing then glowFinalOpacity = masterOpacity * (el.FadeOpacity * el.FadeOpacity) end
                        self:_RenderGlowEffect(el.Glow, popupX, popupY, popupWidth, popupHeight, el.OptionBackground.Rounding, theme.Colors.GlowColor, nil, glowFinalOpacity)
                    else
                        self:_HideGlowEffect(el.Glow)
                    end

                    local currentOptionY = popupY + 5; local hasSelection = el.type == "Multidropdown" and #self.UI.Values[el.id] > 0; local textX = popupX + (hasSelection and 25 or 10)
                    for i, option in ipairs(el.OptionList) do
                        self:_SetVisibility(option.Text, true); self:_SetVisibility(option.Highlight, true)
                        option.ClickRegion = {x1 = popupX, y1 = currentOptionY, x2 = popupX + popupWidth, y2 = currentOptionY + optionHeight}; option.Text.Position = {textX, currentOptionY + (optionHeight / 2) - (option.Text.Size / 2)}; option.Highlight.Position = {popupX + 5, currentOptionY}; option.Highlight.Size = {popupWidth - 10, optionHeight}
                        local isSelected = (el.type == "Dropdown" and self.UI.Values[el.id] == el.Options[i]) or (el.type == "Multidropdown" and table.find(self.UI.Values[el.id], el.Options[i])); local isHovered = (el.HoveredOptionIndex == i)
                        local targetTextColor = isSelected and theme.Colors.Accent or theme.Colors.TextPrimary; self:_AnimateAndApplyColor(option.Text, targetTextColor, finalOpacity)
                        if isHovered then local highlightColor = theme.Colors.Separator; self:_AnimateAndApplyColor(option.Highlight, highlightColor, finalOpacity * 0.4) else option.Highlight.Opacity = 0 end
                        if el.type == "Multidropdown" then
                            self:_SetVisibility(option.CheckmarkLine1, isSelected); self:_SetVisibility(option.CheckmarkLine2, isSelected)
                            if isSelected then local checkY = currentOptionY + (optionHeight / 2); option.CheckmarkLine1.From = {popupX + 8, checkY}; option.CheckmarkLine1.To = {popupX + 11, checkY + 3}; option.CheckmarkLine2.From = {popupX + 11, checkY + 3}; option.CheckmarkLine2.To = {popupX + 15, checkY - 4}; self:_AnimateAndApplyColor(option.CheckmarkLine1, theme.Colors.Accent, finalOpacity); self:_AnimateAndApplyColor(option.CheckmarkLine2, theme.Colors.Accent, finalOpacity) end
                        end
                        currentOptionY = currentOptionY + optionHeight
                    end
                end
            else
                el.PopupClickRegion = nil
                self:_HideGlowEffect(el.Glow); self:_SetVisibility(el.OptionBackground, false); self:_SetVisibility(el.Border, false)
                for _, option in ipairs(el.OptionList) do self:_SetVisibility(option.Text, false); self:_SetVisibility(option.Highlight, false); if el.type == "Multidropdown" then self:_SetVisibility(option.CheckmarkLine1, false); self:_SetVisibility(option.CheckmarkLine2, false) end end
            end
        end
    end

    local sectionHeight = elementY_offset - ((separatorY_abs - animatedY) + 15) + 45
    if #section.Elements > 0 then local lastElement = section.Elements[#section.Elements]; if lastElement.type == "Dropdown" or lastElement.type == "Multidropdown" or lastElement.type == "Keybind" then sectionHeight = sectionHeight + 13 end end
    sDrawing.Background.Size = {columnWidth, sectionHeight}; sDrawing.Border.Size = {columnWidth, sectionHeight}
    return sectionHeight
end


function Library:_RenderSections(panelX, panelY, headerHeight)
    local leftColumnY, rightColumnY = panelY + headerHeight + 20, panelY + headerHeight + 20
    local columnSpacing = 20
    local columnWidth = ((self.Window.Width - self.Window.SidebarWidth + self.Window.PanelOverlap) - (columnSpacing * 3)) / 2
    local leftColumnX, rightColumnX = panelX + columnSpacing, panelX + columnSpacing + columnWidth + columnSpacing
    
    -- === Главный цикл рендера секций ===
    for _, section in ipairs(self.UI.Sections) do
        -- Получаем заранее рассчитанное состояние анимации 
        local anim_state = self.AnimationState[section.Drawing.Background]
        if not anim_state then
            anim_state = { Opacity = 0, YOffset = 0, IsVisible = false }
            self.AnimationState[section.Drawing.Background] = anim_state
        end

        local is_on_active_tab = (section.ParentTab == self.Window.ActiveTab)
        local is_on_old_tab = (self.Window.Animation.State == "FADING_OUT" and section.ParentTab == self.Window.Animation.OldTab)

        -- Если секция должна быть видимой (на текущей или исчезающей вкладке) 
        if (is_on_active_tab and self.Window.Animation.State ~= "FADING_OUT") or is_on_old_tab then
             if not anim_state.IsVisible then self:_SetSectionAndElementsVisibility(section, true); anim_state.IsVisible = true; end

            local sectionX, sectionY
            if section.Side == "Left" then sectionX, sectionY = leftColumnX, leftColumnY
            else sectionX, sectionY = rightColumnX, rightColumnY end
            
            -- Отрисовываем секцию с текущими параметрами анимации 
            local sectionHeight = self:_RenderSingleSection(section, sectionX, sectionY, columnWidth, anim_state.YOffset, anim_state.Opacity)
            
            -- Запоминаем последнюю позицию для плавного исчезновения 
            section.LastPos = { X = sectionX, Y = sectionY } 

            if section.Side == "Left" then leftColumnY = leftColumnY + sectionHeight + columnSpacing
            else rightColumnY = rightColumnY + sectionHeight + columnSpacing end
        
        -- Если секция не должна быть видна, скрываем её 
        elseif anim_state.IsVisible then
            self:_SetSectionAndElementsVisibility(section, false)
            anim_state.IsVisible = false
        end
    end
end

function Library:_RenderConfigsTab(panelX, panelY, headerHeight)
    local configs = self.UI.Core.ConfigsTab
    local theme = self.ActiveTheme

    local startX = panelX + 20
    local startY = panelY + headerHeight + 20
    local contentWidth = (self.Window.Width - self.Window.SidebarWidth + self.Window.PanelOverlap) - 40
    local scrollbarWidth = 6
    local contentAreaWidth = contentWidth - scrollbarWidth - 10
    
    local itemHeight = 60
    local itemSpacing = 10
    local totalItemHeight = itemHeight + itemSpacing
    local MAX_VISIBLE_ITEMS = 7

    local verticalPadding = 35 
    local fullRenderAreaY = startY + 25
    local fullRenderAreaHeight = (MAX_VISIBLE_ITEMS * totalItemHeight) - itemSpacing
    local clippingAreaY = fullRenderAreaY + verticalPadding
    local clippingAreaHeight = fullRenderAreaHeight - (verticalPadding * 2)
    local totalContentHeight = (#configs.Items * totalItemHeight) - itemSpacing
    local needsScrollbar = totalContentHeight > fullRenderAreaHeight

    self:_SetVisibility(configs.Scrollbar.Background, needsScrollbar)
    self:_SetVisibility(configs.Scrollbar.Nub, needsScrollbar)
    self:_AnimateAndApplyColor(configs.MyItemsLabel, theme.Colors.TextPrimary)
    configs.MyItemsLabel.Position = {startX, startY}

    if needsScrollbar then
        local scrollbarX = startX + contentAreaWidth + 5
        local minNubHeight = 30 
        configs.Scrollbar.Background.Position = {scrollbarX, fullRenderAreaY}
        configs.Scrollbar.Background.Size = {scrollbarWidth, fullRenderAreaHeight}
        self:_AnimateAndApplyColor(configs.Scrollbar.Background, theme.Colors.DarkBlue)
        local nubHeight = (totalContentHeight > 0) and math.max(minNubHeight, fullRenderAreaHeight * (fullRenderAreaHeight / totalContentHeight)) or minNubHeight
        local maxScrollOffset = totalContentHeight - fullRenderAreaHeight
        local scrollPercentage = (maxScrollOffset > 0) and (configs.Scrollbar.ScrollOffset / maxScrollOffset) or 0
        local nubY = fullRenderAreaY + ((fullRenderAreaHeight - nubHeight) * scrollPercentage)
        configs.Scrollbar.Nub.Position = {scrollbarX, nubY}
        configs.Scrollbar.Nub.Size = {scrollbarWidth, nubHeight}
        self:_AnimateAndApplyColor(configs.Scrollbar.Nub, theme.Colors.Accent)
        configs.Scrollbar.NubClickRegion = { x1 = scrollbarX, y1 = nubY, x2 = scrollbarX + scrollbarWidth, y2 = nubY + nubHeight }
    end

    local speed_value = self.UI.Values["AboutAnimationSpeed"] or 2.4
    local animationSpeed = (speed_value > 0) and (speed_value / 15.0) or 1

    local loopStartY = fullRenderAreaY
    for i, item in ipairs(configs.Items) do
        -- Рассчитываем "идеальную" позицию на основе скролла
        local itemY = (loopStartY + (i - 1) * totalItemHeight) - configs.Scrollbar.ScrollOffset
        
        local isVisible = (itemY + itemHeight > clippingAreaY) and (itemY < clippingAreaY + clippingAreaHeight)
        local targetOpacity = isVisible and 1.0 or 0.0

        item.Animation.CurrentOpacity = item.Animation.CurrentOpacity + (targetOpacity - item.Animation.CurrentOpacity) * animationSpeed
        if math.abs(item.Animation.CurrentOpacity - targetOpacity) < 0.01 then
            item.Animation.CurrentOpacity = targetOpacity
        end

        -- [[ ГЛАВНОЕ ИЗМЕНЕНИЕ ЗДЕСЬ ]]
        -- 1. Определяем, какую Y-координату использовать для отрисовки.
        local renderY
        if isVisible then
            -- Если элемент видим, используем его текущую позицию и сохраняем её.
            renderY = itemY
            item.Animation.LastVisibleY = itemY
        else
            -- Если элемент не видим (исчезает), используем последнюю сохраненную позицию.
            renderY = item.Animation.LastVisibleY
        end

        if item.Animation.CurrentOpacity > 0 then
            local d = item.Drawing
            local isLoaded = (configs.LoadedConfigName == item.Name)
            local masterOpacity = item.Animation.CurrentOpacity

            self:_SetDrawingTableVisibility(d, true)

            -- 2. Используем `renderY` для позиционирования ВСЕХ объектов конфига.
            self:_AnimateAndApplyColor(d.Background, theme.Colors.SectionBackground, masterOpacity)
            self:_AnimateAndApplyColor(d.Border, theme.Colors.Separator, masterOpacity)
            self:_AnimateAndApplyColor(d.Name, theme.Colors.TextPrimary, masterOpacity)
            self:_AnimateAndApplyColor(d.Modified, theme.Colors.TextSecondary, masterOpacity)
            self:_AnimateAndApplyColor(d.Author, theme.Colors.TextSecondary, masterOpacity)
            self:_AnimateAndApplyColor(d.OptionsButton.Dot1, theme.Colors.TextSecondary, masterOpacity)
            self:_AnimateAndApplyColor(d.OptionsButton.Dot2, theme.Colors.TextSecondary, masterOpacity)
            self:_AnimateAndApplyColor(d.OptionsButton.Dot3, theme.Colors.TextSecondary, masterOpacity)
            
            d.Background.Position = {startX, renderY}; d.Background.Size = {contentAreaWidth, itemHeight}
            d.Border.Position = {startX, renderY}; d.Border.Size = {contentAreaWidth, itemHeight}
            d.Name.Text = item.Name; d.Name.Position = {startX + 15, renderY + 12}
            d.Modified.Text = "Modified: " .. "N/A"; d.Modified.Position = {startX + 15, renderY + 35}
            if d.Modified.TextBounds and d.Modified.TextBounds.x then
                d.Author.Text = "Author: " .. item.Author
                d.Author.Position = {startX + 15 + d.Modified.TextBounds.x + 10, renderY + 35}
            end
            local btnWidth, btnHeight = 85, 28
            local btnX = startX + contentAreaWidth - btnWidth - 15
            local btnY = renderY + (itemHeight / 2) - (btnHeight / 2)
            local optionsBtnX = btnX - 25; local optionsBtnY = renderY + (itemHeight / 2)
            d.OptionsButton.Dot1.Position = {optionsBtnX - 6, optionsBtnY}; d.OptionsButton.Dot2.Position = {optionsBtnX, optionsBtnY}; d.OptionsButton.Dot3.Position = {optionsBtnX + 6, optionsBtnY}
            d.OptionsButton.ClickRegion = {x1 = optionsBtnX - 10, y1 = optionsBtnY - 10, x2 = optionsBtnX + 10, y2 = optionsBtnY + 10}
            
            if isLoaded then
                self:_SetVisibility(d.SaveButton.Background, true); self:_SetVisibility(d.SaveButton.Border, true); self:_SetVisibility(d.SaveButton.Icon, true); self:_SetVisibility(d.SaveButton.Label, true)
                self:_SetVisibility(d.LoadButton.Background, false); self:_SetVisibility(d.LoadButton.Icon, false); self:_SetVisibility(d.LoadButton.Label, false)
                local saveBtn = d.SaveButton
                self:_AnimateAndApplyColor(saveBtn.Background, theme.Colors.SectionBackground, masterOpacity); self:_AnimateAndApplyColor(saveBtn.Border, theme.Colors.Accent, masterOpacity); self:_AnimateAndApplyColor(saveBtn.Icon, theme.Colors.TextPrimary, masterOpacity); self:_AnimateAndApplyColor(saveBtn.Label, theme.Colors.TextPrimary, masterOpacity)
                saveBtn.Background.Position = {btnX, btnY}; saveBtn.Background.Size = {btnWidth, btnHeight}; saveBtn.Border.Position = {btnX, btnY}; saveBtn.Border.Size = {btnWidth, btnHeight}
                local iconX = btnX + 15
                saveBtn.Icon.Position = {iconX, btnY + (btnHeight / 2) - (saveBtn.Icon.Size.y / 2)}; saveBtn.Label.Position = {iconX + saveBtn.Icon.Size.x + 8, btnY + (btnHeight / 2) - (saveBtn.Label.Size / 2)}; saveBtn.ClickRegion = {x1 = btnX, y1 = btnY, x2 = btnX + btnWidth, y2 = btnY + btnHeight}
            else
                self:_SetVisibility(d.SaveButton.Background, false); self:_SetVisibility(d.SaveButton.Border, false); self:_SetVisibility(d.SaveButton.Icon, false); self:_SetVisibility(d.SaveButton.Label, false)
                self:_SetVisibility(d.LoadButton.Background, true); self:_SetVisibility(d.LoadButton.Icon, true); self:_SetVisibility(d.LoadButton.Label, true)
                local loadBtn = d.LoadButton
                local accentColor = theme.Colors.Accent
                local textColorForAccent = self:_GetTextColorForBackground(accentColor)
                self:_AnimateAndApplyColor(loadBtn.Background, accentColor, masterOpacity); self:_AnimateAndApplyColor(loadBtn.Icon, textColorForAccent, masterOpacity); self:_AnimateAndApplyColor(loadBtn.Label, textColorForAccent, masterOpacity)
                loadBtn.Background.Position = {btnX, btnY}; loadBtn.Background.Size = {btnWidth, btnHeight}
                local iconX = btnX + 15
                loadBtn.Icon.Position = {iconX, btnY + (btnHeight / 2) - (loadBtn.Icon.Size.y / 2)}; loadBtn.Label.Position = {iconX + loadBtn.Icon.Size.x + 8, btnY + (btnHeight / 2) - (loadBtn.Label.Size / 2)}; loadBtn.ClickRegion = {x1 = btnX, y1 = btnY, x2 = btnX + btnWidth, y2 = btnY + btnHeight}
            end
        else
            self:_SetDrawingTableVisibility(item.Drawing, false)
        end
    end
end

function Library:_RenderConfigOptionsPopup()
    local configs = self.UI.Core.ConfigsTab
    local popup = configs.OptionsPopup
    local theme = self.ActiveTheme
    local isThemeLight = self:_IsThemeLight(theme)

    -- [[ ИЗМЕНЕНИЕ: Управляем видимостью через анимацию ]]
    local masterOpacity = popup.Animation.CurrentOpacity
    if masterOpacity <= 0 then
        self:_SetDrawingTableVisibility(popup, false)
        self:_HideGlowEffect(popup.Glow)
        return
    end

    self:_SetDrawingTableVisibility(popup, true)

    self:_AnimateAndApplyColor(popup.Background, theme.Colors.SectionBackground, masterOpacity)
    self:_AnimateAndApplyColor(popup.Border, theme.Colors.Separator, masterOpacity)
    self:_AnimateAndApplyColor(popup.IncludeStyleToggle.Label, theme.Colors.TextSecondary, masterOpacity)
    self:_AnimateAndApplyColor(popup.Separator, theme.Colors.Separator, masterOpacity)

    -- [[ НОВОЕ: Расчет позиций и размеров ]]
    local pW = 160
    local pX, pY = popup.Pos.x, popup.Pos.y
    local currentY = pY + 10

    -- Рендеринг "Include Style"
    local toggle = popup.IncludeStyleToggle
    toggle.Label.Position = {pX + 10, currentY + 3}
    local toggleBackX = pX + pW - toggle.Size.width - 15
    toggle.Back.Position = {toggleBackX, currentY};
    toggle.Back.Size = {toggle.Size.width, toggle.Size.height};
    toggle.ClickRegion = {x1 = toggleBackX, y1 = currentY, x2 = toggleBackX + toggle.Size.width, y2 = currentY + toggle.Size.height}
    
    local is_on = self.UI.Values[toggle.id]
    local nubY = currentY + toggle.Size.height / 2
    local targetBackColor, targetNubColor
    if is_on then
        if isThemeLight then
            targetBackColor = theme.Colors.Accent
            targetNubColor = theme.Colors.SectionBackground
        else
            targetBackColor = self:_DarkenColor(theme.Colors.Accent, 0.3)
            targetNubColor = theme.Colors.Accent
        end
    else
        targetBackColor = theme.Colors.DarkGray
        targetNubColor = theme.Colors.LightGray
    end
    
    local speed_value = self.UI.Values["AboutAnimationSpeed"] or 2.5
    local animationSpeed = speed_value / 10.0
    local targetOffset = is_on and (toggle.Size.width - toggle.Size.height / 2) or (toggle.Size.height / 2)
    toggle.AnimatedNubOffset = toggle.AnimatedNubOffset + (targetOffset - toggle.AnimatedNubOffset) * animationSpeed
    toggle.Nub.Position = {toggleBackX + toggle.AnimatedNubOffset, nubY}
    
    self:_AnimateAndApplyColor(toggle.Back, targetBackColor, masterOpacity)
    self:_AnimateAndApplyColor(toggle.Nub, targetNubColor, masterOpacity)

    currentY = currentY + toggle.Size.height + 10

    -- Рендеринг разделителя
    popup.Separator.From = {pX + 10, currentY}
    popup.Separator.To = {pX + pW - 10, currentY}
    
    currentY = currentY + 10

    -- Рендеринг кнопки "Delete"
    local delBtn = popup.DeleteButton
    local btnW, btnH = pW - 20, 28
    local btnX, btnY = pX + 10, currentY

    -- Обновляем IsHovered флаг в реальном времени
    local mouse_pos = getmouseposition()
    if mouse_pos then
        delBtn.IsHovered = self:_IsPointInRegion(mouse_pos.x, mouse_pos.y, delBtn.ClickRegion)
    end

    delBtn.ClickRegion = {x1 = btnX, y1 = btnY, x2 = btnX + btnW, y2 = btnY + btnH}

    -- Прячем рамку, она больше не нужна
    self:_SetVisibility(delBtn.Border, false)

    -- Определяем цвета
    local deleteColor = {165, 88, 92, 255} -- Цвет для иконки и текста
    local deleteHoverColor = {165, 88, 92, 50} -- Полупрозрачный красный для фона при наведении
    local transparentColor = {0, 0, 0, 0} -- Полностью прозрачный фон по умолчанию

    -- Выбираем цвет фона в зависимости от наведения
    local targetBackgroundColor = delBtn.IsHovered and deleteHoverColor or transparentColor

    -- Применяем цвета к элементам
    self:_AnimateAndApplyColor(delBtn.Background, targetBackgroundColor, masterOpacity)
    self:_AnimateAndApplyColor(delBtn.Label, deleteColor, masterOpacity)
    self:_AnimateAndApplyColor(delBtn.Icon, deleteColor, masterOpacity)

-- Размещаем фон, иконку и текст
delBtn.Background.Position = {btnX, btnY}
delBtn.Background.Size = {btnW, btnH}
delBtn.Background.Rounding = self.ActiveTheme.Rounding.Button

-- Новая логика для выравнивания по левому краю с отступом
local iconX = btnX + 3 -- Отступ в 10 пикселей слева
delBtn.Icon.Position = {iconX, btnY + (btnH / 2) - (delBtn.Icon.Size.y / 2)}
delBtn.Label.Position = {iconX + delBtn.Icon.Size.x + 5, btnY + (btnH / 2) - (delBtn.Label.Size / 2)}

    currentY = currentY + btnH + 10
    
    -- Финальный расчет размера попапа
    local pH = currentY - pY
    popup.ClickRegion = {x1=pX, y1=pY, x2=pX+pW, y2=pY+pH}
    popup.Background.Position = {pX, pY}; popup.Background.Size = {pW, pH}
    popup.Border.Position = {pX, pY}; popup.Border.Size = {pW, pH}
    self:_RenderGlowEffect(popup.Glow, pX, pY, pW, pH, popup.Background.Rounding, theme.Colors.GlowColor, nil, masterOpacity)
end


function Library:_RenderWatermark()
    local wm = self.UI.Watermark
    local anim = wm.Animation
    local isVisible = self.UI.Values["BurgerWatermark"]

    if isVisible and anim.CurrentOpacity < 1 and not anim.IsOpening then
        anim.IsOpening = true; anim.IsClosing = false
    elseif not isVisible and anim.CurrentOpacity > 0 and not anim.IsClosing then
        anim.IsOpening = false; anim.IsClosing = true
    end
    self:_UpdatePopupAnimation(wm)

    local masterOpacity = anim.CurrentOpacity
    if masterOpacity <= 0 then
        self:_SetDrawingTableVisibility(wm, false)
        return
    end
    
    self:_SetDrawingTableVisibility(wm, true)

    local theme = self.ActiveTheme
    local isThemeLight = self:_IsThemeLight(theme)
    local bgColor = theme.Colors.WatermarkBackground or theme.Colors.MainBackground
    local accentColor = theme.Colors.Accent
    local textColor = theme.Colors.TextPrimary

    self:_SetVisibility(wm.LogoText2, not isThemeLight)
    self:_SetVisibility(wm.LogoText3, not isThemeLight)

    wm.Items.Player.Text.Text = self.UI.Core.PlayerDisplayName.Text or "player"
    wm.Items.Config.Text.Text = self.UI.Core.ConfigsTab.LoadedConfigName or "default"
    wm.Items.Ping.Text.Text = string.format("%.2f ms", getping() or 0)
    wm.Items.Fps.Text.Text = tostring(get_overlay_fps() or 0) .. " fps"

    self:_AnimateAndApplyColor(wm.LogoBg, bgColor, masterOpacity, true)
    self:_AnimateAndApplyColor(wm.InfoBg, bgColor, masterOpacity, true)
    
    self:_AnimateAndApplyColor(wm.LogoText1, textColor, masterOpacity, true)
    self:_AnimateAndApplyColor(wm.LogoText2, accentColor, masterOpacity, true)
    self:_AnimateAndApplyColor(wm.LogoText3, self:_DarkenColor(accentColor, 0.3), masterOpacity, true)
    
    for _, item in pairs(wm.Items) do
        self:_AnimateAndApplyColor(item.Icon, accentColor, masterOpacity, true)
        self:_AnimateAndApplyColor(item.Text, textColor, masterOpacity, true)
    end

    local height = 40
    local logoWidth = 50
    local separatorWidth = 10
    local horizontalPadding = 17
    
    local currentX = wm.Position.x
    
    wm.LogoBg.Position = {currentX, wm.Position.y}; wm.LogoBg.Size = {logoWidth, height}
    local logoBaseX = currentX + logoWidth/2
    local logoBaseY = wm.Position.y + height/2 - wm.LogoText1.Size/2
    
    wm.LogoText1.Position = {logoBaseX, logoBaseY}
    wm.LogoText2.Position = {logoBaseX - 2, logoBaseY + 1}
    wm.LogoText3.Position = {logoBaseX - 3, logoBaseY - 1}
    
    currentX = currentX + logoWidth + separatorWidth
    
    local infoBgX = currentX
    local contentStartX = infoBgX + horizontalPadding
    currentX = contentStartX
    
    local order = {"Player", "Config", "Ping", "Fps"}
    for i, name in ipairs(order) do
        local item = wm.Items[name]
        if item.Icon.Visible then
            item.Icon.Position = {currentX, wm.Position.y + height/2 - item.Icon.Size.y/2}
            currentX = currentX + item.Icon.Size.x + 8
        end
        if item.Text.Visible and item.Text.TextBounds then
            item.Text.Position = {currentX, wm.Position.y + height/2 - item.Text.Size/2}
            currentX = currentX + item.Text.TextBounds.x + horizontalPadding
        end
    end
    
    local contentWidth = currentX - contentStartX - horizontalPadding
    local totalInfoWidth = contentWidth + (2 * horizontalPadding)
    
    wm.InfoBg.Position = {infoBgX, wm.Position.y}; wm.InfoBg.Size = {totalInfoWidth, height}

    local totalWidth = logoWidth + separatorWidth + totalInfoWidth
    wm.DragArea.Position = wm.Position; wm.DragArea.Size = {totalWidth, height}
end

function Library:_RenderHotkeys()
    local hk = self.UI.Hotkeys
    local anim = hk.Animation
    local isVisible = self.UI.Values["BurgerHotkeys"]

    if isVisible and anim.CurrentOpacity < 1 and not anim.IsOpening then
        anim.IsOpening = true; anim.IsClosing = false
    elseif not isVisible and anim.CurrentOpacity > 0 and not anim.IsClosing then
        anim.IsOpening = false; anim.IsClosing = true
    end
    self:_UpdatePopupAnimation(hk)
    
    local masterOpacity = anim.CurrentOpacity
    if masterOpacity <= 0 then
        self:_SetDrawingTableVisibility(hk.Title, false)
        for _, bind in ipairs(hk.ActiveBinds) do
            if bind.Drawing then self:_SetDrawingTableVisibility(bind.Drawing, false) end
        end
        return
    end

    self:_SetDrawingTableVisibility(hk.Title, true)

    local theme = self.ActiveTheme
    local isThemeLight = self:_IsThemeLight(theme)
    local z = 110

    local titleHeight = 36
    local titleWidth = 160 
    hk.Title.Background.Position = hk.Position
    hk.Title.Background.Size = {titleWidth, titleHeight}
    self:_AnimateAndApplyColor(hk.Title.Background, theme.Colors.HotkeysBackground, masterOpacity, true)

    hk.Title.Icon.Position = {hk.Position.x + 10, hk.Position.y + titleHeight/2 - hk.Title.Icon.Size.y/2}
    self:_AnimateAndApplyColor(hk.Title.Icon, theme.Colors.TextPrimary, masterOpacity, true)

    local sepX = hk.Position.x + 42
    hk.Title.Separator.From = {sepX, hk.Position.y + 8}
    hk.Title.Separator.To = {sepX, hk.Position.y + titleHeight - 8}
    self:_AnimateAndApplyColor(hk.Title.Separator, theme.Colors.Separator, masterOpacity, true)

    hk.Title.Text.Position = {sepX + 12, hk.Position.y + titleHeight/2 - hk.Title.Text.Size/2}
    self:_AnimateAndApplyColor(hk.Title.Text, theme.Colors.TextPrimary, masterOpacity, true)

    local currentY = hk.Position.y + titleHeight + 8
    local bindsToRemove = {}

    for i, bind in ipairs(hk.ActiveBinds) do
        if not bind.Drawing then
            bind.Drawing = {
                ToggleContainerBg = self:_CreateDrawingObject("Square"),
                ToggleTrack = self:_CreateDrawingObject("Square"),
                ToggleNub = self:_CreateDrawingObject("Circle"),
                NameBg = self:_CreateDrawingObject("Square"),
                NameText = self:_CreateDrawingObject("Text")
            }
            local d = bind.Drawing
            if d.ToggleContainerBg then d.ToggleContainerBg.Filled = true; d.ToggleContainerBg.zIndex = z; d.ToggleContainerBg.Rounding = 10; end
            if d.ToggleTrack then d.ToggleTrack.Filled = false; d.ToggleTrack.Thickness = 2; d.ToggleTrack.zIndex = z + 1; end
            if d.ToggleNub then d.ToggleNub.Filled = true; d.ToggleNub.zIndex = z + 2; end
            if d.NameBg then d.NameBg.Filled = true; d.NameBg.zIndex = z; d.NameBg.Rounding = 10; end
            if d.NameText then d.NameText.Font = self.ActiveTheme.Fonts.Main; d.NameText.Size = self.ActiveTheme.Fonts.Size; d.NameText.Text = bind.Name; d.NameText.zIndex = z + 1; end
        end
        
        local speed_value = self.UI.Values["AboutAnimationSpeed"] or 2.4
        local animationSpeed = (speed_value / 1.5) / 10.0
        if bind.IsClosing then
            bind.FadeOpacity = bind.FadeOpacity - animationSpeed
            if bind.FadeOpacity <= 0 then table.insert(bindsToRemove, i) end
        else
            bind.FadeOpacity = math.min(1, bind.FadeOpacity + animationSpeed)
        end

        local finalOpacity = masterOpacity * bind.FadeOpacity
        self:_SetDrawingTableVisibility(bind.Drawing, finalOpacity > 0)
        
        local toggleIndicatorColor = isThemeLight and theme.Colors.TextDark or theme.Colors.TextLight
        local semiTransparentBg = {theme.Colors.SectionBackground[1], theme.Colors.SectionBackground[2], theme.Colors.SectionBackground[3], 255 * 0.2}

        self:_AnimateAndApplyColor(bind.Drawing.ToggleContainerBg, semiTransparentBg, finalOpacity, true)
        self:_AnimateAndApplyColor(bind.Drawing.ToggleTrack, toggleIndicatorColor, finalOpacity, true)
        self:_AnimateAndApplyColor(bind.Drawing.ToggleNub, toggleIndicatorColor, finalOpacity, true)
        self:_AnimateAndApplyColor(bind.Drawing.NameBg, semiTransparentBg, finalOpacity, true)
        self:_AnimateAndApplyColor(bind.Drawing.NameText, theme.Colors.TextPrimary, finalOpacity, true)

        local itemHeight = 30
        local toggleContainerWidth = 45
        local nameWidth = (bind.Drawing.NameText.TextBounds and bind.Drawing.NameText.TextBounds.x or 80) + 20

        local d = bind.Drawing
        d.ToggleContainerBg.Position = {hk.Position.x, currentY}; d.ToggleContainerBg.Size = {toggleContainerWidth, itemHeight}
        
        local trackHeight = 14
        local trackWidth = 24
        d.ToggleTrack.Rounding = (trackHeight / 2) + 9 
        d.ToggleTrack.Position = {hk.Position.x + (toggleContainerWidth - trackWidth)/2, currentY + (itemHeight - trackHeight)/2}
        d.ToggleTrack.Size = {trackWidth, trackHeight}
        
        d.ToggleNub.Radius = 4 
        d.ToggleNub.Position = {d.ToggleTrack.Position.x + trackWidth - d.ToggleNub.Radius - 3, d.ToggleTrack.Position.y + trackHeight/2}
        
        d.NameBg.Position = {hk.Position.x + toggleContainerWidth + 5, currentY}; d.NameBg.Size = {nameWidth, itemHeight}
        d.NameText.Position = {hk.Position.x + toggleContainerWidth + 5 + 10, currentY + itemHeight/2 - d.NameText.Size/2}
        
        currentY = currentY + itemHeight + 5
    end

    for i = #bindsToRemove, 1, -1 do
        local index = bindsToRemove[i]
        if hk.ActiveBinds[index] and hk.ActiveBinds[index].Drawing then
            self:_CleanupDrawingObjects(hk.ActiveBinds[index].Drawing)
        end
        table.remove(hk.ActiveBinds, index)
    end
end

function Library:_InputLoop()
    self:_CheckGlobalBinds()

    if not self.Window.Visible and not self.UI.Values["BurgerWatermark"] and not self.UI.Values["BurgerHotkeys"] then
        return
    end

    local mouse_pos = getmouseposition()
    if not mouse_pos then return end

    local mouse_moved = (mouse_pos.x ~= lastMousePos.x or mouse_pos.y ~= lastMousePos.y)
    local is_left_pressed_now = isleftpressed()
    local is_left_clicked = was_left_pressed and not is_left_pressed_now
    local is_right_pressed_now = isrightpressed()
    local is_right_clicked = was_right_pressed and not is_right_pressed_now
    local key_pressed = (getpressedkey() ~= "None")

    -- Оптимизация: запускаем основную логику только если есть действие или активна анимация
    if mouse_moved or is_left_pressed_now or is_left_clicked or is_right_pressed_now or is_right_clicked or key_pressed or self:_UpdateAllAnimations() then

    lastMousePos = mouse_pos 

    local mouse_x, mouse_y = self:_SafeNumber(mouse_pos.x, 0), self:_SafeNumber(mouse_pos.y, 0)
    local is_press_started = is_left_pressed_now and not was_left_pressed

    local picker = self.UI.Popups.ColorPicker
    local style_window = self.UI.Popups.EditStyle
    local configsTab = self.UI.Core.ConfigsTab
    local about_window = self.UI.Core.AboutWindow
    local settings_popup = self.UI.Popups.Settings
    local burger_popup = self.UI.Popups.BurgerMenu
    local burger_button = self.UI.Core.HeaderButtons.BurgerMenu
    local wm = self.UI.Watermark
    local hk = self.UI.Hotkeys
    
    local function applySliderInput(slider)
        if not slider.IsEditing then return end
        local num = tonumber(slider.InputText)
        if num then
            num = math.clamp(num, slider.Min, slider.Max)
            if slider.Increment >= 1 then
                self.UI.Values[slider.id] = math.floor(num)
            else
                self.UI.Values[slider.id] = num
            end
            if slider.Callback then slider.Callback(self.UI.Values[slider.id]) end
        end
        slider.IsEditing = false
    end


    local function applyColorInput(picker)
        if not picker.IsEditing then return end
        picker.IsEditing = false
        local newColor

        if picker.Mode == "HEX" then
            local hex_input = picker.InputText:gsub("#", "")
            newColor = self:_HEXtoRGB("#" .. hex_input)
        else
            local nums = {}
            for num_str in string.gmatch(picker.InputText, "%d+") do
                local num = tonumber(num_str)
                if num then
                    table.insert(nums, math.clamp(num, 0, 255))
                end
            end
            if #nums > 0 then
                newColor = { nums[1] or 0, nums[2] or 0, nums[3] or 0, nums[4] or 255 }
            end
        end

        if newColor then
            picker.h, picker.s, picker.v, picker.a = self:_RGBtoHSV(newColor[1], newColor[2], newColor[3], newColor[4])
            if picker.EditingValueID then
                self.UI.Values[picker.EditingValueID] = newColor
            elseif picker.EditingColorName then
                style_window.EditingTheme.Colors[picker.EditingColorName] = newColor
                if self.UI.Values.EditStyleRealTime and self.TempTheme then self.TempTheme.Colors[picker.EditingColorName] = newColor end
            end
        end
    end

    local anyDropdownOpen = false
    local function updateHoverStates()
        picker.HoveredDropdownIndex = 0
        if picker.IsOpen and picker.Dropdown.IsOpen and picker.Dropdown.PopupClickRegion then
            for i, option in ipairs(picker.Dropdown.Options) do
                if self:_IsPointInRegion(mouse_x, mouse_y, option.ClickRegion) then
                    picker.HoveredDropdownIndex = i; return
                end
            end
        end

        for _, section in ipairs(self.UI.Sections) do
            if section.ParentTab == self.Window.ActiveTab then
                for _, el in ipairs(section.Elements) do
                    if (el.type == "Dropdown" or el.type == "Multidropdown") and el.IsOpen then
                        anyDropdownOpen = true
                        el.HoveredOptionIndex = 0
                        if el.PopupClickRegion then
                            for i, option in ipairs(el.OptionList) do
                                if self:_IsPointInRegion(mouse_x, mouse_y, option.ClickRegion) then
                                    el.HoveredOptionIndex = i; return
                                end
                            end
                        end
                    end
                end
            end
        end

        if burger_popup.IsOpen then
            burger_popup.HoveredItemIndex = 0
            for i, item in ipairs(burger_popup.Items) do
                if self:_IsPointInRegion(mouse_x, mouse_y, item.ClickRegion) then
                    burger_popup.HoveredItemIndex = i; return
                end
            end
        end

        if about_window.IsOpen then
            local is_hovering_any_circle = false
            for _, circle in ipairs(about_window.StyleCircles) do
                if self:_IsPointInRegion(mouse_x, mouse_y, circle.ClickRegion) then
                    is_hovering_any_circle = true
                    if about_window.HoveredThemeCircle.Name ~= circle.Name then
                        about_window.HoveredThemeCircle.Name = circle.Name
                        about_window.HoveredThemeCircle.HoverStartTime = tick()
                    end
                    return
                end
            end
            if not is_hovering_any_circle then about_window.HoveredThemeCircle.Name = nil end
        end
    end
    updateHoverStates()

    if is_press_started then
        is_dragging_something = false
        local started_drag = false

        -- [[ ИЗМЕНЕНИЕ ЗДЕСЬ ]]
        -- Проверяем, не тащим ли мы скроллбар во вкладке конфигов
        local scrollbar = configsTab.Scrollbar
        -- Проверяем, нужна ли вообще полоса прокрутки
        local itemHeight = 60; local itemSpacing = 10; local totalItemHeight = itemHeight + itemSpacing; local MAX_VISIBLE_ITEMS = 7
        local visibleAreaHeight = (MAX_VISIBLE_ITEMS * totalItemHeight) - itemSpacing
        local totalContentHeight = (#configsTab.Items * totalItemHeight) - itemSpacing
        local needsScrollbar = totalContentHeight > visibleAreaHeight

        if self.Window.ActiveTab == "Configs" and needsScrollbar and self:_IsPointInRegion(mouse_x, mouse_y, scrollbar.NubClickRegion) then
            scrollbar.IsDraggingNub = true
            scrollbar.DragStartMouseY = mouse_y
            scrollbar.DragStartOffset = scrollbar.ScrollOffset
            started_drag = true
        end
        -- [[ КОНЕЦ ИЗМЕНЕНИЯ ]]

        local wmDragRegion = {x1=wm.DragArea.Position.x, y1=wm.DragArea.Position.y, x2=wm.DragArea.Position.x+wm.DragArea.Size.x, y2=wm.DragArea.Position.y+wm.DragArea.Size.y}
        if self.UI.Values["BurgerWatermark"] and self:_IsPointInRegion(mouse_x, mouse_y, wmDragRegion) then
            wm.IsDragging = true; started_drag = true; wm.DragOffset = {x = mouse_x - wm.Position.x, y = mouse_y - wm.Position.y};
        end

        local hkDragRegion = {x1=hk.Title.Background.Position.x, y1=hk.Title.Background.Position.y, x2=hk.Title.Background.Position.x+hk.Title.Background.Size.x, y2=hk.Title.Background.Position.y+hk.Title.Background.Size.y}
        if not started_drag and self.UI.Values["BurgerHotkeys"] and self:_IsPointInRegion(mouse_x, mouse_y, hkDragRegion) then
            hk.IsDragging = true; started_drag = true; hk.DragOffset = {x = mouse_x - hk.Position.x, y = mouse_y - hk.Position.y};
        end
        
        if not started_drag then
            if about_window.IsOpen and self:_IsPointInRegion(mouse_x, mouse_y, about_window.AnimationSpeedSlider.ClickRegion) then
                about_window.AnimationSpeedSlider.IsDragging = true; started_drag = true;
            elseif picker.IsOpen and self:_IsPointInRegion(mouse_x, mouse_y, picker.HueSliderRegion) then
                picker.isDraggingHue = true; started_drag = true;
            elseif picker.IsOpen and self:_IsPointInRegion(mouse_x, mouse_y, picker.OpacitySliderRegion) then
                picker.isDraggingOpacity = true; started_drag = true;
            elseif picker.IsOpen and self:_IsPointInRegion(mouse_x, mouse_y, picker.SaturationValueRegion) then
                picker.isDraggingSaturationValue = true; started_drag = true;
            else
                for _, section in ipairs(self.UI.Sections) do
                    for _, el in ipairs(section.Elements) do
                        if el.type == "Slider" and self:_IsPointInRegion(mouse_x, mouse_y, el.ClickRegion) then
                            el.IsDragging = true; started_drag = true; break;
                        end
                    end
                    if started_drag then break end
                end
            end
        end

        if not started_drag then
            local header_drag_region = {x1 = self.Window.X, y1 = self.Window.Y, x2 = self.Window.X + self.Window.Width, y2 = self.Window.Y + self.Window.HeaderHeight}
            local on_header_button = self:_IsPointInRegion(mouse_x, mouse_y, self.UI.Core.HeaderButtons.Save.ClickRegion) or self:_IsPointInRegion(mouse_x, mouse_y, self.UI.Core.HeaderButtons.ViewESP.ClickRegion) or self:_IsPointInRegion(mouse_x, mouse_y, self.UI.Core.HeaderButtons.CreateNew.ClickRegion) or self:_IsPointInRegion(mouse_x, mouse_y, self.UI.Core.HeaderButtons.Settings.ClickRegion) or self:_IsPointInRegion(mouse_x, mouse_y, burger_button.ClickRegion)

            if self:_IsPointInRegion(mouse_x, mouse_y, header_drag_region) and not on_header_button and not (picker.IsOpen or style_window.IsOpen or about_window.IsOpen or settings_popup.IsOpen or burger_popup.IsOpen or configsTab.OptionsPopup.IsOpen) then
                self.Window.IsDragging = true;
                self.Window.IsFastDragging = true;
                started_drag = true;
                drag_offset = {x = mouse_x - self.Window.X, y = mouse_y - self.Window.Y};
            end
        end
        is_dragging_something = started_drag
    end

    if is_left_pressed_now then
        -- [[ ИЗМЕНЕНИЕ ЗДЕСЬ ]]
        -- Добавлена новая, более точная логика перетаскивания скроллбара
        local scrollbar = configsTab.Scrollbar
        if scrollbar.IsDraggingNub then
            -- Вычисляем все необходимые размеры, чтобы быть уверенными в точности
            local itemHeight = 60; local itemSpacing = 10; local totalItemHeight = itemHeight + itemSpacing; local MAX_VISIBLE_ITEMS = 7;
            local visibleAreaHeight = (MAX_VISIBLE_ITEMS * totalItemHeight) - itemSpacing
            local totalContentHeight = (#configsTab.Items * totalItemHeight) - itemSpacing
            local minNubHeight = 30
            local nubHeight = math.max(minNubHeight, visibleAreaHeight * (visibleAreaHeight / totalContentHeight))
            
            -- Диапазон, который может прокрутить контент
            local contentScrollRange = totalContentHeight - visibleAreaHeight
            -- Диапазон, в котором может двигаться сам ползунок
            local nubScrollRange = visibleAreaHeight - nubHeight
            
            -- Вычисляем смещение мыши с момента нажатия
            local mouseDeltaY = mouse_y - scrollbar.DragStartMouseY
            
            -- Вычисляем пропорцию. Если nubScrollRange равен 0, то и пропорция 0
            local scrollRatio = (nubScrollRange > 0) and (contentScrollRange / nubScrollRange) or 0
            
            -- Вычисляем новое смещение контента
            local newOffset = scrollbar.DragStartOffset + (mouseDeltaY * scrollRatio)
            
            -- Ограничиваем смещение, чтобы не выйти за пределы
            configsTab.Scrollbar.ScrollOffset = math.clamp(newOffset, 0, contentScrollRange)
        end
        -- [[ КОНЕЦ ИЗМЕНЕНИЯ ]]

        if wm.IsDragging then wm.Position.x = mouse_x - wm.DragOffset.x; wm.Position.y = mouse_y - wm.DragOffset.y; end
        if hk.IsDragging then hk.Position.x = mouse_x - hk.DragOffset.x; hk.Position.y = mouse_y - hk.DragOffset.y; end
        if self.Window.IsDragging then self.Window.X = mouse_x - drag_offset.x; self.Window.Y = mouse_y - drag_offset.y; end

        local function update_slider_value(slider)
            local sliderBackX, sliderBackWidth = self:_SafeNumber(slider.Back.Position.x, 0), self:_SafeNumber(slider.Back.Size.x, 1)
            local mouse_relative_x = math.clamp(mouse_x - sliderBackX, 0, sliderBackWidth)
            local percentage = sliderBackWidth > 0 and (mouse_relative_x / sliderBackWidth) or 0
            local raw_value = slider.Min + (slider.Max - slider.Min) * percentage
            
            local stepped_value
            if slider.Increment >= 1 then
                stepped_value = math.floor(raw_value / slider.Increment + 0.5) * slider.Increment
            else
                stepped_value = tonumber(string.format("%." .. string.len(tostring(slider.Increment):match("%.(.*)") or "") .. "f", (math.floor(raw_value / slider.Increment + 0.5) * slider.Increment)))
            end
            
            local clamped_value = math.clamp(stepped_value, slider.Min, slider.Max)
            if clamped_value ~= self.UI.Values[slider.id] then
                self.UI.Values[slider.id] = clamped_value
                if slider.Callback then slider.Callback(clamped_value) end
            end
        end

        if about_window.IsOpen and about_window.AnimationSpeedSlider.IsDragging then
            update_slider_value(about_window.AnimationSpeedSlider);
        end
        for _, section in ipairs(self.UI.Sections) do for _, el in ipairs(section.Elements) do if el.type == "Slider" and el.IsDragging then update_slider_value(el); break; end end end

        if picker.isDraggingHue or picker.isDraggingOpacity or picker.isDraggingSaturationValue then
            local function update_color_picker()
                local new_rgb = self:_HSVtoRGB(picker.h, picker.s, picker.v); local new_color = {new_rgb[1], new_rgb[2], new_rgb[3], picker.a * 255}
                if picker.EditingValueID then self.UI.Values[picker.EditingValueID] = new_color
                elseif picker.EditingColorName then
                    style_window.EditingTheme.Colors[picker.EditingColorName] = new_color
                    if self.UI.Values.EditStyleRealTime and self.TempTheme then self.TempTheme.Colors[picker.EditingColorName] = new_color end
                end
            end
            if picker.isDraggingHue then picker.h = math.clamp((mouse_x - picker.HueSliderRegion.x1) / (picker.HueSliderRegion.x2 - picker.HueSliderRegion.x1), 0, 1) end
            if picker.isDraggingOpacity then picker.a = math.clamp((mouse_x - picker.OpacitySliderRegion.x1) / (picker.OpacitySliderRegion.x2 - picker.OpacitySliderRegion.x1), 0, 1) end
            if picker.isDraggingSaturationValue then
                picker.s = math.clamp((mouse_x - picker.SaturationValueRegion.x1) / (picker.SaturationValueRegion.x2 - picker.SaturationValueRegion.x1), 0, 1)
                picker.v = 1 - math.clamp((mouse_y - picker.SaturationValueRegion.y1) / (picker.SaturationValueRegion.y2 - picker.SaturationValueRegion.y1), 0, 1)
            end
            update_color_picker()
        end
    end

    local right_click_handled = false
    if is_right_clicked then
        if picker.IsOpen and (picker.ClickRegion and self:_IsPointInRegion(mouse_x, mouse_y, picker.ClickRegion)) then
            for i = #picker.Swatches, 1, -1 do
                local swatch = picker.Swatches[i]
                if not swatch.IsAddButton and self:_IsPointInRegion(mouse_x, mouse_y, swatch.ClickRegion) then
                    self:_RemoveColorSwatch(i)
                    right_click_handled = true
                    break
                end
            end
        end
    end

    if is_left_clicked and not right_click_handled then
        if not is_dragging_something then
            local click_was_handled = false

            local active_slider_editing = nil
            if about_window.AnimationSpeedSlider.IsEditing then active_slider_editing = about_window.AnimationSpeedSlider end
            if not active_slider_editing then
                for _, section in ipairs(self.UI.Sections) do for _, el in ipairs(section.Elements) do if el.type == "Slider" and el.IsEditing then active_slider_editing = el; break; end end if active_slider_editing then break end end
            end
            if active_slider_editing and not self:_IsPointInRegion(mouse_x, mouse_y, active_slider_editing.ValueInputClickRegion) then
                applySliderInput(active_slider_editing); click_was_handled = true
            elseif picker.IsEditing and not self:_IsPointInRegion(mouse_x, mouse_y, picker.Input.ClickRegion) then
                applyColorInput(picker); click_was_handled = true
            end

            if not click_was_handled then
                if anyDropdownOpen or (picker.IsOpen and picker.Dropdown.IsOpen) then
                    click_was_handled = true
                    if picker.IsOpen and picker.Dropdown.IsOpen then
                        if picker.Dropdown.PopupClickRegion and self:_IsPointInRegion(mouse_x, mouse_y, picker.Dropdown.PopupClickRegion) then
                            if picker.HoveredDropdownIndex > 0 then picker.Mode = picker.Dropdown.Options[picker.HoveredDropdownIndex].Text.Text end
                        end
                        picker.Dropdown.IsOpen, picker.Dropdown.IsClosing = false, true
                    else
                         for _, section in ipairs(self.UI.Sections) do for _, el in ipairs(section.Elements) do
                            if (el.type == "Dropdown" or el.type == "Multidropdown") and el.IsOpen then
                                if el.PopupClickRegion and self:_IsPointInRegion(mouse_x, mouse_y, el.PopupClickRegion) then
                                    if el.HoveredOptionIndex > 0 then
                                        local i = el.HoveredOptionIndex
                                        if el.type == "Dropdown" then
                                            self.UI.Values[el.id] = el.Options[i]
                                            if el.Callback then pcall(el.Callback, self.UI.Values[el.id]) end
                                            el.IsOpen, el.IsClosing = false, true
                                        else
                                            local opt = el.Options[i]
                                            local found_idx = table.find(self.UI.Values[el.id], opt)
                                            if found_idx then table.remove(self.UI.Values[el.id], found_idx) else table.insert(self.UI.Values[el.id], opt) end
                                            if el.Callback then pcall(el.Callback, self.UI.Values[el.id]) end
                                        end
                                    end
                                else
                                    el.IsOpen, el.IsClosing = false, true
                                end
                                break
                            end
                        end end
                    end
                end
            end

            if not click_was_handled then
                if picker.IsOpen then
                    click_was_handled = true
                    if not (picker.ClickRegion and self:_IsPointInRegion(mouse_x, mouse_y, picker.ClickRegion)) then
                        picker.Animation.IsClosing = true; picker.Animation.IsOpening = false
                    else
                        local swatch_click_handled = false
                        for i, swatch in ipairs(picker.Swatches) do
                            if self:_IsPointInRegion(mouse_x, mouse_y, swatch.ClickRegion) then
                                if swatch.IsAddButton then
                                    local current_color_rgb = self:_HSVtoRGB(picker.h, picker.s, picker.v)
                                    self:_AddColorSwatch({current_color_rgb[1], current_color_rgb[2], current_color_rgb[3], picker.a * 255})
                                else
                                    local preset_color = swatch.Color
                                    picker.h, picker.s, picker.v, picker.a = self:_RGBtoHSV(preset_color[1], preset_color[2], preset_color[3], preset_color[4])
                                    if picker.EditingValueID then self.UI.Values[picker.EditingValueID] = preset_color
                                    elseif picker.EditingColorName then
                                        style_window.EditingTheme.Colors[picker.EditingColorName] = preset_color
                                        if self.UI.Values.EditStyleRealTime and self.TempTheme then self.TempTheme.Colors[picker.EditingColorName] = preset_color end
                                    end
                                end
                                swatch_click_handled = true
                                break
                            end
                        end

                        if not swatch_click_handled then
                            if self:_IsPointInRegion(mouse_x, mouse_y, picker.Input.ClickRegion) then
                                picker.IsEditing = true
                                if picker.Mode == "HEX" then picker.InputText = picker.Input.Text.Text:gsub("#", "") else picker.InputText = picker.Input.Text.Text end
                            elseif self:_IsPointInRegion(mouse_x, mouse_y, picker.Dropdown.ClickRegion) then
                                picker.Dropdown.IsOpen, picker.Dropdown.IsClosing = not picker.Dropdown.IsOpen, picker.Dropdown.IsOpen
                                if picker.Dropdown.IsOpen then picker.Dropdown.FadeOpacity = 0.0 end
                            end
                        end
                    end
                elseif style_window.IsOpen then
                    click_was_handled = true
                    if style_window.ClickRegion and self:_IsPointInRegion(mouse_x, mouse_y, style_window.ClickRegion) then
                        if self:_IsPointInRegion(mouse_x, mouse_y, style_window.CloseButton.ClickRegion) or self:_IsPointInRegion(mouse_x, mouse_y, style_window.CancelButton.ClickRegion) then self:_revert_realtime_changes(); style_window.Animation.IsClosing = true; style_window.Animation.IsOpening = false; style_window.IsEditingName = false;
                        elseif self:_IsPointInRegion(mouse_x, mouse_y, style_window.SaveButton.ClickRegion) then
                            local originalName = style_window.EditingThemeName
                            local newName = style_window.StyleNameInputText.Text or "Custom"
                            if newName == "" then newName = "Custom" end

                            if newName ~= originalName and self.Themes[originalName] and not self.Themes[originalName].IsPreset then
                                self.Themes[originalName] = nil
                            end

                            local finalName = newName
                            if self.Themes[finalName] and finalName ~= originalName then
                                local i = 1
                                while self.Themes[finalName .. " (" .. i .. ")"] do i = i + 1 end
                                finalName = finalName .. " (" .. i .. ")"
                            end

                            local newTheme = self:_DeepCopy(style_window.EditingTheme)
                            newTheme.Name = finalName
                            newTheme.IsPreset = false
                            self.Themes[finalName] = newTheme

                            self:_RebuildStyleCircles()
                            self.UI.Values.AboutSelectedStyle = finalName
                            self.ActiveTheme = self.Themes[finalName]

                            self.TempTheme = nil; self.PreEditThemeName = nil; self.UI.Values.EditStyleRealTime = false;
                            style_window.Animation.IsClosing = true; style_window.Animation.IsOpening = false; style_window.IsEditingName = false;
                        elseif self:_IsPointInRegion(mouse_x, mouse_y, style_window.RealTimeToggle.ClickRegion) then
                            self.UI.Values.EditStyleRealTime = not self.UI.Values.EditStyleRealTime
                            if self.UI.Values.EditStyleRealTime then self.PreEditThemeName = self.ActiveTheme.Name; self.TempTheme = self:_DeepCopy(style_window.EditingTheme); self.ActiveTheme = self.TempTheme;
                            else self.ActiveTheme = self.Themes[self.PreEditThemeName] or self.Themes.Blue; self.UI.Values.AboutSelectedStyle = self.ActiveTheme.Name; self.TempTheme = nil; self.PreEditThemeName = nil; end
                        elseif self:_IsPointInRegion(mouse_x, mouse_y, style_window.StyleNameInputClickRegion) then style_window.IsEditingName = true
                        else
                            local clicked_color = false
                            for _, item in ipairs(style_window.ColorItems) do
                                if self:_IsPointInRegion(mouse_x, mouse_y, item.ClickRegion) then
                                    picker.IsOpen = true; picker.Animation.IsOpening = true; picker.Animation.IsClosing = false;
                                    picker.EditingColorName = item.Name; picker.EditingValueID = nil; picker.Pos = {x = mouse_x, y = mouse_y}; local color_to_edit = style_window.EditingTheme.Colors[item.Name]; picker.h, picker.s, picker.v, picker.a = self:_RGBtoHSV(color_to_edit[1], color_to_edit[2], color_to_edit[3], color_to_edit[4]); clicked_color = true; break;
                                end
                            end
                            if not clicked_color then style_window.IsEditingName = false end
                        end
                    end
                elseif about_window.IsOpen then
                    click_was_handled = true
                    if about_window.ClickRegion and self:_IsPointInRegion(mouse_x, mouse_y, about_window.ClickRegion) then
                        if self:_IsPointInRegion(mouse_x, mouse_y, about_window.CloseButton.ClickRegion) then about_window.Animation.IsClosing = true; about_window.Animation.IsOpening = false;
                        elseif self:_IsPointInRegion(mouse_x, mouse_y, about_window.AutoSaveToggle.ClickRegion) then self.UI.Values.AboutAutoSave = not self.UI.Values.AboutAutoSave
                        elseif self:_IsPointInRegion(mouse_x, mouse_y, about_window.ToggleUIKeybind.ClickRegion) then about_window.ToggleUIKeybind.IsListening = not about_window.ToggleUIKeybind.IsListening
                        elseif self:_IsPointInRegion(mouse_x, mouse_y, about_window.AnimationSpeedSlider.ValueInputClickRegion) then
                             local slider = about_window.AnimationSpeedSlider; slider.IsEditing = true; slider.InputText = string.format("%.1f", self.UI.Values[slider.id])
                        else
                            for _, circle in ipairs(about_window.StyleCircles) do
                                if self:_IsPointInRegion(mouse_x, mouse_y, circle.ClickRegion) then
                                    if circle.IsAddButton then
                                        local newName = "Custom 1"
                                        local i = 1
                                        while self.Themes[newName] do i = i + 1; newName = "Custom " .. i; end
                                        style_window.EditingTheme = self:_DeepCopy(self.ActiveTheme)
                                        style_window.EditingThemeName = newName
                                        style_window.StyleNameInputText.Text = newName
                                        style_window.IsOpen = true; style_window.Animation.IsOpening = true; style_window.Animation.IsClosing = false;
                                    else self.UI.Values.AboutSelectedStyle = circle.Name; self.ActiveTheme = self.Themes[circle.Name]; end; break;
                                end
                            end
                        end
                    else
                        about_window.Animation.IsClosing = true; about_window.Animation.IsOpening = false;
                    end

                elseif settings_popup.Animation.CurrentOpacity > 0 then
                    click_was_handled = true
                    if not (settings_popup.ClickRegion and self:_IsPointInRegion(mouse_x, mouse_y, settings_popup.ClickRegion)) then
                        settings_popup.Animation.IsClosing = true
                        settings_popup.Animation.IsOpening = false
                    else
                        if settings_popup.ActiveToggle then
                            for _, element in ipairs(settings_popup.ActiveToggle.SettingsElements or {}) do
                                if element.type == "Keybind" and self:_IsPointInRegion(mouse_x, mouse_y, element.ClickRegion) then
                                    element.IsListening = not element.IsListening;
                                    break;
                                end
                            end;
                        end
                    end

                elseif burger_popup.IsOpen then
                    click_was_handled = true
                    if burger_popup.ClickRegion and self:_IsPointInRegion(mouse_x, mouse_y, burger_popup.ClickRegion) then
                        if burger_popup.HoveredItemIndex > 0 then local item = burger_popup.Items[burger_popup.HoveredItemIndex]; self.UI.Values[item.id] = not self.UI.Values[item.id]; end
                    else
                        burger_popup.Animation.IsClosing = true; burger_popup.Animation.IsOpening = false
                    end
                elseif configsTab.OptionsPopup.IsOpen then
                    click_was_handled = true
                    if not (configsTab.OptionsPopup.ClickRegion and self:_IsPointInRegion(mouse_x, mouse_y, configsTab.OptionsPopup.ClickRegion)) then
                        configsTab.OptionsPopup.Animation.IsClosing = true
                        configsTab.OptionsPopup.Animation.IsOpening = false
                    else
                        if self:_IsPointInRegion(mouse_x, mouse_y, configsTab.OptionsPopup.IncludeStyleToggle.ClickRegion) then 
                            self.UI.Values[configsTab.OptionsPopup.IncludeStyleToggle.id] = not self.UI.Values[configsTab.OptionsPopup.IncludeStyleToggle.id]
                        end

                        local delBtn = configsTab.OptionsPopup.DeleteButton
                        if self:_IsPointInRegion(mouse_x, mouse_y, delBtn.ClickRegion) then
                            local itemIndex = configsTab.OptionsPopup.ItemIndex
                            if itemIndex and configsTab.Items[itemIndex] then
                                local configNameToDelete = configsTab.Items[itemIndex].Name
                                deletefile(self:_GetConfigPath(configNameToDelete))
                                configsTab.OptionsPopup.Animation.IsClosing = true
                                configsTab.OptionsPopup.Animation.IsOpening = false
                                configsTab.NeedsRefresh = true
                            end
                        end
                    end
                end
            end

            if not click_was_handled then
                if self:_IsPointInRegion(mouse_x, mouse_y, burger_button.ClickRegion) then
                    burger_popup.IsOpen = not burger_popup.IsOpen;
                    if burger_popup.IsOpen then burger_popup.Animation.IsOpening = true; burger_popup.Animation.IsClosing = false; burger_popup.Pos = {x = mouse_x, y = mouse_y}; else burger_popup.Animation.IsClosing = true; burger_popup.Animation.IsOpening = false; end
                elseif self:_IsPointInRegion(mouse_x, mouse_y, self.UI.Core.HeaderButtons.Settings.ClickRegion) then
                    about_window.IsOpen = not about_window.IsOpen
                    if about_window.IsOpen then about_window.Animation.IsOpening = true; about_window.Animation.IsClosing = false; else about_window.Animation.IsClosing = true; about_window.Animation.IsOpening = false; end
                elseif self:_IsPointInRegion(mouse_x, mouse_y, self.UI.Core.HeaderButtons.CreateNew.ClickRegion) and self.Window.ActiveTab == "Configs" then self.UI.Core.HeaderButtons.CreateNew.ClickTime = tick(); self:_CreateNewConfig();
                elseif self:_IsPointInRegion(mouse_x, mouse_y, self.UI.Core.HeaderButtons.Save.ClickRegion) then self.UI.Core.HeaderButtons.Save.ClickTime = tick(); if configsTab.LoadedConfigName ~= "" then self:_SaveConfig(configsTab.LoadedConfigName) end
                elseif self:_IsPointInRegion(mouse_x, mouse_y, self.UI.Core.HeaderButtons.ViewESP.ClickRegion) then
                    self.UI.Core.HeaderButtons.ViewESP.IsOpen = not self.UI.Core.HeaderButtons.ViewESP.IsOpen
                    self.UI.Core.HeaderButtons.ViewESP.ClickTime = tick()
                else
                    local clicked_on_main_ui = false
                    if self.Window.ActiveTab == "Configs" then
                        for i, item in ipairs(configsTab.Items) do local d = item.Drawing
                            if configsTab.LoadedConfigName == item.Name and self:_IsPointInRegion(mouse_x, mouse_y, d.SaveButton.ClickRegion) then self:_SaveConfig(item.Name); clicked_on_main_ui = true; break;
                            elseif configsTab.LoadedConfigName ~= item.Name and self:_IsPointInRegion(mouse_x, mouse_y, d.LoadButton.ClickRegion) then self:_LoadConfig(item.Name); clicked_on_main_ui = true; break;
                            elseif self:_IsPointInRegion(mouse_x, mouse_y, d.OptionsButton.ClickRegion) then 
                                local popup = configsTab.OptionsPopup
                                popup.IsOpen = not popup.IsOpen
                                if popup.IsOpen then
                                    popup.Animation.IsOpening = true
                                    popup.Animation.IsClosing = false
                                    popup.Animation.CurrentOpacity = 0
                                else
                                    popup.Animation.IsClosing = true
                                    popup.Animation.IsOpening = false
                                end
                                popup.ItemIndex = i
                                popup.Pos = {x = mouse_x - 155, y = mouse_y}
                                clicked_on_main_ui = true
                                break
                            end
                        end
                    else
                        for _, section in ipairs(self.UI.Sections) do if section.ParentTab == self.Window.ActiveTab then for _, el in ipairs(section.Elements) do
                            if self:_IsPointInRegion(mouse_x, mouse_y, el.ClickRegion) then
                                if el.type == "Toggle" then self.UI.Values[el.id] = not self.UI.Values[el.id]; if el.Callback then el.Callback(self.UI.Values[el.id]) end
                                elseif el.type == "Dropdown" or el.type == "Multidropdown" then
                                    local openingThisOne = not el.IsOpen; for _, s_inner in ipairs(self.UI.Sections) do for _, el_inner in ipairs(s_inner.Elements) do if (el_inner.type == "Dropdown" or el_inner.type == "Multidropdown") and el_inner.IsOpen then el_inner.IsOpen = false; el_inner.IsClosing = true; end end end
                                    if openingThisOne then el.IsOpen = true; el.IsClosing = false; el.FadeOpacity = 0.0; end
                                elseif el.type == "Slider" then update_slider_value(el)
                                end; clicked_on_main_ui = true; break;
                            elseif el.type == "Toggle" and el.HasColor and self:_IsPointInRegion(mouse_x, mouse_y, el.ColorClickRegion) then
                                picker.IsOpen = true; picker.Animation.IsOpening = true; picker.Animation.IsClosing = false; picker.EditingValueID = el.HasColor.id; picker.EditingColorName = nil; picker.Pos = {x = mouse_x, y = mouse_y}; local color_to_edit = self.UI.Values[el.HasColor.id]; picker.h, picker.s, picker.v, picker.a = self:_RGBtoHSV(color_to_edit[1], color_to_edit[2], color_to_edit[3], color_to_edit[4]); clicked_on_main_ui = true; break;
                            elseif el.HasSettings and self:_IsPointInRegion(mouse_x, mouse_y, el.SettingsClickRegion) then
                                settings_popup.IsOpen = true
                                settings_popup.Animation.IsOpening = true
                                settings_popup.Animation.IsClosing = false
                                settings_popup.Animation.CurrentOpacity = 0
                                settings_popup.ActiveToggle = el;
                                settings_popup.Pos = {x = mouse_x, y = mouse_y};
                                clicked_on_main_ui = true;
                                break;
                            elseif el.type == "Slider" and self:_IsPointInRegion(mouse_x, mouse_y, el.ValueInputClickRegion) then
                                el.IsEditing = true; el.InputText = tostring(math.floor(self.UI.Values[el.id])); clicked_on_main_ui = true; break;
                            end
                        end end if clicked_on_main_ui then break end end
                    end

                    if not clicked_on_main_ui then
                        for _, group in ipairs(self.UI.TabGroups) do for _, tab in ipairs(group.Tabs) do
                            if self:_IsPointInRegion(mouse_x, mouse_y, tab.ClickRegion) then self.Window.ActiveTab = tab.Name; break end
                        end end
                    end
                end
            end
        end

        wm.IsDragging = false; self.Window.IsDragging = false; hk.IsDragging = false;
        if about_window.IsOpen then about_window.AnimationSpeedSlider.IsDragging = false end
        picker.isDraggingHue, picker.isDraggingOpacity, picker.isDraggingSaturationValue = false, false, false;
        for _, section in ipairs(self.UI.Sections) do for _, el in ipairs(section.Elements) do if el.type == "Slider" and el.IsDragging then el.IsDragging = false end end end
        is_dragging_something = false
        self.Window.IsFastDragging = false;
        configsTab.Scrollbar.IsDraggingNub = false
    end

    do
        local KEY_INITIAL_DELAY = 0.4
        local KEY_REPEAT_DELAY = 0.05
        local key = getpressedkey()

        local function handle_text_input(target, input_key)
            if target.type == "Slider" then
                if input_key == "Backspace" then
                    if #target.InputText > 0 then target.InputText = string.sub(target.InputText, 1, -2) end
                elseif input_key == "Enter" then
                    applySliderInput(target)
                elseif string.match(input_key, "[-.0-9]") then
                    if #target.InputText < 7 then target.InputText = target.InputText .. input_key end
                end
            elseif target == style_window then
                local current_text = target.StyleNameInputText.Text
                if input_key == "Backspace" then
                    if #current_text > 0 then target.StyleNameInputText.Text = string.sub(current_text, 1, -2) end
                elseif input_key == "Space" then
                    if #current_text < 20 then target.StyleNameInputText.Text = current_text .. " " end
                elseif string.len(input_key) == 1 and string.match(input_key, "%w") then
                    if #current_text < 20 then target.StyleNameInputText.Text = current_text .. input_key end
                end
            elseif target == picker then
                if input_key == "Backspace" then
                    if #picker.InputText > 0 then picker.InputText = string.sub(picker.InputText, 1, -2) end
                elseif input_key == "Enter" then
                    applyColorInput(picker)

                elseif picker.Mode == "RGBA" and (input_key == "Space" or input_key == ",") then
                    picker.InputText = picker.InputText:match("^%s*(.-)%s*$"):gsub("[,%s]*$", "")
                    local parts = self:_SplitString(picker.InputText, ",")

                    if #parts > 0 and #parts < 4 then
                        local last_part = parts[#parts]
                        local last_num = tonumber(last_part) or 0

                        parts[#parts] = tostring(math.clamp(last_num, 0, 255))
                        picker.InputText = table.concat(parts, ", ") .. ", "
                    end

                elseif string.len(input_key) == 1 then
                    if picker.Mode == "HEX" then
                        if string.match(input_key:lower(), "[0-9a-f]") and #picker.InputText < 8 then
                            picker.InputText = picker.InputText .. input_key:lower()
                        end
                    elseif picker.Mode == "RGBA" then
                        if string.match(input_key, "%d") then
                            local temp_text = picker.InputText .. input_key
                            local parts = self:_SplitString(temp_text, ",")

                            if #parts <= 4 then
                                local last_part = parts[#parts] or ""
                                local current_num = tonumber(last_part) or 0

                                if #last_part == 4 then
                                    local corrected_part = string.sub(last_part, 1, 3)
                                    local corrected_num = tonumber(corrected_part)

                                    parts[#parts] = tostring(math.clamp(corrected_num, 0, 255))

                                    picker.InputText = table.concat(parts, ", ")
                                    if #parts < 4 then
                                        picker.InputText = picker.InputText .. ", "
                                    end
                                elseif #last_part == 3 and current_num > 255 then
                                    parts[#parts] = "255"
                                    picker.InputText = table.concat(parts, ", ")
                                    if #parts < 4 then
                                        picker.InputText = picker.InputText .. ", "
                                    end
                                else
                                    picker.InputText = temp_text
                                end
                            end
                        end
                    end
                end
            end
        end

        local active_target
        if style_window.IsOpen and style_window.IsEditingName then
            active_target = style_window
        elseif picker.IsOpen and picker.IsEditing then
            active_target = picker
        else
            if about_window.AnimationSpeedSlider.IsEditing then active_target = about_window.AnimationSpeedSlider end

            if not active_target then
                for _, section in ipairs(self.UI.Sections) do
                    for _, el in ipairs(section.Elements) do
                        if el.type == "Slider" and el.IsEditing then
                            active_target = el; break
                        end
                    end
                    if active_target then break end
                end
            end
        end

        if key and key ~= "None" then
            if active_target then
                if key ~= active_target.last_key_pressed then
                    handle_text_input(active_target, key)
                    active_target.last_key_press_time = tick()
                    active_target.last_key_pressed = key
                    active_target.is_in_repeat = false
                else
                    local delay = active_target.is_in_repeat and KEY_REPEAT_DELAY or KEY_INITIAL_DELAY
                    if (tick() - active_target.last_key_press_time) > delay then
                        handle_text_input(active_target, key)
                        active_target.last_key_press_time = tick()
                        active_target.is_in_repeat = true
                    end
                end
            else
                if about_window.IsOpen and about_window.ToggleUIKeybind and about_window.ToggleUIKeybind.IsListening then
                    if self.UI.Values[about_window.ToggleUIKeybind.id] ~= key then self.UI.Values[about_window.ToggleUIKeybind.id] = key end
                    about_window.ToggleUIKeybind.IsListening = false
                elseif settings_popup.IsOpen and settings_popup.ActiveToggle then
                    for _, element in ipairs(settings_popup.ActiveToggle.SettingsElements or {}) do
                        if element.type == "Keybind" and element.IsListening then
                            if self.UI.Values[element.id] ~= key then self.UI.Values[element.id] = key end
                            element.IsListening = false; break
                        end
                    end
                end
            end
        else
            if style_window.last_key_pressed ~= "None" then style_window.last_key_pressed = "None"; style_window.is_in_repeat = false end
            if picker.last_key_pressed ~= "None" then picker.last_key_pressed = "None"; picker.is_in_repeat = false end
            if about_window.AnimationSpeedSlider.last_key_pressed ~= "None" then about_window.AnimationSpeedSlider.last_key_pressed = "None"; about_window.AnimationSpeedSlider.is_in_repeat = false; end
            for _, section in ipairs(self.UI.Sections) do
                for _, el in ipairs(section.Elements) do
                    if el.type == "Slider" and el.last_key_pressed ~= "None" then el.last_key_pressed = "None"; el.is_in_repeat = false; break end
                end
            end
        end
    end
    end

    was_left_pressed = is_left_pressed_now
    was_right_pressed = is_right_pressed_now
end


function Library:_AddPresetsTab()
    local tabGroupName = "PRESETS"
    local tabName = "Configs"

    for _, group in ipairs(self.UI.TabGroups) do
        if group.Name == tabGroupName then return end
    end

    local group = { Name = tabGroupName, Header = self:_CreateDrawingObject("Text"), Tabs = {} }
    if group.Header then
        group.Header.Font = self.ActiveTheme.Fonts.Main; group.Header.Size = self.ActiveTheme.Fonts.TabHeaderSize; group.Header.Text = group.Name; group.Header.Center = false; group.Header.Outline = false; group.Header.zIndex = 3;
    end

    local tab = {
        Name = tabName,
        Text = self:_CreateDrawingObject("Text"),
        Icon = self:_CreateDrawingObject("Image"),
        ClickRegion = {},
        Highlight = self:_CreateDrawingObject("Square") -- Добавляем недостающий объект
    }
    -- И настраиваем его
    if tab.Highlight then
        tab.Highlight.Filled = true
        tab.Highlight.zIndex = 2
        tab.Highlight.Rounding = self.ActiveTheme.Rounding.Element + 3
        tab.Highlight.Visible = true
    end
    
    if tab.Text then
        tab.Text.Font = self.ActiveTheme.Fonts.Main; tab.Text.Size = self.ActiveTheme.Fonts.TabSize; tab.Text.Text = tabName; tab.Text.Center = false; tab.Text.Outline = false; tab.Text.zIndex = 3; end
    if tab.Icon then
        tab.Icon.Url = "https://i.postimg.cc/3Rsbw44x/dsawdsaaaaaaaaa.png" -- Gear icon
        tab.Icon.Size = {self.ActiveTheme.IconSize, self.ActiveTheme.IconSize}; tab.Icon.zIndex = 3;
    end

    table.insert(group.Tabs, tab)
    table.insert(self.UI.TabGroups, group)
end

function Library:_MainLoop()
    print(SCRIPT_PREFIX .. "UI Initialized and Main Loop started. x242")
    local is_first_frame = true
    while true do
        -- Обрабатываем очередь на удаление в начале каждого кадра
        self:_ProcessRemovalQueue()
        -- Сначала обрабатываем ввод. Он может пометить UI как "грязный".
        self:_InputLoop()

        -- Затем обновляем все анимации и проверяем, активны ли они.
        local hasActiveAnimations = self:_UpdateAllAnimations()

        -- [[ НОВОЕ: Проверка на активный ввод текста для мигания курсора ]]
        local is_text_input_active = false
        if self.UI.Popups.EditStyle.IsEditingName or self.UI.Popups.ColorPicker.IsEditing then
            is_text_input_active = true
        else
            for _, section in ipairs(self.UI.Sections) do
                for _, el in ipairs(section.Elements) do
                    if el.type == "Slider" and el.IsEditing then
                        is_text_input_active = true
                        break
                    end
                end
                if is_text_input_active then break end
            end
            if not is_text_input_active and self.UI.Core.AboutWindow.AnimationSpeedSlider and self.UI.Core.AboutWindow.AnimationSpeedSlider.IsEditing then
                is_text_input_active = true
            end
        end

        if self.Window.Visible then
            if is_first_frame then
                self:_AddPresetsTab()
                is_first_frame = false
            end
            self:_RenderLoop()
        end

        self:_RenderWatermark()
        self:_RenderHotkeys()

        wait(0.01)
    end
end




--================================================================
--[[ PRIVATE: INTERNAL ELEMENT CREATORS ]]
--================================================================

function Library:_Internal_CreateToggle(options)
    local is_on = options.Default or false
    if self.UI.Values[options.id] == nil then
        self.UI.Values[options.id] = is_on
    end
    local z = options.zIndex or 4
    local toggle = {
        id = options.id, type = "Toggle", Name = options.Name,
        Size = {width = 35, height = 20},
        HasSettings = options.HasSettings or false,
        HasColor = options.HasColor or false,
        Callback = options.Callback,
        Label = self:_CreateDrawingObject("Text"), Back = self:_CreateDrawingObject("Square"),
        Nub = self:_CreateDrawingObject("Circle"), ClickRegion = {}, SettingsClickRegion = {},
        SettingsIcon = nil,
        ColorCircle = nil,
        ColorBorder = nil,
        ColorClickRegion = {},
        CurrentBackColor = {0,0,0,0},
        CurrentNubColor = {0,0,0,0},
        -- ИЗМЕНЕНИЕ: Добавляем поле для хранения анимированной позиции
        AnimatedNubOffset = is_on and (35 - 20 / 2) or (20 / 2)
    }
    if toggle.HasColor and type(toggle.HasColor) == 'table' then
        if self.UI.Values[toggle.HasColor.id] == nil then
            self.UI.Values[toggle.HasColor.id] = toggle.HasColor.Default or {255, 255, 255, 255}
        end
        toggle.ColorCircle = self:_CreateDrawingObject("Circle")
        toggle.ColorBorder = self:_CreateDrawingObject("Circle")
        if toggle.ColorCircle then
            toggle.ColorCircle.Filled = true; toggle.ColorCircle.zIndex = z + 1; toggle.ColorCircle.Radius = 6;
        end
        if toggle.ColorBorder then
            toggle.ColorBorder.Filled = false; toggle.ColorBorder.Thickness = 1; toggle.ColorBorder.zIndex = z + 2; toggle.ColorBorder.Radius = 7;
        end
    end
    if toggle.HasSettings then
        toggle.SettingsIcon = self:_CreateDrawingObject("Image")
        if toggle.SettingsIcon then
            toggle.SettingsIcon.Url = "https://i.postimg.cc/3Rsbw44x/dsawdsaaaaaaaaa.png"
            toggle.SettingsIcon.Size = {16, 16}
            toggle.SettingsIcon.zIndex = z + 1
        end
    end
    if toggle.Label then
        toggle.Label.Font = self.ActiveTheme.Fonts.Main; toggle.Label.Size = self.ActiveTheme.Fonts.Size + 2; toggle.Label.Text = toggle.Name; toggle.Label.Center = false; toggle.Label.Outline = false; toggle.Label.zIndex = z;
    end
    if toggle.Back then
        toggle.Back.Filled = true; toggle.Back.zIndex = z;
        toggle.Back.Rounding = 10;
    end
    if toggle.Nub then
        toggle.Nub.Filled = true; toggle.Nub.zIndex = z + 1;
        toggle.Nub.Radius = 8;
    end
    return toggle
end

function Library:_Internal_CreateSlider(options)
    if self.UI.Values[options.id] == nil then
        self.UI.Values[options.id] = options.Default or options.Min or 0
    end
    local z = options.zIndex or 4
    local slider = {
        id = options.id, type = "Slider", Name = options.Name, Min = options.Min or 0, Max = options.Max or 100,
        Increment = options.Increment or 1, IsDragging = false, Callback = options.Callback,
        
        IsEditing = false,
        InputText = tostring(math.floor(self.UI.Values[options.id] or options.Min)),
        AnimatedValue = self.UI.Values[options.id],
        
        last_key_press_time = 0,
        last_key_pressed = "",
        is_in_repeat = false, -- << ДОБАВЬ ЭТУ СТРОКУ
        
        Label = self:_CreateDrawingObject("Text"), 
        Back = self:_CreateDrawingObject("Square"),
        LeftFill = self:_CreateDrawingObject("Square"),
        Nub = self:_CreateDrawingObject("Circle"), 
        ValueText = self:_CreateDrawingObject("Text"),
        ClickRegion = {}, 
        Glow = self:_Internal_CreateGlowSet(z),

        ValueInputBg = self:_CreateDrawingObject("Square"),
        ValueInputBorder = self:_CreateDrawingObject("Square"),
        ValueInputCursor = self:_CreateDrawingObject("Line"),
        ValueInputClickRegion = {}
    }
    if slider.Label then slider.Label.Font = self.ActiveTheme.Fonts.Main; slider.Label.Size = self.ActiveTheme.Fonts.Size + 2; slider.Label.Text = slider.Name; slider.Label.Center = false; slider.Label.Outline = false; slider.Label.zIndex = z; end
    if slider.Back then slider.Back.Filled = true; slider.Back.zIndex = z; slider.Back.Rounding = 1; end
    if slider.LeftFill then slider.LeftFill.Filled = true; slider.LeftFill.zIndex = z + 1; slider.LeftFill.Rounding = 1; end
    if slider.Nub then slider.Nub.Filled = true; slider.Nub.zIndex = z + 2; slider.Nub.Radius = 8; end
    if slider.ValueText then slider.ValueText.Font = self.ActiveTheme.Fonts.Main; slider.ValueText.Size = self.ActiveTheme.Fonts.Size; slider.ValueText.Center = true; slider.ValueText.Outline = false; slider.ValueText.zIndex = z + 2; end
    
    if slider.ValueInputBg then slider.ValueInputBg.Filled = true; slider.ValueInputBg.zIndex = z; slider.ValueInputBg.Rounding = self.ActiveTheme.Rounding.Element; end
    if slider.ValueInputBorder then slider.ValueInputBorder.Filled = false; slider.ValueInputBorder.Thickness = 1; slider.ValueInputBorder.zIndex = z + 3; slider.ValueInputBorder.Rounding = self.ActiveTheme.Rounding.Element; end
    if slider.ValueInputCursor then slider.ValueInputCursor.Thickness = 1.5; slider.ValueInputCursor.zIndex = z + 3; end

    return slider
end

function Library:_Internal_CreateDropdown(options)
    if self.UI.Values[options.id] == nil then
        self.UI.Values[options.id] = options.Default or options.Options[1]
    end
    local z = options.zIndex or 4
    local dropdown = {
        id = options.id, type = "Dropdown", Name = options.Name, Options = options.Options,
        IsOpen = false, IsClosing = false, FadeOpacity = 0.0,
        HoveredOptionIndex = 0,
        Size = options.Size or {width = 120, height = 25}, Callback = options.Callback,
        Label = self:_CreateDrawingObject("Text"), Button = self:_CreateDrawingObject("Square"),
        ButtonText = self:_CreateDrawingObject("Text"), OptionList = {},
        OptionBackground = self:_CreateDrawingObject("Square"), ArrowLine1 = self:_CreateDrawingObject("Line"),
        ArrowLine2 = self:_CreateDrawingObject("Line"), ClickRegion = {},
        Border = self:_CreateDrawingObject("Square"),
        Glow = self:_Internal_CreateGlowSet(z + 8),
        CurrentButtonColor = {0,0,0,0}
    }
    if dropdown.Label then dropdown.Label.Font = self.ActiveTheme.Fonts.Main; dropdown.Label.Size = self.ActiveTheme.Fonts.Size + 2; dropdown.Label.Text = dropdown.Name; dropdown.Label.Center = false; dropdown.Label.Outline = false; dropdown.Label.zIndex = z; end
    if dropdown.Button then dropdown.Button.Filled = true; dropdown.Button.zIndex = z; dropdown.Button.Rounding = self.ActiveTheme.Rounding.Element; end
    if dropdown.ButtonText then dropdown.ButtonText.Font = self.ActiveTheme.Fonts.Main; dropdown.ButtonText.Size = self.ActiveTheme.Fonts.Size + 3; dropdown.ButtonText.Text = self.UI.Values[dropdown.id]; dropdown.ButtonText.Center = false; dropdown.ButtonText.Outline = false; dropdown.ButtonText.zIndex = z + 1; end
    if dropdown.OptionBackground then dropdown.OptionBackground.Filled = true; dropdown.OptionBackground.zIndex = z + 9; dropdown.OptionBackground.Visible = false; dropdown.OptionBackground.Rounding = self.ActiveTheme.Rounding.Section; end
    if dropdown.ArrowLine1 then dropdown.ArrowLine1.Thickness = 2; dropdown.ArrowLine1.zIndex = z + 2; end
    if dropdown.ArrowLine2 then dropdown.ArrowLine2.Thickness = 2; dropdown.ArrowLine2.zIndex = z + 2; end
    if dropdown.Border then dropdown.Border.Filled = false; dropdown.Border.Thickness = 1; dropdown.Border.zIndex = z + 12; dropdown.Border.Visible = false; dropdown.Border.Rounding = self.ActiveTheme.Rounding.Section; end

    for i, option in ipairs(dropdown.Options) do
        local optionEntry = {
            Text = self:_CreateDrawingObject("Text"),
            Highlight = self:_CreateDrawingObject("Square"),
            ClickRegion = {}
        }
        if optionEntry.Text then optionEntry.Text.Font = self.ActiveTheme.Fonts.Main; optionEntry.Text.Size = self.ActiveTheme.Fonts.Size; optionEntry.Text.Text = option; optionEntry.Text.Center = false; optionEntry.Text.Outline = false; optionEntry.Text.zIndex = z + 11; optionEntry.Text.Visible = false; end
        if optionEntry.Highlight then optionEntry.Highlight.Filled = true; optionEntry.Highlight.zIndex = z + 10; optionEntry.Highlight.Visible = false; optionEntry.Highlight.Rounding = self.ActiveTheme.Rounding.Element; end
        table.insert(dropdown.OptionList, optionEntry)
    end
    return dropdown
end

function Library:_Internal_CreateMultidropdown(options)
    if self.UI.Values[options.id] == nil then
        self.UI.Values[options.id] = options.Default or {}
    end
    local z = options.zIndex or 4
    local multidropdown = {
        id = options.id, type = "Multidropdown", Name = options.Name, Options = options.Options,
        IsOpen = false, IsClosing = false, FadeOpacity = 0.0,
        HoveredOptionIndex = 0,
        Size = {width = 120, height = 25}, Callback = options.Callback,
        Label = self:_CreateDrawingObject("Text"), Button = self:_CreateDrawingObject("Square"),
        ButtonText = self:_CreateDrawingObject("Text"), OptionList = {},
        OptionBackground = self:_CreateDrawingObject("Square"), ArrowLine1 = self:_CreateDrawingObject("Line"),
        ArrowLine2 = self:_CreateDrawingObject("Line"), ClickRegion = {},
        Border = self:_CreateDrawingObject("Square"),
        Glow = self:_Internal_CreateGlowSet(z + 8),
        CurrentButtonColor = {0,0,0,0}
    }
    if multidropdown.Label then multidropdown.Label.Font = self.ActiveTheme.Fonts.Main; multidropdown.Label.Size = self.ActiveTheme.Fonts.Size + 2; multidropdown.Label.Text = multidropdown.Name; multidropdown.Label.Center = false; multidropdown.Label.Outline = false; multidropdown.Label.zIndex = z; end
    if multidropdown.Button then multidropdown.Button.Filled = true; multidropdown.Button.zIndex = z; multidropdown.Button.Rounding = self.ActiveTheme.Rounding.Element; end
    if multidropdown.ButtonText then multidropdown.ButtonText.Font = self.ActiveTheme.Fonts.Main; multidropdown.ButtonText.Size = self.ActiveTheme.Fonts.Size + 3; multidropdown.ButtonText.Text = ""; multidropdown.ButtonText.Center = false; multidropdown.ButtonText.Outline = false; multidropdown.ButtonText.zIndex = z + 1; end
    if multidropdown.OptionBackground then multidropdown.OptionBackground.Filled = true; multidropdown.OptionBackground.zIndex = z + 9; multidropdown.OptionBackground.Visible = false; multidropdown.OptionBackground.Rounding = self.ActiveTheme.Rounding.Section; end
    if multidropdown.ArrowLine1 then multidropdown.ArrowLine1.Thickness = 2; multidropdown.ArrowLine1.zIndex = z + 2; end
    if multidropdown.ArrowLine2 then multidropdown.ArrowLine2.Thickness = 2; multidropdown.ArrowLine2.zIndex = z + 2; end
    if multidropdown.Border then multidropdown.Border.Filled = false; multidropdown.Border.Thickness = 1; multidropdown.Border.zIndex = z + 12; multidropdown.Border.Visible = false; multidropdown.Border.Rounding = self.ActiveTheme.Rounding.Section; end

    for i, option in ipairs(multidropdown.Options) do
        local optionEntry = {
            Text = self:_CreateDrawingObject("Text"),
            Highlight = self:_CreateDrawingObject("Square"),
            CheckmarkLine1 = self:_CreateDrawingObject("Line"), -- << ДОБАВЛЕНО
            CheckmarkLine2 = self:_CreateDrawingObject("Line"), -- << ДОБАВЛЕНО
            ClickRegion = {}
        }
        if optionEntry.Text then optionEntry.Text.Font = self.ActiveTheme.Fonts.Main; optionEntry.Text.Size = self.ActiveTheme.Fonts.Size; optionEntry.Text.Text = option; optionEntry.Text.Center = false; optionEntry.Text.Outline = false; optionEntry.Text.zIndex = z + 11; optionEntry.Text.Visible = false; end
        if optionEntry.Highlight then optionEntry.Highlight.Filled = true; optionEntry.Highlight.zIndex = z + 10; optionEntry.Highlight.Visible = false; optionEntry.Highlight.Rounding = self.ActiveTheme.Rounding.Element; end
        -- << НАСТРОЙКА ГАЛОЧКИ >>
        if optionEntry.CheckmarkLine1 then optionEntry.CheckmarkLine1.Thickness = 2; optionEntry.CheckmarkLine1.zIndex = z + 12; optionEntry.CheckmarkLine1.Visible = false; end
        if optionEntry.CheckmarkLine2 then optionEntry.CheckmarkLine2.Thickness = 2; optionEntry.CheckmarkLine2.zIndex = z + 12; optionEntry.CheckmarkLine2.Visible = false; end
        table.insert(multidropdown.OptionList, optionEntry)
    end
    return multidropdown
end

function Library:_Internal_CreateKeybind(options)
    if self.UI.Values[options.id] == nil then
        self.UI.Values[options.id] = options.Default or "none"
    end
    local z = options.zIndex or 4
    local keybind = {
        id = options.id,
        type = "Keybind",
        Name = options.Name,
        ParentToggleID = options.ParentToggleID, -- << ДОБАВЛЕНО
        ParentToggleName = options.ParentToggleName, -- << ДОБАВЛЕНО
        Label = self:_CreateDrawingObject("Text"),
        Size = {width = 100, height = 25},
        Callback = options.Callback,
        Button = self:_CreateDrawingObject("Square"),
        Border = self:_CreateDrawingObject("Square"),
        ButtonText = self:_CreateDrawingObject("Text"),
        IsListening = false,
        ClickRegion = {}
    }
    if keybind.Label then -- << ДОБАВЛЕН БЛОК
        keybind.Label.Font = self.ActiveTheme.Fonts.Main; keybind.Label.Size = self.ActiveTheme.Fonts.Size + 2; keybind.Label.Text = keybind.Name; keybind.Label.Center = false; keybind.Label.Outline = false; keybind.Label.zIndex = z;
    end
    if keybind.Button then
        keybind.Button.Filled = true; keybind.Button.zIndex = z; keybind.Button.Rounding = self.ActiveTheme.Rounding.Element;
    end
    if keybind.Border then
        keybind.Border.Filled = false; keybind.Border.Thickness = 1; keybind.Border.zIndex = z + 1; keybind.Border.Rounding = self.ActiveTheme.Rounding.Element;
    end
    if keybind.ButtonText then
        keybind.ButtonText.Font = self.ActiveTheme.Fonts.Main; keybind.ButtonText.Size = self.ActiveTheme.Fonts.Size; keybind.ButtonText.Text = self.UI.Values[keybind.id]; keybind.ButtonText.Center = true; keybind.ButtonText.Outline = false; keybind.ButtonText.zIndex = z + 1;
    end
    return keybind
end

--================================================================
--[[ PUBLIC API ]]
--================================================================

function Library:Tab(options)
    local tabGroupName = options.Group
    local tabName = options.Name

    local existingGroup; for _, group in ipairs(self.UI.TabGroups) do if group.Name == tabGroupName then existingGroup = group; break end end

    if not existingGroup then
        existingGroup = { Name = tabGroupName, Header = self:_CreateDrawingObject("Text"), Tabs = {} }
        if existingGroup.Header then existingGroup.Header.Font = self.ActiveTheme.Fonts.Main; existingGroup.Header.Size = self.ActiveTheme.Fonts.TabHeaderSize; existingGroup.Header.Text = existingGroup.Name; existingGroup.Header.Center = false; existingGroup.Header.Outline = false; existingGroup.Header.zIndex = 3; end
        table.insert(self.UI.TabGroups, existingGroup)
    end

    local tab_obj = {
        Name = tabName,
        Text = self:_CreateDrawingObject("Text"),
        Icon = nil,
        ClickRegion = {},
        --[[ НОВОЕ: Персональный объект подсветки для вкладки ]]
        Highlight = self:_CreateDrawingObject("Square")
    }
    if tab_obj.Highlight then
        tab_obj.Highlight.Filled = true
        tab_obj.Highlight.zIndex = 2
        tab_obj.Highlight.Rounding = self.ActiveTheme.Rounding.Element + 3
        tab_obj.Highlight.Visible = true -- Он всегда видим, но может быть прозрачным
    end
    if tab_obj.Text then tab_obj.Text.Font = self.ActiveTheme.Fonts.Main; tab_obj.Text.Size = self.ActiveTheme.Fonts.TabSize; tab_obj.Text.Text = tabName; tab_obj.Text.Center = false; tab_obj.Text.Outline = false; tab_obj.Text.zIndex = 3; end
    if options.Icon then tab_obj.Icon = self:_CreateDrawingObject("Image"); if tab_obj.Icon then tab_obj.Icon.Url = options.Icon; tab_obj.Icon.Size = {self.ActiveTheme.IconSize, self.ActiveTheme.IconSize}; tab_obj.Icon.zIndex = 3; end end

    if self.Window.ActiveTab == "" then self.Window.ActiveTab = tabName end
    table.insert(existingGroup.Tabs, tab_obj)

    local self_lib = self
    local TabObject = {};
    function TabObject:Section(sectionOptions) sectionOptions.ParentTab = tabName; return self_lib:Section(sectionOptions) end
    return TabObject
end

function Library:Section(options)
    local section = {
        Title = options.Name, ParentTab = options.ParentTab, Side = options.Side or "Left", Elements = {},
        Drawing = { Background = self:_CreateDrawingObject("Square"), Border = self:_CreateDrawingObject("Square"), Title = self:_CreateDrawingObject("Text"), Separator = self:_CreateDrawingObject("Line") }
    }
    if section.Drawing.Background then section.Drawing.Background.Filled = true; section.Drawing.Background.zIndex = 2; section.Drawing.Background.Rounding = self.ActiveTheme.Rounding.Section; end
    if section.Drawing.Border then section.Drawing.Border.Filled = false; section.Drawing.Border.Thickness = 1; section.Drawing.Border.zIndex = 3; section.Drawing.Border.Rounding = self.ActiveTheme.Rounding.Section; end
    if section.Drawing.Title then section.Drawing.Title.Font = self.ActiveTheme.Fonts.Main; section.Drawing.Title.Size = self.ActiveTheme.Fonts.Size + 10; section.Drawing.Title.Text = section.Title; section.Drawing.Title.Center = false; section.Drawing.Title.Outline = false; section.Drawing.Title.zIndex = 4; end
    if section.Drawing.Separator then section.Drawing.Separator.Thickness = 2; section.Drawing.Separator.zIndex = 3; end

    table.insert(self.UI.Sections, section)

    local self_lib = self
    local SectionObject = {}
    local last_element = nil -- Ссылка на последний добавленный элемент для цепочки

    -- Определяем все методы для SectionObject, чтобы их можно было вызывать в цепочке.

    function SectionObject:Toggle(toggleOptions)
        last_element = self_lib:_Internal_CreateToggle(toggleOptions)
        table.insert(section.Elements, last_element)
        return SectionObject -- Всегда возвращаем SectionObject для продолжения цепочки
    end

    function SectionObject:Slider(sliderOptions) 
        last_element = self_lib:_Internal_CreateSlider(sliderOptions)
        table.insert(section.Elements, last_element)
        return SectionObject 
    end
    
    function SectionObject:Dropdown(dropdownOptions) 
        last_element = self_lib:_Internal_CreateDropdown(dropdownOptions)
        table.insert(section.Elements, last_element)
        return SectionObject 
    end
    
    function SectionObject:Multidropdown(multidropdownOptions) 
        last_element = self_lib:_Internal_CreateMultidropdown(multidropdownOptions)
        table.insert(section.Elements, last_element)
        return SectionObject 
    end

    -- Метод Keybind теперь является частью SectionObject.
    -- Он будет работать корректно, только если вызван сразу после Toggle.
    function SectionObject:Keybind(keybindOptions)
        if last_element and last_element.type == "Toggle" then
            -- Привязываем информацию о родительском Toggle к самому кейбинду
            keybindOptions.ParentToggleID = last_element.id
            keybindOptions.ParentToggleName = last_element.Name
            
            local keybind_element = self_lib:_Internal_CreateKeybind(keybindOptions)
            
            -- Добавляем кейбинд в список настроек родительского Toggle
            if not last_element.SettingsElements then last_element.SettingsElements = {} end
            table.insert(last_element.SettingsElements, keybind_element)
        else
            warn(SCRIPT_PREFIX .. "Keybind() can only be chained after a Toggle() element.")
        end
        return SectionObject -- Всегда возвращаем SectionObject для продолжения цепочки
    end

    return SectionObject
end


function Library:Unload()
    self.Window.Visible = false
    for _, obj in ipairs(self.UI.DrawingObjects) do if obj and obj.Remove then pcall(obj.Remove, obj) end end
    self.UI.DrawingObjects = {}; print(SCRIPT_PREFIX .. "UI Unloaded.")
end

function Library:Create()
    self:_InitializeCoreUI()
    setmetatable(self.AnimationState, {__mode = "k"}) -- Делаем ключи слабыми для авто-очистки
    
    -- Config System Initialization
    if not checkfolder(self.ConfigFolderPath) then
        makefolder(self.ConfigFolderPath)
        print(SCRIPT_PREFIX .. "Created config folder: " .. self.ConfigFolderPath)
    end
    
    local files = listfiles(self.ConfigFolderPath)
    if not files or #files == 0 then
        print(SCRIPT_PREFIX .. "No configs found. Creating 'default.cfg'...")
        self:_SaveConfig("default")
    end

    self:_RefreshConfigList()
    if self.UI.Core.ConfigsTab.Items[1] then
        self:_LoadConfig(self.UI.Core.ConfigsTab.Items[1].Name)
    end

    spawn(function() self:_MainLoop() end)
    return self
end

function Library:ToggleVisibility()
    -- Не прерываем текущую анимацию
    if self.GlobalAnimation.IsHiding or self.GlobalAnimation.IsShowing then return end

    if self.GlobalAnimation.Opacity == 1 then
        self.GlobalAnimation.IsHiding = true
    else
        self.GlobalAnimation.Opacity = 0 -- Убеждаемся, что начинаем с нуля
        self.Window.Visible = true      -- ВАЖНО: запускаем рендер-цикл для анимации появления
        self.GlobalAnimation.IsShowing = true
    end
end

function Library:_CheckGlobalBinds()
    if self.UI.Popups.ColorPicker.IsOpen or self.UI.Popups.EditStyle.IsOpen then
        return
    end
    
    local key = getpressedkey()
    if key and key ~= "None" then
        if key == self.UI.Values["ToggleUIBind"] then
            if (tick() - self.lastUIToggleTime) > 0.3 then
                self:ToggleVisibility()
                self.lastUIToggleTime = tick()
            end
            return -- Выходим, чтобы не обрабатывать другие бинды одновременно
        end
        
        -- Защита от многократного срабатывания
        if (tick() - (lastBindCheckTime or 0)) < 0.2 then return end

        -- Ищем совпадение с биндами элементов
        for _, section in ipairs(self.UI.Sections) do
            for _, el in ipairs(section.Elements) do
                if el.SettingsElements then
                    for _, setting_el in ipairs(el.SettingsElements) do
                        if setting_el.type == "Keybind" and self.UI.Values[setting_el.id] == key then
                            lastBindCheckTime = tick()

                            -- Переключаем значение родительского Toggle
                            local toggle_id = setting_el.ParentToggleID
                            local new_state = not self.UI.Values[toggle_id]
                            self.UI.Values[toggle_id] = new_state

                            -- Обновляем список активных хоткеев
                            local hk = self.UI.Hotkeys
                            local existingBindIndex = nil
                            for i, bind in ipairs(hk.ActiveBinds) do
                                if bind.id == toggle_id then
                                    existingBindIndex = i
                                    break
                                end
                            end

                            if new_state and not existingBindIndex then
                                -- Добавляем новый активный бинд
                                table.insert(hk.ActiveBinds, {
                                    id = toggle_id,
                                    Name = setting_el.ParentToggleName,
                                    FadeOpacity = 0.0,
                                    IsClosing = false
                                })
                            elseif not new_state and existingBindIndex then
                                -- Помечаем существующий бинд на удаление (для анимации)
                                hk.ActiveBinds[existingBindIndex].IsClosing = true
                            end
                            
                            -- Вызываем оригинальный Callback, если он есть
                            if el.Callback then pcall(el.Callback, new_state) end
                            return -- Выходим после обработки первого найденного бинда
                        end
                    end
                end
            end
        end
    end
end

return Library
