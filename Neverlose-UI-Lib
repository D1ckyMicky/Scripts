--[[
    Neverlose.cc Style UI Library for Severe
    Version: 16.1 (Config System - Hotfix)
    Developer: Gemini AI & Dicky_Micky_

    - [FIX] Changed config file extension from .json to .cfg to avoid 'banned file extension' error in Severe.
    - [NEW] Implemented the core config saving/loading system using the file system.
    - [NEW] The library now automatically creates a 'NL_Configs' folder on startup.
    - [NEW] On first launch (or if no configs exist), a 'default.cfg' config is created with the default values of all UI elements.
    - [NEW] The 'Configs' tab now dynamically loads and displays all .cfg files found in the 'NL_Configs' folder.
    - [UPDATE] The 'Save' button now saves the current UI values to the selected config file.
    - [UPDATE] The 'Load' button now loads UI values from the selected config file.
    - [INTERNAL] Removed 'DummyData' in favor of the new dynamic system.
]]

local Library = {}

--================================================================
--[[ PRIVATE: CORE PROPERTIES & CONFIGURATION ]]
--================================================================

Library.AnimationState = {} -- Хранилище для состояний анимации
Library.GlobalAnimation = { IsHiding = false, IsShowing = false, Opacity = 1.0 }
Library.lastUIToggleTime = 0

Library.Window = {
    Visible = true, X = 400, Y = 200, Width = 750, Height = 620,
    SidebarWidth = 187, HeaderHeight = 65, IsDragging = false,
    ActiveTab = "", PanelOverlap = 4,
    LastRenderedTab = "",
    Animation = { State = "IDLE", OldTab = nil } -- << ИЗМЕНИ ЭТУ СТРОКУ
}

Library.ConfigFolderPath = "NL_Configs" -- Новая папка для конфигов

Library.Themes = {
    Blue = {
        Name = "Blue", IsPreset = true,
        Fonts = { Title = 2, Main = 1, Size = 14, TitleSize = 27, TabSize = 18, TabHeaderSize = 12 },
        Colors = { 
            MainBackground = {6, 9, 17, 245}, SectionBackground = {3, 11, 23, 255}, SidebarBackground = {11, 20, 33, 204}, 
            Separator = {0, 18, 32, 255}, Accent = {24, 165, 232, 255}, DarkBlue = {3, 23, 51, 255}, 
            DarkGray = {24, 24, 24, 255}, LightGray = {77, 77, 76, 255}, 
            TextPrimary = {234, 239, 245, 255}, TextSecondary = {160, 181, 197, 255}, 
            TabHeader = {100, 120, 140, 255}, GlowColor = {7, 70, 99, 255}, GlowAccent = {24, 165, 232, 255},
            TextLight = {234, 239, 245, 255}, TextDark = {60, 60, 60, 255}
        },
        Transparency = { Solid = 0.9, ActiveTabHighlight = 0.28 },
        Rounding = { Window = 8, Section = 6, Element = 4, Button = 5 }, IconSize = 16
    },
    Black = {
        Name = "Black", IsPreset = true,
        Fonts = { Title = 2, Main = 1, Size = 14, TitleSize = 27, TabSize = 18, TabHeaderSize = 12 },
        Colors = { 
            MainBackground = {6, 6, 9, 247}, SectionBackground = {0, 3, 5, 255}, SidebarBackground = {14, 16, 19, 230}, 
            Separator = {11, 11, 11, 255}, Accent = {72, 130, 255, 255}, DarkBlue = {10, 11, 19, 255}, 
            DarkGray = {24, 24, 24, 255}, LightGray = {77, 77, 76, 255}, 
            TextPrimary = {234, 239, 245, 255}, TextSecondary = {181, 181, 194, 255}, 
            TabHeader = {111, 120, 130, 255}, GlowColor = {22, 39, 77, 255}, GlowAccent = {72, 130, 255, 255},
            TextLight = {234, 239, 245, 255}, TextDark = {60, 60, 60, 255}
        },
        Transparency = { Solid = 0.9, ActiveTabHighlight = 0.28 },
        Rounding = { Window = 8, Section = 6, Element = 4, Button = 5 }, IconSize = 16
    },
    White = {
        Name = "White", IsPreset = true,
        Fonts = { Title = 2, Main = 1, Size = 14, TitleSize = 27, TabSize = 18, TabHeaderSize = 12 },
        Colors = { 
            MainBackground = {250, 250, 255, 247}, SectionBackground = {244, 244, 244, 255}, SidebarBackground = {240, 240, 240, 230}, 
            Separator = {200, 200, 200, 255}, Accent = {24, 165, 232, 255}, DarkBlue = {220, 220, 220, 255}, 
            DarkGray = {165, 165, 165, 255}, LightGray = {120, 120, 120, 255}, 
            TextPrimary = {10, 10, 10, 255}, TextSecondary = {60, 60, 60, 255}, 
            TabHeader = {100, 100, 100, 255}, GlowColor = {7, 70, 99, 255}, GlowAccent = {24, 165, 232, 255},
            TextLight = {234, 239, 245, 255}, TextDark = {60, 60, 60, 255}
        },
        Transparency = { Solid = 0.9, ActiveTabHighlight = 0.28 },
        Rounding = { Window = 8, Section = 6, Element = 4, Button = 5 }, IconSize = 16
    }
}
Library.ActiveTheme = Library.Themes.Blue
Library.CustomThemeCounter = 0
Library.TempTheme = nil
Library.PreEditThemeName = nil

Library.UI = { TabGroups = {}, Sections = {}, Values = {}, DrawingObjects = {}, Popups = {} }

local drag_offset = {x = 0, y = 0}
local was_left_pressed = false
local is_dragging_something = false
local lastToggleTime = 0
local toggleDelay = 0.5
local SCRIPT_PREFIX = "[NL UI Lib] "
local lastAutoSaveTime = 0
local autoSaveInterval = 15 -- Интервал в секундах (можно изменить)
local lastBindCheckTime = 0 -- Для глобальной проверки биндов 

--================================================================
--[[ PRIVATE: COLOR CONVERSION FUNCTIONS (PLACEHOLDERS) ]]
--================================================================

-- ВСТАВЬТЕ СЮДА ФУНКЦИЮ _HSVtoRGB
function Library:_HSVtoRGB(h, s, v)
    local r, g, b

    local i = math.floor(h * 6)
    local f = h * 6 - i
    local p = v * (1 - s)
    local q = v * (1 - f * s)
    local t = v * (1 - (1 - f) * s)

    i = i % 6

    if i == 0 then r, g, b = v, t, p
    elseif i == 1 then r, g, b = q, v, p
    elseif i == 2 then r, g, b = p, v, t
    elseif i == 3 then r, g, b = p, q, v
    elseif i == 4 then r, g, b = t, p, v
    elseif i == 5 then r, g, b = v, p, q
    end

    -- Возвращаем таблицу {r, g, b} со значениями от 0 до 255,
    -- как того требует библиотека Drawing.
    return { r * 255, g * 255, b * 255 }
end

-- ВСТАВЬТЕ СЮДА ФУНКЦИЮ _RGBtoHSV
function Library:_RGBtoHSV(r, g, b, a)
    r, g, b = r / 255, g / 255, b / 255
    local max, min = math.max(r, g, b), math.min(r, g, b)
    local h, s, v = max, max, max

    local d = max - min
    s = max == 0 and 0 or d / max

    if max == min then
        h = 0
    else
        if max == r then
            h = (g - b) / d + (g < b and 6 or 0)
        elseif max == g then
            h = (b - r) / d + 2
        elseif max == b then
            h = (r - g) / d + 4
        end
        h = h / 6
    end

    return h, s, v, (a or 255) / 255
end

--================================================================
--[[ PRIVATE: HELPER FUNCTIONS ]]
--================================================================

function Library:_CreateDrawingObject(class)
    local success, object = pcall(Drawing.new, class)
    if not success then warn(SCRIPT_PREFIX .. "Failed to create Drawing object of type:", class); return nil end
    table.insert(self.UI.DrawingObjects, object)
    return object
end

function Library:_DeepCopy(original)
    local copy = {}
    for k, v in pairs(original) do
        if type(v) == "table" then
            v = self:_DeepCopy(v)
        end
        copy[k] = v
    end
    return copy
end

function Library:_DarkenColor(color, factor)
    factor = factor or 0.3
    return { math.max(0, math.floor(color[1] * factor)), math.max(0, math.floor(color[2] * factor)), math.max(0, math.floor(color[3] * factor)), color[4] or 255 }
end

function Library:_IsThemeLight(theme)
    local bg = theme.Colors.MainBackground
    if not bg then return false end
    -- Using luminance formula to determine brightness
    local brightness = (bg[1] * 0.299 + bg[2] * 0.587 + bg[3] * 0.114)
    return brightness > 150 -- Threshold for what is considered a "light" background
end

function Library:_getAvatarThumbnail(userId)
    local url = string.format("https://thumbnails.roblox.com/v1/users/avatar-headshot?userIds=%d&size=420x420&format=Png&isCircular=true", userId)
    local success, response = pcall(function() return httpget(url, "application/json") end)
    if success then
        local decoded = JSONDecode(response)
        if decoded and decoded.data and decoded.data[1] and decoded.data[1].imageUrl then
            return decoded.data[1].imageUrl
        end
    end
    return nil
end

function Library:_SafeNumber(value, default) return type(value) == "number" and value or (default or 0) end
function Library:_IsPointInRegion(x, y, region)
    if not region or not region.x1 or not region.x2 or not region.y1 or not region.y2 then return false end
    return x >= self:_SafeNumber(region.x1, 0) and x <= self:_SafeNumber(region.x2, 0) and y >= self:_SafeNumber(region.y1, 0) and y <= self:_SafeNumber(region.y2, 0)
end
function Library:_SetVisibility(object, visible) if object and object.Visible ~= visible then object.Visible = visible end end
function table.find(tbl, value) for i, v in ipairs(tbl) do if v == value then return i end end; return nil end

-- Вставьте эту новую функцию в раздел PRIVATE: HELPER FUNCTIONS
function Library:_CleanupDrawingObjects(tbl)
    for _, v in pairs(tbl) do
        if type(v) == 'table' then
            if v.Remove and type(v.Remove) == 'function' then
                -- Это объект отрисовки, удаляем его
                pcall(v.Remove, v)
            else
                -- Это обычная таблица, идем глубже
                self:_CleanupDrawingObjects(v)
            end
        end
    end
end

-- Новая функция для плавной смены цвета (анимации)
function Library:_LerpColor(from, to, alpha)
    -- Проверка на случай, если одна из таблиц некорректна
    if type(from) ~= "table" or type(to) ~= "table" then 
        return to or from or {0, 0, 0, 255} 
    end

    -- Интерполяция с использованием значений по умолчанию для каждого канала
    local r = (from[1] or 0) + ((to[1] or 0) - (from[1] or 0)) * alpha
    local g = (from[2] or 0) + ((to[2] or 0) - (from[2] or 0)) * alpha
    local b = (from[3] or 0) + ((to[3] or 0) - (from[3] or 0)) * alpha
    local a = (from[4] or 255) + ((to[4] or 255) - (from[4] or 255)) * alpha
    
    return {r, g, b, a}
end

-- Новая функция для отрисовки подсказки у кнопки Save
function Library:_RenderSaveTooltip()
    local tooltip = self.UI.Core.SaveTooltip
    local saveBtn = self.UI.Core.HeaderButtons.Save
    local isVisible = saveBtn.IsHovered
    local theme = self.ActiveTheme

    self:_SetVisibility(tooltip.Background, isVisible)
    self:_SetVisibility(tooltip.Border, isVisible)
    self:_SetVisibility(tooltip.ConfigName, isVisible)
    self:_SetVisibility(tooltip.Author, isVisible)

    if isVisible then
        self:_AnimateAndApplyColor(tooltip.Background, theme.Colors.SectionBackground)
        self:_AnimateAndApplyColor(tooltip.Border, theme.Colors.Separator)
        self:_AnimateAndApplyColor(tooltip.ConfigName, theme.Colors.TextPrimary)
        self:_AnimateAndApplyColor(tooltip.Author, theme.Colors.TextSecondary)
    
        local configName = self.UI.Core.ConfigsTab.LoadedConfigName
        if configName == "" then configName = "default" end
        tooltip.ConfigName.Text = "Config \"" .. configName .. "\""
        tooltip.Author.Text = "Author: " .. (self.UI.Core.PlayerDisplayName.Text or "user")

        local padding = 16
        local configNameWidth = tooltip.ConfigName.TextBounds and tooltip.ConfigName.TextBounds.x or 100
        local authorWidth = tooltip.Author.TextBounds and tooltip.Author.TextBounds.x or 100
        local tooltipW = math.max(configNameWidth, authorWidth) + padding
        local tooltipH = 50

        local btnRegion = saveBtn.ClickRegion
        local tooltipX, tooltipY = btnRegion.x2 + 10, btnRegion.y1

        tooltip.Background.Position = {tooltipX, tooltipY}
        tooltip.Background.Size = {tooltipW, tooltipH}
        tooltip.Border.Position = {tooltipX, tooltipY}
        tooltip.Border.Size = {tooltipW, tooltipH}
        tooltip.ConfigName.Position = {tooltipX + (padding / 2), tooltipY + 8}
        tooltip.Author.Position = {tooltipX + (padding / 2), tooltipY + 28}
        
        self:_RenderGlowEffect(tooltip.Glow, tooltipX, tooltipY, tooltipW, tooltipH, tooltip.Background.Rounding, theme.Colors.GlowColor)
    else
        self:_HideGlowEffect(tooltip.Glow)
    end
end

function Library:_AnimateAndApplyColor(drawingObject, targetColor, masterOpacity)
    if not drawingObject or type(targetColor) ~= "table" then return end

    local state = self.AnimationState[drawingObject]
    if not state then
        state = { CurrentColor = self:_DeepCopy(targetColor) }
        self.AnimationState[drawingObject] = state
    end

    local speed_value = self.UI.Values["AboutAnimationSpeed"] or 2.5 
    local animationSpeed = speed_value / 16.0

    state.CurrentColor = self:_LerpColor(state.CurrentColor, targetColor, animationSpeed)

    local color = state.CurrentColor
    if color then
        drawingObject.Color = {color[1], color[2], color[3]}
        local baseOpacity = (color[4] or 255) / 255
        
        masterOpacity = (masterOpacity == nil) and 1 or masterOpacity
        
        -- [[ НОВОЕ: Глобальная прозрачность для анимации скрытия/показа ]]
        local globalOpacity = self.GlobalAnimation and self.GlobalAnimation.Opacity or 1
        drawingObject.Opacity = baseOpacity * masterOpacity * globalOpacity
    end
end

function Library:_GetTextColorForBackground(backgroundColor)
    local theme = self.ActiveTheme
    if not backgroundColor or type(backgroundColor) ~= "table" then
        return theme.Colors.TextLight 
    end
    
    local brightness = (backgroundColor[1] * 0.299 + backgroundColor[2] * 0.587 + backgroundColor[3] * 0.114)
    
    return brightness > 140 and theme.Colors.TextDark or theme.Colors.TextLight
end

function Library:_UpdateAnimationStates()
    local still_fading_out = false
    local still_fading_in = false
    local ANIMATION_SLIDE_DISTANCE = 20
    local speed_value = self.UI.Values["AboutAnimationSpeed"] or 2.5
    local animationSpeed = (speed_value * 1.5) / 15.0

    -- === Расчет состояний для каждой секции ===
    for _, section in ipairs(self.UI.Sections) do
        local anim_state = self.AnimationState[section.Drawing.Background]
        if not anim_state then
            anim_state = { Opacity = 0, YOffset = 0 }
            self.AnimationState[section.Drawing.Background] = anim_state
        end

        local is_on_active_tab = (section.ParentTab == self.Window.ActiveTab)
        local is_on_old_tab = (self.Window.Animation.State == "FADING_OUT" and section.ParentTab == self.Window.Animation.OldTab)
        
        local targetOpacity, targetYOffset
        
        if is_on_old_tab then
            -- Цель для исчезающей секции: полная прозрачность и смещение вниз 
            targetOpacity, targetYOffset = 0, ANIMATION_SLIDE_DISTANCE
            if anim_state.Opacity > 0.01 then still_fading_out = true end
        elseif is_on_active_tab and self.Window.Animation.State ~= "FADING_OUT" then
            -- Цель для появляющейся секции: полная непрозрачность и нулевое смещение 
            targetOpacity, targetYOffset = 1, 0
            if anim_state.Opacity < 0.99 then still_fading_in = true end
        else
            -- Секция неактивна, скрываем её 
            targetOpacity, targetYOffset = 0, anim_state.YOffset
        end
        
        -- Плавно интерполируем текущие значения к целевым 
        anim_state.Opacity = anim_state.Opacity + (targetOpacity - anim_state.Opacity) * animationSpeed
        anim_state.YOffset = anim_state.YOffset + (targetYOffset - anim_state.YOffset) * animationSpeed
        
        -- Принудительно "прищелкиваем" значения в конце анимации для точности 
        if math.abs(anim_state.Opacity - targetOpacity) < 0.01 then anim_state.Opacity = targetOpacity end
        if math.abs(anim_state.YOffset - targetYOffset) < 0.01 then anim_state.YOffset = targetYOffset end
    end

    -- === Смена состояний анимации ===
    if self.Window.Animation.State == "FADING_OUT" and not still_fading_out then
        -- Исчезновение завершено, начинаем появление 
        self.Window.Animation.State = "FADING_IN"
        self.Window.Animation.OldTab = nil
        
        -- Сбрасываем начальные позиции для новых элементов, чтобы они выезжали правильно 
        for _, section in ipairs(self.UI.Sections) do
            if section.ParentTab == self.Window.ActiveTab then
                local anim_state = self.AnimationState[section.Drawing.Background]
                if anim_state then
                    anim_state.Opacity = 0
                    anim_state.YOffset = ANIMATION_SLIDE_DISTANCE
                end
            end
        end
    elseif self.Window.Animation.State == "FADING_IN" and not still_fading_in then
        -- Появление завершено, переходим в режим ожидания 
        self.Window.Animation.State = "IDLE"
    end
end

function Library:_SetSectionAndElementsVisibility(section, visible)
    -- Сначала обрабатываем собственные объекты секции (фон, заголовок и т.д.)
    for _, obj in pairs(section.Drawing) do
        if obj and obj.Visible ~= nil then self:_SetVisibility(obj, visible) end
    end

    -- Затем обрабатываем все элементы внутри секции
    for _, el in ipairs(section.Elements) do
        for key, val in pairs(el) do
            -- Проверяем, является ли значение в паре объектом для отрисовки
            if type(val) == 'table' and val.Visible ~= nil then
                self:_SetVisibility(val, visible)
            -- Отдельно обрабатываем вложенные списки, как в Dropdown
            elseif (key == 'OptionList' or key == 'Glow') and type(val) == 'table' then
                 for _, nested_obj in ipairs(val) do
                    if nested_obj and nested_obj.Visible ~= nil then self:_SetVisibility(nested_obj, visible) end
                 end
            end
        end
        -- Если мы скрываем секцию, также нужно закрыть все открытые в ней выпадающие списки
        if not visible and el.IsOpen then
            el.IsOpen = false
        end
    end
end

function Library:_EnsureDefaults(data_table, default_table)
    if type(data_table) ~= 'table' or type(default_table) ~= 'table' then
        return self:_DeepCopy(default_table) or {}
    end
    
    local result = self:_DeepCopy(data_table)
    for key, defaultValue in pairs(default_table) do
        if result[key] == nil then
            -- Если ключ полностью отсутствует в загруженных данных, копируем его из шаблона.
            result[key] = defaultValue
        elseif type(defaultValue) == 'table' and type(result[key]) == 'table' then
            -- Если ключ есть, но это тоже таблица, рекурсивно проверяем и её.
            result[key] = self:_EnsureDefaults(result[key], defaultValue)
        end
    end
    return result
end

function Library:_HideSettingsPopupElements(popup)
    if not popup or not popup.ActiveToggle or not popup.ActiveToggle.SettingsElements then
        return
    end
    for _, element in ipairs(popup.ActiveToggle.SettingsElements) do
        if element.type == "Keybind" then
            if element.Label then self:_SetVisibility(element.Label, false) end -- << ИСПРАВЛЕНИЕ
            if element.Button then self:_SetVisibility(element.Button, false) end
            if element.Border then self:_SetVisibility(element.Border, false) end
            if element.ButtonText then self:_SetVisibility(element.ButtonText, false) end
        end
    end
end

-- Вставьте эту новую функцию в раздел PRIVATE: HELPER FUNCTIONS
function Library:_SetDrawingTableVisibility(tbl, visible)
    for _, v in pairs(tbl) do
        if type(v) == 'table' then
            if v.Remove and type(v.Remove) == 'function' then
                -- Это объект отрисовки, меняем его видимость
                self:_SetVisibility(v, visible)
            else
                -- Это обычная таблица, идем глубже
                self:_SetDrawingTableVisibility(v, visible)
            end
        end
    end
end

--================================================================
--[[ PRIVATE: GLOW EFFECT HELPERS ]]
--================================================================

function Library:_Internal_CreateGlowSet(zIndex, count)
    local glowSet = {}
    count = count or 20
    for i = 1, count do
        local glowSquare = self:_CreateDrawingObject("Square")
        if glowSquare then
            glowSquare.Filled = true
            glowSquare.zIndex = zIndex - i
            table.insert(glowSet, glowSquare)
        end
    end
    return glowSet
end

function Library:_RenderGlowEffect(glowSet, x, y, width, height, rounding, targetColor, sides)
    if not glowSet or #glowSet == 0 or not targetColor then return end
    
    local animatedColor = targetColor
    -- [[ НОВОЕ: Получаем глобальную прозрачность и применяем её ]]
    local globalOpacity = self.GlobalAnimation and self.GlobalAnimation.Opacity or 1
    
    sides = sides or {top=true, bottom=true, left=true, right=true}
    local glowColorRGB = {animatedColor[1], animatedColor[2], animatedColor[3]}
    -- Умножаем на глобальную прозрачность
    local glowOpacity = ((animatedColor[4] or 255) / 255) * globalOpacity

    for i, glowSquare in ipairs(glowSet) do
        local alpha_factor = 0.24 * math.exp(-0.24 * i)
        local spread = i * 0.6
        local glowX, glowY, glowW, glowH = x, y, width, height

        if sides.left then glowX = x - spread; glowW = glowW + spread; end
        if sides.right then glowW = glowW + spread; end
        if sides.top then glowY = y - spread; glowH = glowH + spread; end
        if sides.bottom then glowH = glowH + spread; end
        
        glowSquare.Position = {glowX, glowY}
        glowSquare.Size = {glowW, glowH}
        glowSquare.Rounding = rounding + spread
        glowSquare.Color = glowColorRGB
        glowSquare.Opacity = glowOpacity * alpha_factor
        self:_SetVisibility(glowSquare, true)
    end
end

function Library:_HideGlowEffect(glowSet)
    if not glowSet then return end
    for _, glowSquare in ipairs(glowSet) do
        self:_SetVisibility(glowSquare, false)
    end
end


--================================================================
--[[ PRIVATE: INITIALIZATION & CORE UI ]]
--================================================================

function Library:_InitializeCoreUI()
    local UI = self.UI; UI.Core = {}

    UI.Core.Sidebar = { Drawing = self:_CreateDrawingObject("Square"), Glow = self:_Internal_CreateGlowSet(0) }
    UI.Core.RightPanel = { Drawing = self:_CreateDrawingObject("Square"), Glow = self:_Internal_CreateGlowSet(0) }
    UI.Core.VerticalSeparator = self:_CreateDrawingObject("Square")
    UI.Core.SidebarHeaderSeparator = self:_CreateDrawingObject("Square")
    UI.Core.RightPanelHeaderSeparator = self:_CreateDrawingObject("Square")
    
    if UI.Core.Sidebar.Drawing then UI.Core.Sidebar.Drawing.Filled = true; UI.Core.Sidebar.Drawing.zIndex = 1; UI.Core.Sidebar.Drawing.Rounding = self.ActiveTheme.Rounding.Window; end
    if UI.Core.RightPanel.Drawing then UI.Core.RightPanel.Drawing.Filled = true; UI.Core.RightPanel.Drawing.zIndex = 1; UI.Core.RightPanel.Drawing.Rounding = self.ActiveTheme.Rounding.Window; end
    if UI.Core.VerticalSeparator then UI.Core.VerticalSeparator.Filled = true; UI.Core.VerticalSeparator.zIndex = 3; end
    if UI.Core.SidebarHeaderSeparator then UI.Core.SidebarHeaderSeparator.Filled = true; UI.Core.SidebarHeaderSeparator.zIndex = 2; end
    if UI.Core.RightPanelHeaderSeparator then UI.Core.RightPanelHeaderSeparator.Filled = true; UI.Core.RightPanelHeaderSeparator.zIndex = 2; end

    UI.Core.Title = self:_CreateDrawingObject("Text"); UI.Core.Title2 = self:_CreateDrawingObject("Text"); UI.Core.Title3 = self:_CreateDrawingObject("Text")
    if UI.Core.Title then UI.Core.Title.Font = self.ActiveTheme.Fonts.Title; UI.Core.Title.Size = self.ActiveTheme.Fonts.TitleSize; UI.Core.Title.Text = "NEVERLOSE"; UI.Core.Title.Center = false; UI.Core.Title.Outline = false; UI.Core.Title.zIndex = 5; end
    if UI.Core.Title2 then UI.Core.Title2.Font = self.ActiveTheme.Fonts.Title; UI.Core.Title2.Size = self.ActiveTheme.Fonts.TitleSize; UI.Core.Title2.Text = "NEVERLOSE"; UI.Core.Title2.Center = false; UI.Core.Title2.Outline = false; UI.Core.Title2.zIndex = 4; end
    if UI.Core.Title3 then UI.Core.Title3.Font = self.ActiveTheme.Fonts.Title; UI.Core.Title3.Size = self.ActiveTheme.Fonts.TitleSize; UI.Core.Title3.Text = "NEVERLOSE"; UI.Core.Title3.Center = false; UI.Core.Title3.Outline = false; UI.Core.Title3.zIndex = 3; end

    UI.Core.SidebarBottomCircle = self:_CreateDrawingObject("Circle"); if UI.Core.SidebarBottomCircle then UI.Core.SidebarBottomCircle.Filled = false; UI.Core.SidebarBottomCircle.Thickness = 3; UI.Core.SidebarBottomCircle.zIndex = 6; UI.Core.SidebarBottomCircle.Radius = 28; end
    UI.Core.PlayerDisplayName = self:_CreateDrawingObject("Text"); if UI.Core.PlayerDisplayName then UI.Core.PlayerDisplayName.Font = self.ActiveTheme.Fonts.Main; UI.Core.PlayerDisplayName.Size = self.ActiveTheme.Fonts.Size + 2; UI.Core.PlayerDisplayName.Text = ""; UI.Core.PlayerDisplayName.Center = false; UI.Core.PlayerDisplayName.Outline = false; UI.Core.PlayerDisplayName.zIndex = 7; end
    UI.Core.TillLabel = self:_CreateDrawingObject("Text"); if UI.Core.TillLabel then UI.Core.TillLabel.Font = self.ActiveTheme.Fonts.Main; UI.Core.TillLabel.Size = self.ActiveTheme.Fonts.Size; UI.Core.TillLabel.Text = "Till:"; UI.Core.TillLabel.Center = false; UI.Core.TillLabel.Outline = false; UI.Core.TillLabel.zIndex = 7; end
    UI.Core.ForeverLabel = self:_CreateDrawingObject("Text"); if UI.Core.ForeverLabel then UI.Core.ForeverLabel.Font = self.ActiveTheme.Fonts.Main; UI.Core.ForeverLabel.Size = self.ActiveTheme.Fonts.Size; UI.Core.ForeverLabel.Text = " Forever"; UI.Core.ForeverLabel.Center = false; UI.Core.ForeverLabel.Outline = false; UI.Core.ForeverLabel.zIndex = 7; end

    UI.Core.HeaderButtons = {
        Save = { Background = self:_CreateDrawingObject("Square"), Border = self:_CreateDrawingObject("Square"), Label = self:_CreateDrawingObject("Text"), Icon = self:_CreateDrawingObject("Image"), ClickRegion = {}, ClickTime = 0, IsHovered = false, CurrentColor = {0,0,0,0} },
        ViewESP = { Background = self:_CreateDrawingObject("Square"), Border = self:_CreateDrawingObject("Square"), Label = self:_CreateDrawingObject("Text"), ClickRegion = {}, ClickTime = 0, IsOpen = false },
        CreateNew = { Background = self:_CreateDrawingObject("Square"), Border = self:_CreateDrawingObject("Square"), Label = self:_CreateDrawingObject("Text"), Icon = self:_CreateDrawingObject("Image"), ClickRegion = {}, ClickTime = 0 },
        Settings = { Icon = self:_CreateDrawingObject("Image"), ClickRegion = {} }
    }
    
    UI.Core.SaveTooltip = {
        Background = self:_CreateDrawingObject("Square"),
        Border = self:_CreateDrawingObject("Square"),
        Glow = self:_Internal_CreateGlowSet(49),
        ConfigName = self:_CreateDrawingObject("Text"),
        Author = self:_CreateDrawingObject("Text")
    }
    
    self.UI.Popups.About = { IsOpen = false }

    local function setupHeaderButton(button, text, has_icon)
        if button.Background then button.Background.Filled = true; button.Background.zIndex = 2; button.Background.Rounding = self.ActiveTheme.Rounding.Button; end
        if button.Border then button.Border.Filled = false; button.Border.Thickness = 1; button.Border.zIndex = 3; button.Border.Rounding = self.ActiveTheme.Rounding.Button; end
        if button.Label then button.Label.Font = self.ActiveTheme.Fonts.Main; button.Label.Size = self.ActiveTheme.Fonts.Size; button.Label.Text = text; button.Label.Center = false; button.Label.Outline = false; button.Label.zIndex = 4; end
        if button.Icon and has_icon then button.Icon.Size = {13.33, 13.33}; button.Icon.zIndex = 5; button.Icon.Visible = true;
        else if button.Icon then button.Icon.Visible = false end end
    end
    setupHeaderButton(UI.Core.HeaderButtons.Save, " Save", true)
    setupHeaderButton(UI.Core.HeaderButtons.ViewESP, "View ESP", false)
    setupHeaderButton(UI.Core.HeaderButtons.CreateNew, " Create new", true)
    
    if UI.Core.HeaderButtons.Save.Icon then UI.Core.HeaderButtons.Save.Icon.Url = "https://s6.imgcdn.dev/Y4Sudt.png"; end
    if UI.Core.HeaderButtons.CreateNew.Icon then UI.Core.HeaderButtons.CreateNew.Icon.Url = "https://i.imgur.com/plus-sign-icon.png"; end
    if UI.Core.HeaderButtons.Settings.Icon then UI.Core.HeaderButtons.Settings.Icon.Url = "https://s6.imgcdn.dev/Y4SCjT.png"; UI.Core.HeaderButtons.Settings.Icon.Size = {20, 20}; UI.Core.HeaderButtons.Settings.Icon.zIndex = 5; end

    local tooltip = UI.Core.SaveTooltip
    if tooltip.Background then tooltip.Background.Filled = true; tooltip.Background.zIndex = 50; tooltip.Background.Rounding = self.ActiveTheme.Rounding.Element; end
    if tooltip.Border then tooltip.Border.Filled = false; tooltip.Border.Thickness = 1; tooltip.Border.zIndex = 51; tooltip.Border.Rounding = self.ActiveTheme.Rounding.Element; end
    if tooltip.ConfigName then tooltip.ConfigName.Font = self.ActiveTheme.Fonts.Main; tooltip.ConfigName.Size = self.ActiveTheme.Fonts.Size + 2; tooltip.ConfigName.zIndex = 51; end
    if tooltip.Author then tooltip.Author.Font = self.ActiveTheme.Fonts.Main; tooltip.Author.Size = self.ActiveTheme.Fonts.Size; tooltip.Author.zIndex = 51; end

    UI.Core.ViewESPPanel = self:_CreateDrawingObject("Square"); if UI.Core.ViewESPPanel then UI.Core.ViewESPPanel.Filled = true; UI.Core.ViewESPPanel.zIndex = 1; UI.Core.ViewESPPanel.Rounding = self.ActiveTheme.Rounding.Window; end
    UI.Core.ViewESPImage = self:_CreateDrawingObject("Image"); if UI.Core.ViewESPImage then UI.Core.ViewESPImage.zIndex = 2; UI.Core.ViewESPImage.Visible = false; UI.Core.ViewESPImage.Url = "https://s6.imgcdn.dev/Y4wqGT.jpg"; UI.Core.ViewESPImage.Rounding = self.ActiveTheme.Rounding.Window - 2; end
    UI.Core.ViewESPPanelBorder = self:_CreateDrawingObject("Square"); if UI.Core.ViewESPPanelBorder then UI.Core.ViewESPPanelBorder.Filled = false; UI.Core.ViewESPPanelBorder.Thickness = 1; UI.Core.ViewESPPanelBorder.zIndex = 3; UI.Core.ViewESPPanelBorder.Rounding = self.ActiveTheme.Rounding.Window; end

    self:_InitializeAboutWindow()
    self:_InitializeSettingsPopup()
    self:_InitializeEditStyleWindow()
    self:_InitializeColorPickerWindow()
    self:_InitializeConfigsTab()

    local Players = game:FindService("Players")
    if Players and Players.localPlayer then
        local localPlayerName = Players.localPlayer.Name
        UI.Core.PlayerDisplayName.Text = localPlayerName
        if UI.Core.AboutWindow.InfoRegisteredToValue then UI.Core.AboutWindow.InfoRegisteredToValue.Text = " " .. localPlayerName end
        local userId = Players.localPlayer.UserId
        if userId and userId > 0 then
            local avatarUrl; pcall(function() avatarUrl = self:_getAvatarThumbnail(userId) end)
            if avatarUrl then
                UI.Core.SidebarAvatar = self:_CreateDrawingObject("Image")
                if UI.Core.SidebarAvatar then UI.Core.SidebarAvatar.Size = {56, 56}; UI.Core.SidebarAvatar.Position = {0, 0}; UI.Core.SidebarAvatar.Opacity = 1; UI.Core.SidebarAvatar.Visible = true; UI.Core.SidebarAvatar.zIndex = 4; UI.Core.SidebarAvatar.Url = avatarUrl; UI.Core.SidebarAvatar.Rounding = 28; end
            end
        end
    end
    
    UI.Core.HeaderButtons.Save.CurrentColor = self:_DeepCopy(self.ActiveTheme.Colors.MainBackground)
end

function Library:_InitializeAboutWindow()
    local about = {}; self.UI.Core.AboutWindow = about; local about_z = 32
    about.StyleCircles = {}
    about.HoveredThemeCircle = { Name = nil, HoverStartTime = 0 }
    about.Background = self:_CreateDrawingObject("Square"); if about.Background then about.Background.Filled = true; about.Background.zIndex = 30; about.Background.Rounding = self.ActiveTheme.Rounding.Section; end
    about.Border = self:_CreateDrawingObject("Square"); if about.Border then about.Border.Filled = false; about.Border.Thickness = 1; about.Border.zIndex = 31; about.Border.Rounding = self.ActiveTheme.Rounding.Section; end
    about.Glow = self:_Internal_CreateGlowSet(29)
    about.HeaderIcon = self:_CreateDrawingObject("Image"); if about.HeaderIcon then about.HeaderIcon.Url = "https://s6.imgcdn.dev/Y4SCjT.png"; about.HeaderIcon.Size = {16, 16}; about.HeaderIcon.zIndex = about_z; end
    about.HeaderTitle = self:_CreateDrawingObject("Text"); if about.HeaderTitle then about.HeaderTitle.Font = self.ActiveTheme.Fonts.Main; about.HeaderTitle.Size = self.ActiveTheme.Fonts.Size + 2; about.HeaderTitle.Text = "About Neverlose"; about.HeaderTitle.Center = false; about.HeaderTitle.zIndex = about_z; end
    about.CloseButton = { Line1 = self:_CreateDrawingObject("Line"), Line2 = self:_CreateDrawingObject("Line"), ClickRegion = {} }; if about.CloseButton.Line1 then about.CloseButton.Line1.Thickness = 2; about.CloseButton.Line1.zIndex = about_z; end; if about.CloseButton.Line2 then about.CloseButton.Line2.Thickness = 2; about.CloseButton.Line2.zIndex = about_z; end

    local separatorThickness = 2
    about.Separator1 = self:_CreateDrawingObject("Line"); if about.Separator1 then about.Separator1.Thickness = separatorThickness; about.Separator1.zIndex = 31; end
    about.MainTitle = self:_CreateDrawingObject("Text"); if about.MainTitle then about.MainTitle.Font = self.ActiveTheme.Fonts.Title; about.MainTitle.Size = 27; about.MainTitle.Text = "NEVERLOSE.CC"; about.MainTitle.Center = true; about.MainTitle.zIndex = about_z; end
    about.Separator2 = self:_CreateDrawingObject("Line"); if about.Separator2 then about.Separator2.Thickness = separatorThickness; about.Separator2.zIndex = 31; end

    local function setupInfoText(label_text, value_text)
        local label = self:_CreateDrawingObject("Text"); local value = self:_CreateDrawingObject("Text")
        if label then label.Font = self.ActiveTheme.Fonts.Main; label.Size = self.ActiveTheme.Fonts.Size + 2; label.Text = label_text; label.Center = false; label.zIndex = about_z; end
        if value then value.Font = self.ActiveTheme.Fonts.Main; value.Size = self.ActiveTheme.Fonts.Size + 2; value.Text = value_text; value.Center = false; value.zIndex = about_z; end
        return label, value
    end
    about.InfoVersionLabel, about.InfoVersionValue = setupInfoText("Version:", " 2.0.0")
    about.InfoBuildDateLabel, about.InfoBuildDateValue = setupInfoText("Build date:", " Dec 30 2020")
    about.InfoBuildTypeLabel, about.InfoBuildTypeValue = setupInfoText("Build type:", " Release")
    about.InfoRegisteredToLabel, about.InfoRegisteredToValue = setupInfoText("Registered to:", "")
    about.InfoSubscriptionLabel, about.InfoSubscriptionValue = setupInfoText("Subscription till:", " FOREVER")

    about.FooterText = self:_CreateDrawingObject("Text"); if about.FooterText then about.FooterText.Font = self.ActiveTheme.Fonts.Main; about.FooterText.Size = self.ActiveTheme.Fonts.Size - 1; about.FooterText.Text = "neverlose.cc © 2025"; about.FooterText.Center = true; about.FooterText.zIndex = about_z; end
    about.Separator3 = self:_CreateDrawingObject("Line"); if about.Separator3 then about.Separator3.Thickness = separatorThickness; about.Separator3.zIndex = 31; end
    about.CreditText = self:_CreateDrawingObject("Text"); if about.CreditText then about.CreditText.Font = self.ActiveTheme.Fonts.Main; about.CreditText.Size = self.ActiveTheme.Fonts.Size; about.CreditText.Text = "UI by Dicky_Micky_"; about.CreditText.Center = true; about.CreditText.zIndex = about_z; end

    about.AutoSaveToggle = self:_Internal_CreateToggle({ id = "AboutAutoSave", Name = "Auto Save", Default = false, zIndex = about_z });

    about.ToggleUIKeybind = self:_Internal_CreateKeybind({ id = "ToggleUIBind", Name = "Toggle UI", Default = "insert", zIndex = about_z })

    about.AnimationSpeedSlider = self:_Internal_CreateSlider({ id = "AboutAnimationSpeed", Name = "Animation Speed", Min = 0, Max = 5, Default = 2.4, Increment = 0.1, zIndex = about_z });

    about.StyleLabel, _ = setupInfoText("Style", "");

    local tooltip_z = 60
    about.Tooltip = { Background = self:_CreateDrawingObject("Square"), Text = self:_CreateDrawingObject("Text") }
    if about.Tooltip.Background then about.Tooltip.Background.Filled = true; about.Tooltip.Background.zIndex = tooltip_z; about.Tooltip.Background.Rounding = self.ActiveTheme.Rounding.Element; end
    if about.Tooltip.Text then about.Tooltip.Text.Font = self.ActiveTheme.Fonts.Main; about.Tooltip.Text.Size = self.ActiveTheme.Fonts.Size; about.Tooltip.Text.Center = false; about.Tooltip.Text.zIndex = tooltip_z + 1; end

    self:_RebuildStyleCircles()
    self.UI.Values["AboutSelectedStyle"] = "Blue"
end

function Library:_RebuildStyleCircles()
    local about = self.UI.Core.AboutWindow
    local about_z = 32

    for _, circle in ipairs(about.StyleCircles) do
        if circle.Circle then circle.Circle:Remove() end
        if circle.Border then circle.Border:Remove() end
        if circle.Inner then circle.Inner:Remove() end
        if circle.PlusLine1 then circle.PlusLine1:Remove() end
        if circle.PlusLine2 then circle.PlusLine2:Remove() end
    end
    about.StyleCircles = {}

    local function addCircle(theme, isAddButton)
        local circleObj = {
            Name = theme.Name,
            IsAddButton = isAddButton or false,
            Circle = self:_CreateDrawingObject("Circle"),
            Border = self:_CreateDrawingObject("Circle"),
            ClickRegion = {}
        }

        if circleObj.Circle then 
            circleObj.Circle.Filled = true; 
            circleObj.Circle.zIndex = about_z; 
            circleObj.Circle.Radius = 9; 
            local c = (theme.Colors and theme.Colors.MainBackground) or {40,40,40,255};
            circleObj.Circle.Color = {c[1], c[2], c[3]};
            circleObj.Circle.Opacity = (c[4] or 255) / 255;
        end
        if circleObj.Border then circleObj.Border.Filled = false; circleObj.Border.Thickness = 2; circleObj.Border.zIndex = about_z + 1; circleObj.Border.Radius = 11; circleObj.Border.Visible = false; end

        if isAddButton then
            circleObj.PlusLine1 = self:_CreateDrawingObject("Line"); if circleObj.PlusLine1 then circleObj.PlusLine1.Thickness = 2; circleObj.PlusLine1.zIndex = about_z + 1; end
            circleObj.PlusLine2 = self:_CreateDrawingObject("Line"); if circleObj.PlusLine2 then circleObj.PlusLine2.Thickness = 2; circleObj.PlusLine2.zIndex = about_z + 1; end
        else
            circleObj.Inner = self:_CreateDrawingObject("Circle"); if circleObj.Inner then 
                circleObj.Inner.Filled = true; 
                circleObj.Inner.zIndex = about_z + 1; 
                circleObj.Inner.Radius = 4;
                local c = theme.Colors.Accent;
                circleObj.Inner.Color = {c[1], c[2], c[3]};
                circleObj.Inner.Opacity = (c[4] or 255) / 255;
            end
        end
        table.insert(about.StyleCircles, circleObj)
    end

    local themeOrder = {}
    local customThemeNames = {}
    for themeName, themeData in pairs(self.Themes) do
        if not themeData.IsPreset then
            table.insert(customThemeNames, themeName)
        end
    end
    table.sort(customThemeNames)

    -- Build the final list in display order (which will be rendered right-to-left)
    table.insert(themeOrder, {Name = "Add"}) -- Slot 1
    table.insert(themeOrder, self.Themes.Black) -- Slot 2
    table.insert(themeOrder, self.Themes.White) -- Slot 3
    table.insert(themeOrder, self.Themes.Blue) -- Slot 4
    for _, themeName in ipairs(customThemeNames) do -- Slots 5+
        table.insert(themeOrder, self.Themes[themeName])
    end
    
    for _, themeData in ipairs(themeOrder) do
        addCircle(themeData, themeData.Name == "Add")
    end
end

function Library:_InitializeSettingsPopup()
    local popup = {}; self.UI.Popups.Settings = popup; local z = 20
    popup.IsOpen = false; popup.Pos = {x=0, y=0}
    popup.ActiveToggle = nil -- Ссылка на Toggle, чьи настройки открыты 

    -- Создаем базовые элементы окна: фон, границу и свечение [cite: 46, 47]
    popup.Background = self:_CreateDrawingObject("Square"); if popup.Background then popup.Background.Filled = true; popup.Background.zIndex = z; popup.Background.Rounding = self.ActiveTheme.Rounding.Section; end
    popup.Border = self:_CreateDrawingObject("Square"); if popup.Border then popup.Border.Filled = false; popup.Border.Thickness = 1; popup.Border.zIndex = z + 1; popup.Border.Rounding = self.ActiveTheme.Rounding.Section; end
    popup.Glow = self:_Internal_CreateGlowSet(z - 1)
    
    -- Создаем заголовок и разделитель [cite: 46]
    popup.Title = self:_CreateDrawingObject("Text"); if popup.Title then popup.Title.Font = self.ActiveTheme.Fonts.Main; popup.Title.Size = self.ActiveTheme.Fonts.Size + 4; popup.Title.Text = "Settings"; popup.Title.Center = false; popup.Title.Outline = false; popup.Title.zIndex = z + 2; end
    popup.Separator = self:_CreateDrawingObject("Line"); if popup.Separator then popup.Separator.Thickness = 2; popup.Separator.zIndex = z + 1; end

    popup.ClickRegion = {}
end

function Library:_InitializeEditStyleWindow()
    local style_window = {}; self.UI.Popups.EditStyle = style_window; local z = 40
    style_window.IsOpen = false
    style_window.IsEditingName = false -- For text input
    style_window.last_key_press_time = 0
    style_window.key_press_delay = 0.04
    style_window.last_key_pressed = ""
    style_window.ColorItems = {}
    style_window.EditingTheme = {}
    style_window.EditingThemeName = "" -- Original name of the theme being edited

    style_window.Background = self:_CreateDrawingObject("Square"); if style_window.Background then style_window.Background.Filled = true; style_window.Background.zIndex = z; style_window.Background.Rounding = self.ActiveTheme.Rounding.Section; end
    style_window.Border = self:_CreateDrawingObject("Square"); if style_window.Border then style_window.Border.Filled = false; style_window.Border.Thickness = 1; style_window.Border.zIndex = z + 1; style_window.Border.Rounding = self.ActiveTheme.Rounding.Section; end
    style_window.Glow = self:_Internal_CreateGlowSet(z - 1)
    
    style_window.HeaderIcon = self:_CreateDrawingObject("Square"); if style_window.HeaderIcon then style_window.HeaderIcon.Filled = true; style_window.HeaderIcon.zIndex = z + 2; style_window.HeaderIcon.Size = {18, 18}; end
    
    style_window.HeaderTitle = self:_CreateDrawingObject("Text"); if style_window.HeaderTitle then style_window.HeaderTitle.Font = self.ActiveTheme.Fonts.Main; style_window.HeaderTitle.Size = self.ActiveTheme.Fonts.Size + 3; style_window.HeaderTitle.Text = "Edit Style"; style_window.HeaderTitle.Center = false; style_window.HeaderTitle.zIndex = z + 2; end
    style_window.CloseButton = { Line1 = self:_CreateDrawingObject("Line"), Line2 = self:_CreateDrawingObject("Line"), ClickRegion = {} }; if style_window.CloseButton.Line1 then style_window.CloseButton.Line1.Thickness = 2; style_window.CloseButton.Line1.zIndex = z + 2; end; if style_window.CloseButton.Line2 then style_window.CloseButton.Line2.Thickness = 2; style_window.CloseButton.Line2.zIndex = z + 2; end
    style_window.Separator1 = self:_CreateDrawingObject("Line"); if style_window.Separator1 then style_window.Separator1.Thickness = 2; style_window.Separator1.zIndex = z + 1; end
    
    style_window.StyleNameLabel = self:_CreateDrawingObject("Text"); if style_window.StyleNameLabel then style_window.StyleNameLabel.Font = self.ActiveTheme.Fonts.Main; style_window.StyleNameLabel.Size = self.ActiveTheme.Fonts.Size + 1; style_window.StyleNameLabel.Text = "Style name"; style_window.StyleNameLabel.Center = false; style_window.StyleNameLabel.zIndex = z + 2; end
    style_window.StyleNameInputBg = self:_CreateDrawingObject("Square"); if style_window.StyleNameInputBg then style_window.StyleNameInputBg.Filled = true; style_window.StyleNameInputBg.zIndex = z + 2; style_window.StyleNameInputBg.Rounding = self.ActiveTheme.Rounding.Element; end
    style_window.StyleNameInputText = self:_CreateDrawingObject("Text"); if style_window.StyleNameInputText then style_window.StyleNameInputText.Font = self.ActiveTheme.Fonts.Main; style_window.StyleNameInputText.Size = self.ActiveTheme.Fonts.Size + 1; style_window.StyleNameInputText.Text = "Style"; style_window.StyleNameInputText.Center = false; style_window.StyleNameInputText.zIndex = z + 3; end
    style_window.StyleNameInputCursor = self:_CreateDrawingObject("Line"); if style_window.StyleNameInputCursor then style_window.StyleNameInputCursor.Thickness = 1.5; style_window.StyleNameInputCursor.zIndex = z + 4; end
    style_window.StyleNameInputClickRegion = {}
    
    style_window.Separator2 = self:_CreateDrawingObject("Line"); if style_window.Separator2 then style_window.Separator2.Thickness = 2; style_window.Separator2.zIndex = z + 1; end
    
    local color_order = {
        "Accent", "GlowColor", "GlowAccent", "DarkBlue", "DarkGray", "LightGray", "MainBackground", "SectionBackground",
        "Separator", "SidebarBackground", "TabHeader", "TextDark", "TextLight"
    }
    for _, colorName in ipairs(color_order) do
        local item = {
            Name = colorName,
            Label = self:_CreateDrawingObject("Text"),
            ColorCircle = self:_CreateDrawingObject("Circle"),
            ColorBorder = self:_CreateDrawingObject("Circle"),
            ClickRegion = {}
        }
        if item.Label then item.Label.Font = self.ActiveTheme.Fonts.Main; item.Label.Size = self.ActiveTheme.Fonts.Size + 1; item.Label.Text = colorName; item.Label.Center = false; item.Label.zIndex = z + 2; end
        if item.ColorCircle then item.ColorCircle.Filled = true; item.ColorCircle.zIndex = z + 2; item.ColorCircle.Radius = 8; end
        if item.ColorBorder then item.ColorBorder.Filled = false; item.ColorBorder.Thickness = 1; item.ColorBorder.zIndex = z + 3; item.ColorBorder.Radius = 9; end
        table.insert(style_window.ColorItems, item)
    end

    style_window.Separator3 = self:_CreateDrawingObject("Line"); if style_window.Separator3 then style_window.Separator3.Thickness = 2; style_window.Separator3.zIndex = z + 1; end

    style_window.RealTimeToggle = self:_Internal_CreateToggle({id = "EditStyleRealTime", Name = "real-time changes", Default = false, zIndex = z + 2})
    style_window.CancelButton = { Background = self:_CreateDrawingObject("Square"), Border = self:_CreateDrawingObject("Square"), IconLine1 = self:_CreateDrawingObject("Line"), IconLine2 = self:_CreateDrawingObject("Line"), Label = self:_CreateDrawingObject("Text"), ClickRegion = {} }
    style_window.SaveButton = { Background = self:_CreateDrawingObject("Square"), Label = self:_CreateDrawingObject("Text"), Icon = self:_CreateDrawingObject("Image"), ClickRegion = {} }

    if style_window.CancelButton.Background then style_window.CancelButton.Background.Filled = true; style_window.CancelButton.Background.zIndex = z + 2; style_window.CancelButton.Background.Rounding = self.ActiveTheme.Rounding.Button; end
    if style_window.CancelButton.Border then style_window.CancelButton.Border.Filled = false; style_window.CancelButton.Border.Thickness = 1; style_window.CancelButton.Border.zIndex = z + 3; style_window.CancelButton.Border.Rounding = self.ActiveTheme.Rounding.Button; end
    if style_window.CancelButton.IconLine1 then style_window.CancelButton.IconLine1.Thickness = 2; style_window.CancelButton.IconLine1.zIndex = z + 4; end
    if style_window.CancelButton.IconLine2 then style_window.CancelButton.IconLine2.Thickness = 2; style_window.CancelButton.IconLine2.zIndex = z + 4; end
    if style_window.CancelButton.Label then style_window.CancelButton.Label.Font = self.ActiveTheme.Fonts.Main; style_window.CancelButton.Label.Size = self.ActiveTheme.Fonts.Size; style_window.CancelButton.Label.Text = "Cancel"; style_window.CancelButton.Label.Center = false; style_window.CancelButton.Label.zIndex = z + 4; end

    if style_window.SaveButton.Background then style_window.SaveButton.Background.Filled = true; style_window.SaveButton.Background.zIndex = z + 2; style_window.SaveButton.Background.Rounding = self.ActiveTheme.Rounding.Button; end
    if style_window.SaveButton.Label then style_window.SaveButton.Label.Font = self.ActiveTheme.Fonts.Main; style_window.SaveButton.Label.Size = self.ActiveTheme.Fonts.Size; style_window.SaveButton.Label.Text = "Save"; style_window.SaveButton.Label.Center = false; style_window.SaveButton.Label.zIndex = z + 3; end
    if style_window.SaveButton.Icon then style_window.SaveButton.Icon.Url = "https://s6.imgcdn.dev/Y4Sudt.png"; style_window.SaveButton.Icon.Size = {13.33, 13.33}; style_window.SaveButton.Icon.zIndex = z + 3; end
end

function Library:_InitializeColorPickerWindow()
    local picker = {}; self.UI.Popups.ColorPicker = picker; local z = 50
    picker.IsOpen = false
    picker.EditingColorName = nil
    picker.EditingValueID = nil -- << ДОБАВЛЕНО: ID для значения цвета (например, ESP)
    picker.Pos = {x=0, y=0}

    -- State
    picker.h, picker.s, picker.v, picker.a = 0, 1, 1, 1
    picker.isDraggingHue = false
    picker.isDraggingOpacity = false
    picker.isDraggingSaturationValue = false

    -- Drawing Objects
    picker.Background = self:_CreateDrawingObject("Square"); if picker.Background then picker.Background.Filled = true; picker.Background.zIndex = z; picker.Background.Rounding = self.ActiveTheme.Rounding.Window; end
    picker.Border = self:_CreateDrawingObject("Square"); if picker.Border then picker.Border.Filled = false; picker.Border.Thickness = 1; picker.Border.zIndex = z; picker.Border.Rounding = self.ActiveTheme.Rounding.Window; end
    picker.Glow = self:_Internal_CreateGlowSet(z - 1)
    picker.ColorSquare = self:_CreateDrawingObject("Square"); if picker.ColorSquare then picker.ColorSquare.Filled = true; picker.ColorSquare.zIndex = z + 1; picker.ColorSquare.Rounding = self.ActiveTheme.Rounding.Element; end
    picker.GradientOverlay = self:_CreateDrawingObject("Image"); if picker.GradientOverlay then picker.GradientOverlay.Url = "https://pixeldrain.com/api/filesystem/6mLiDUiK"; picker.GradientOverlay.zIndex = z + 2; picker.GradientOverlay.Rounding = self.ActiveTheme.Rounding.Element; end
    picker.SaturationValueNub = self:_CreateDrawingObject("Circle"); if picker.SaturationValueNub then picker.SaturationValueNub.Filled = false; picker.SaturationValueNub.Thickness = 2; picker.SaturationValueNub.Radius = 5; picker.SaturationValueNub.zIndex = z + 3; end

    picker.HueSlider = self:_CreateDrawingObject("Image"); if picker.HueSlider then picker.HueSlider.Url = "https://s6.imgcdn.dev/Y40GWM.jpg"; picker.HueSlider.zIndex = z + 1; picker.HueSlider.Rounding = 4; end
    picker.HueNub = self:_CreateDrawingObject("Circle"); if picker.HueNub then picker.HueNub.Filled = true; picker.HueNub.Radius = 7; picker.HueNub.zIndex = z + 3; end
    picker.HueNubBorder = self:_CreateDrawingObject("Circle"); if picker.HueNubBorder then picker.HueNubBorder.Filled = false; picker.HueNubBorder.Thickness = 2; picker.HueNubBorder.Radius = 7; picker.HueNubBorder.zIndex = z + 2; end

    picker.OpacitySliderBackground = self:_CreateDrawingObject("Square"); if picker.OpacitySliderBackground then picker.OpacitySliderBackground.Filled = true; picker.OpacitySliderBackground.zIndex = z + 1; picker.OpacitySliderBackground.Rounding = 4; end
    picker.OpacitySliderGradient = self:_CreateDrawingObject("Image"); if picker.OpacitySliderGradient then picker.OpacitySliderGradient.Url = "https://pixeldrain.com/api/filesystem/2py1vehq"; picker.OpacitySliderGradient.zIndex = z + 2; picker.OpacitySliderGradient.Rounding = 4; end
    picker.OpacityNub = self:_CreateDrawingObject("Circle"); if picker.OpacityNub then picker.OpacityNub.Filled = true; picker.OpacityNub.Radius = 7; picker.OpacityNub.zIndex = z + 3; end
    picker.OpacityNubBorder = self:_CreateDrawingObject("Circle"); if picker.OpacityNubBorder then picker.OpacityNubBorder.Filled = false; picker.OpacityNubBorder.Thickness = 2; picker.OpacityNubBorder.Radius = 7; picker.OpacityNubBorder.zIndex = z + 2; end

    -- Click Regions
    picker.SaturationValueRegion = {}
    picker.HueSliderRegion = {}
    picker.OpacitySliderRegion = {}
end

function Library:_InitializeConfigsTab()
    local configs = {}; self.UI.Core.ConfigsTab = configs; local z = 4
    
    configs.LoadedConfigName = ""
    configs.Items = {} -- Will be populated by _RefreshConfigList

    configs.MyItemsLabel = self:_CreateDrawingObject("Text")
    if configs.MyItemsLabel then
        configs.MyItemsLabel.Font = self.ActiveTheme.Fonts.Main; configs.MyItemsLabel.Size = self.ActiveTheme.Fonts.Size + 2; configs.MyItemsLabel.Text = "- My items"; configs.MyItemsLabel.Center = false; configs.MyItemsLabel.zIndex = z;
    end

    configs.Scrollbar = {
        Background = self:_CreateDrawingObject("Square"),
        Nub = self:_CreateDrawingObject("Square")
    }
    if configs.Scrollbar.Background then configs.Scrollbar.Background.Filled = true; configs.Scrollbar.Background.zIndex = z + 2; configs.Scrollbar.Background.Rounding = 2; end
    if configs.Scrollbar.Nub then configs.Scrollbar.Nub.Filled = true; configs.Scrollbar.Nub.zIndex = z + 3; configs.Scrollbar.Nub.Rounding = 2; end

    configs.OptionsPopup = {
        IsOpen = false, ItemIndex = nil, Pos = {x=0, y=0}, ClickRegion = {},
        Background = self:_CreateDrawingObject("Square"),
        Border = self:_CreateDrawingObject("Square"),
        Glow = self:_Internal_CreateGlowSet(z + 10),
        IncludeStyleToggle = self:_Internal_CreateToggle({ id = "ConfigIncludeStyle", Name = "Include Style", Default = true, zIndex = z + 12 })
    }
    if configs.OptionsPopup.Background then configs.OptionsPopup.Background.Filled = true; configs.OptionsPopup.Background.zIndex = z + 11; configs.OptionsPopup.Background.Rounding = self.ActiveTheme.Rounding.Section; end
    if configs.OptionsPopup.Border then configs.OptionsPopup.Border.Filled = false; configs.OptionsPopup.Border.Thickness = 1; configs.OptionsPopup.Border.zIndex = z + 12; configs.OptionsPopup.Border.Rounding = self.ActiveTheme.Rounding.Section; end
end

--================================================================
--[[ PRIVATE: CONFIG SYSTEM ]]
--================================================================

function Library:_GetConfigPath(name)
    return self.ConfigFolderPath .. "\\" .. name .. ".cfg"
end

function Library:_SaveConfig(name)
    local configData = {
        Values = {},
        Themes = {},
        ActiveThemeName = self.ActiveTheme.Name
    }

    for id, value in pairs(self.UI.Values) do
        if not string.find(id, "About") and id ~= "ConfigIncludeStyle" then
            configData.Values[id] = value
        end
    end

    if self.UI.Values["ConfigIncludeStyle"] then
        print(SCRIPT_PREFIX .. "Saving custom themes...") -- Строка для отладки
        for themeName, themeData in pairs(self.Themes) do
            if not themeData.IsPreset then
                -- [ДОБАВЛЕНО] Печатаем в консоль каждую найденную кастомную тему
                print(SCRIPT_PREFIX .. "Found custom theme to save: " .. themeName)
                
                local sanitizedTheme = {
                    Colors = self:_DeepCopy(themeData.Colors),
                    Rounding = self:_DeepCopy(themeData.Rounding),
                    Transparency = self:_DeepCopy(themeData.Transparency),
                    IconSize = themeData.IconSize
                }
                configData.Themes[themeName] = sanitizedTheme
            end
        end
    end

    local success, encodedData = pcall(JSONEncode, configData)
    if success then
        writefile(self:_GetConfigPath(name), encodedData)
        print(SCRIPT_PREFIX .. "Config '" .. name .. "' saved successfully.")
        self.UI.Core.ConfigsTab.NeedsRefresh = true
    else
        warn(SCRIPT_PREFIX .. "Failed to encode config data for '" .. name .. "'.")
    end
end

function Library:_LoadConfig(name)
    local filePath = self:_GetConfigPath(name)
    if not checkfile(filePath) then warn(SCRIPT_PREFIX .. "Config file not found: " .. name); return end
    local success, fileContent = pcall(readfile, filePath)
    if not success or not fileContent then warn(SCRIPT_PREFIX .. "Failed to read config file: " .. name); return end
    local success, decodedData = pcall(JSONDecode, fileContent)
    if not success or not decodedData then warn(SCRIPT_PREFIX .. "Failed to decode config JSON: " .. name); return end

    -- << НАЧАЛО ИСПРАВЛЕНИЯ: ОЧИСТКА СТАРЫХ КАСТОМНЫХ ТЕМ >>
    do
        local themesToRemove = {}
        -- Сначала собираем имена всех тем, которые не являются стандартными
        for themeName, themeData in pairs(self.Themes) do
            if not themeData.IsPreset then
                table.insert(themesToRemove, themeName)
            end
        end
        -- Затем удаляем их
        for _, themeNameToRemove in ipairs(themesToRemove) do
            self.Themes[themeNameToRemove] = nil
        end
    end
    -- << КОНЕЦ ИСПРАВЛЕНИЯ >>

    if decodedData.Themes then
        for themeName, savedThemeData in pairs(decodedData.Themes) do
            local baseTheme = self.Themes.Blue
            local fullTheme = self:_EnsureDefaults(savedThemeData, baseTheme)

            fullTheme.Name = themeName
            fullTheme.IsPreset = false
            fullTheme.Fonts = self:_DeepCopy(baseTheme.Fonts)

            if fullTheme.Transparency and fullTheme.Transparency.ActiveTabHighlight == 0 then
                fullTheme.Transparency.ActiveTabHighlight = baseTheme.Transparency.ActiveTabHighlight
            end

            self.Themes[themeName] = fullTheme
        end
    end
    self:_RebuildStyleCircles() -- Перестраиваем кружки стилей уже с правильным набором тем

    if decodedData.Values then
        for id, value in pairs(decodedData.Values) do
            if self.UI.Values[id] ~= nil then
                self.UI.Values[id] = value
                for _, section in ipairs(self.UI.Sections) do
                    for _, element in ipairs(section.Elements) do
                        if element.id == id and element.Callback then
                            pcall(element.Callback, value)
                            break
                        end
                    end
                end
            end
        end
    end

    if decodedData.ActiveThemeName and self.Themes[decodedData.ActiveThemeName] then
        self.ActiveTheme = self.Themes[decodedData.ActiveThemeName]
        self.UI.Values.AboutSelectedStyle = decodedData.ActiveThemeName
    else
        -- Если активной темы из конфига нет, ставим стандартную
        self.ActiveTheme = self.Themes.Blue
        self.UI.Values.AboutSelectedStyle = "Blue"
    end

    self.UI.Core.ConfigsTab.LoadedConfigName = name
    print(SCRIPT_PREFIX .. "Config '" .. name .. "' loaded successfully.")
end

function Library:_InitializeConfigsTab()
    local configs = {}; self.UI.Core.ConfigsTab = configs; local z = 4
    
    configs.LoadedConfigName = ""
    configs.Items = {} -- Will be populated by _RefreshConfigList
    configs.NeedsRefresh = false -- [ДОБАВЛЕНО] Флаг для отложенного обновления

    configs.MyItemsLabel = self:_CreateDrawingObject("Text")
    if configs.MyItemsLabel then
        configs.MyItemsLabel.Font = self.ActiveTheme.Fonts.Main; configs.MyItemsLabel.Size = self.ActiveTheme.Fonts.Size + 2; configs.MyItemsLabel.Text = "- My items"; configs.MyItemsLabel.Center = false; configs.MyItemsLabel.zIndex = z;
    end

    configs.Scrollbar = {
        Background = self:_CreateDrawingObject("Square"),
        Nub = self:_CreateDrawingObject("Square")
    }
    if configs.Scrollbar.Background then configs.Scrollbar.Background.Filled = true; configs.Scrollbar.Background.zIndex = z + 2; configs.Scrollbar.Background.Rounding = 2; end
    if configs.Scrollbar.Nub then configs.Scrollbar.Nub.Filled = true; configs.Scrollbar.Nub.zIndex = z + 3; configs.Scrollbar.Nub.Rounding = 2; end

    configs.OptionsPopup = {
        IsOpen = false, ItemIndex = nil, Pos = {x=0, y=0}, ClickRegion = {},
        Background = self:_CreateDrawingObject("Square"),
        Border = self:_CreateDrawingObject("Square"),
        Glow = self:_Internal_CreateGlowSet(z + 10),
        IncludeStyleToggle = self:_Internal_CreateToggle({ id = "ConfigIncludeStyle", Name = "Include Style", Default = true, zIndex = z + 12 })
    }
    if configs.OptionsPopup.Background then configs.OptionsPopup.Background.Filled = true; configs.OptionsPopup.Background.zIndex = z + 11; configs.OptionsPopup.Background.Rounding = self.ActiveTheme.Rounding.Section; end
    if configs.OptionsPopup.Border then configs.OptionsPopup.Border.Filled = false; configs.OptionsPopup.Border.Thickness = 1; configs.OptionsPopup.Border.zIndex = z + 12; configs.OptionsPopup.Border.Rounding = self.ActiveTheme.Rounding.Section; end
end

-- Вставьте эту новую функцию в раздел PRIVATE: CONFIG SYSTEM
function Library:_CreateNewConfig()
    local baseName = "New config"
    local newName = baseName
    local i = 1
    
    while checkfile(self:_GetConfigPath(newName)) do
        newName = baseName .. " (" .. i .. ")"
        i = i + 1
    end
    
    print(SCRIPT_PREFIX .. "Creating new config: " .. newName)
    self:_SaveConfig(newName)
end

function Library:_RefreshConfigList()
    local configs = self.UI.Core.ConfigsTab
    
    for _, item in ipairs(configs.Items) do
        self:_CleanupDrawingObjects(item.Drawing)
    end
    configs.Items = {}

    local files = listfiles(self.ConfigFolderPath)
    if not files then return end

    local localPlayerName = "user"
    local p = game:FindService("Players")
    if p and p.localPlayer then
        localPlayerName = p.localPlayer.Name
    end

    for _, fileName in ipairs(files) do
        if string.sub(fileName, -4) == ".cfg" then
            local configName = string.sub(fileName, 1, -5)
            local item = {
                Name = configName,
                Modified = "N/A",
                Author = localPlayerName,
                Drawing = {
                    Background = self:_CreateDrawingObject("Square"),
                    Border = self:_CreateDrawingObject("Square"), -- [ДОБАВЛЕНО] Объект для обводки
                    Name = self:_CreateDrawingObject("Text"),
                    Modified = self:_CreateDrawingObject("Text"),
                    Author = self:_CreateDrawingObject("Text"),
                    OptionsButton = {
                        Dot1 = self:_CreateDrawingObject("Circle"), Dot2 = self:_CreateDrawingObject("Circle"), Dot3 = self:_CreateDrawingObject("Circle"),
                        ClickRegion = {}
                    },
                    LoadButton = {
                        Background = self:_CreateDrawingObject("Square"),
                        Icon = self:_CreateDrawingObject("Image"),
                        Label = self:_CreateDrawingObject("Text"),
                        ClickRegion = {}
                    },
                    SaveButton = {
                        Background = self:_CreateDrawingObject("Square"), Border = self:_CreateDrawingObject("Square"),
                        Icon = self:_CreateDrawingObject("Image"), Label = self:_CreateDrawingObject("Text"),
                        ClickRegion = {}
                    }
                }
            }
            
            local d = item.Drawing; local z = 4
            if d.Background then d.Background.Filled = true; d.Background.zIndex = z; d.Background.Rounding = self.ActiveTheme.Rounding.Section; end
            -- [ДОБАВЛЕНО] Настройка обводки
            if d.Border then d.Border.Filled = false; d.Border.Thickness = 1; d.Border.zIndex = z + 1; d.Border.Rounding = self.ActiveTheme.Rounding.Section; end
            
            if d.Name then d.Name.Font = self.ActiveTheme.Fonts.Main; d.Name.Size = self.ActiveTheme.Fonts.Size + 2; d.Name.Center = false; d.Name.zIndex = z + 1; end
            if d.Modified then d.Modified.Font = self.ActiveTheme.Fonts.Main; d.Modified.Size = self.ActiveTheme.Fonts.Size; d.Modified.Center = false; d.Modified.zIndex = z + 1; end
            if d.Author then d.Author.Font = self.ActiveTheme.Fonts.Main; d.Author.Size = self.ActiveTheme.Fonts.Size; d.Author.Center = false; d.Author.zIndex = z + 1; end
            
            if d.OptionsButton.Dot1 then d.OptionsButton.Dot1.Filled = true; d.OptionsButton.Dot1.Radius = 1.5; d.OptionsButton.Dot1.zIndex = z + 2; end
            if d.OptionsButton.Dot2 then d.OptionsButton.Dot2.Filled = true; d.OptionsButton.Dot2.Radius = 1.5; d.OptionsButton.Dot2.zIndex = z + 2; end
            if d.OptionsButton.Dot3 then d.OptionsButton.Dot3.Filled = true; d.OptionsButton.Dot3.Radius = 1.5; d.OptionsButton.Dot3.zIndex = z + 2; end

            if d.LoadButton.Background then d.LoadButton.Background.Filled = true; d.LoadButton.Background.zIndex = z + 2; d.LoadButton.Background.Rounding = self.ActiveTheme.Rounding.Button; end
            if d.LoadButton.Icon then d.LoadButton.Icon.Size = {14, 14}; d.LoadButton.Icon.zIndex = z + 3; d.LoadButton.Icon.Url = "https://s6.imgcdn.dev/Y4v6tt.png"; end
            if d.LoadButton.Label then d.LoadButton.Label.Font = self.ActiveTheme.Fonts.Main; d.LoadButton.Label.Size = self.ActiveTheme.Fonts.Size; d.LoadButton.Label.Text = "Load"; d.LoadButton.Label.Center = false; d.LoadButton.Label.zIndex = z + 3; end

            if d.SaveButton.Background then d.SaveButton.Filled = true; d.SaveButton.zIndex = z + 2; d.SaveButton.Rounding = self.ActiveTheme.Rounding.Button; end
            if d.SaveButton.Border then d.SaveButton.Border.Filled = false; d.SaveButton.Border.Thickness = 1; d.SaveButton.Border.zIndex = z + 3; d.SaveButton.Border.Rounding = self.ActiveTheme.Rounding.Button; end
            if d.SaveButton.Icon then d.SaveButton.Icon.Size = {13.33, 13.33}; d.SaveButton.Icon.zIndex = z + 3; d.SaveButton.Icon.Url = "https://s6.imgcdn.dev/Y4Sudt.png"; end
            if d.SaveButton.Label then d.SaveButton.Label.Font = self.ActiveTheme.Fonts.Main; d.SaveButton.Label.Size = self.ActiveTheme.Fonts.Size; d.SaveButton.Label.Text = "Save"; d.SaveButton.Label.Center = false; d.SaveButton.Label.zIndex = z + 3; end
            
            table.insert(configs.Items, item)
        end
    end
end

--================================================================
--[[ PRIVATE: THEME MANAGEMENT ]]
--================================================================

function Library:_revert_realtime_changes()
    if self.UI.Values.EditStyleRealTime and self.PreEditThemeName then
        self.ActiveTheme = self.Themes[self.PreEditThemeName] or self.Themes.Blue
        self.UI.Values.AboutSelectedStyle = self.ActiveTheme.Name
    end
    self.TempTheme = nil
    self.PreEditThemeName = nil
    self.UI.Values.EditStyleRealTime = false
end

--================================================================
--[[ PRIVATE: RENDERING & INPUT HANDLING ]]
--================================================================

function Library:_RenderAboutWindow(mouse_pos)
    local about = self.UI.Core.AboutWindow
    local isVisible = self.UI.Popups.About.IsOpen
    local theme = self.ActiveTheme
    local globalOpacity = self.GlobalAnimation.Opacity
    
    local function setAboutVisibility(tbl, visible)
        for key, obj in pairs(tbl) do
            if type(obj) == 'table' then
                if obj.Visible ~= nil then self:_SetVisibility(obj, visible)
                elseif obj.Label and (obj.Back or obj.Button or (obj.LeftFill and obj.Nub) or obj.Border) then
                    self:_SetVisibility(obj.Label, visible);
                    if obj.Back then self:_SetVisibility(obj.Back, visible); self:_SetVisibility(obj.Nub, visible); end
                    if obj.LeftFill then self:_SetVisibility(obj.LeftFill, visible); self:_SetVisibility(obj.Nub, visible); self:_SetVisibility(obj.ValueText, visible); end
                    if obj.Button then self:_SetVisibility(obj.Button, visible); self:_SetVisibility(obj.ButtonText, visible); end
                    if obj.ArrowLine1 then self:_SetVisibility(obj.ArrowLine1, visible); self:_SetVisibility(obj.ArrowLine2, visible); end
                    if obj.Border then self:_SetVisibility(obj.Border, visible) end
                elseif key ~= "ClickRegion" and key ~= "StyleCircles" and key ~= "Glow" and key ~= "Tooltip" and key ~= "HoveredThemeCircle" then
                     setAboutVisibility(obj, visible)
                end
            end
        end
    end
    setAboutVisibility(about, isVisible)
    self:_SetVisibility(about.Tooltip.Background, false)
    self:_SetVisibility(about.Tooltip.Text, false)

    for _, circle in ipairs(about.StyleCircles) do
        self:_SetVisibility(circle.Circle, isVisible); 
        self:_SetVisibility(circle.Border, isVisible and self.UI.Values.AboutSelectedStyle == circle.Name);
        if circle.Inner then self:_SetVisibility(circle.Inner, isVisible) end
        if circle.PlusLine1 then self:_SetVisibility(circle.PlusLine1, isVisible); self:_SetVisibility(circle.PlusLine2, isVisible) end
        
        local baseCircleOpacity = (circle.Circle and circle.Circle.Color and circle.Circle.Color[4]) and (circle.Circle.Color[4] / 255) or 1
        if circle.Circle then circle.Circle.Opacity = baseCircleOpacity * globalOpacity end
        if circle.Border then circle.Border.Opacity = globalOpacity end
        if circle.Inner then circle.Inner.Opacity = globalOpacity end
        if circle.PlusLine1 then circle.PlusLine1.Opacity = globalOpacity end
        if circle.PlusLine2 then circle.PlusLine2.Opacity = globalOpacity end
    end

    if not isVisible then
        if about.Glow then self:_HideGlowEffect(about.Glow) end
        if about.AnimationSpeedSlider.Glow then self:_HideGlowEffect(about.AnimationSpeedSlider.Glow) end
        return
    end

    -- Анимация цветов
    self:_AnimateAndApplyColor(about.Background, theme.Colors.SectionBackground)
    self:_AnimateAndApplyColor(about.Border, theme.Colors.Separator)
    self:_AnimateAndApplyColor(about.HeaderIcon, theme.Colors.TextSecondary)
    self:_AnimateAndApplyColor(about.HeaderTitle, theme.Colors.TextPrimary)
    self:_AnimateAndApplyColor(about.CloseButton.Line1, theme.Colors.TextSecondary)
    self:_AnimateAndApplyColor(about.CloseButton.Line2, theme.Colors.TextSecondary)
    self:_AnimateAndApplyColor(about.Separator1, theme.Colors.Separator)
    self:_AnimateAndApplyColor(about.MainTitle, theme.Colors.TextPrimary)
    self:_AnimateAndApplyColor(about.Separator2, theme.Colors.Separator)
    self:_AnimateAndApplyColor(about.InfoVersionLabel, theme.Colors.TextSecondary); self:_AnimateAndApplyColor(about.InfoVersionValue, theme.Colors.Accent)
    self:_AnimateAndApplyColor(about.InfoBuildDateLabel, theme.Colors.TextSecondary); self:_AnimateAndApplyColor(about.InfoBuildDateValue, theme.Colors.Accent)
    self:_AnimateAndApplyColor(about.InfoBuildTypeLabel, theme.Colors.TextSecondary); self:_AnimateAndApplyColor(about.InfoBuildTypeValue, theme.Colors.Accent)
    self:_AnimateAndApplyColor(about.InfoRegisteredToLabel, theme.Colors.TextSecondary); self:_AnimateAndApplyColor(about.InfoRegisteredToValue, theme.Colors.Accent)
    self:_AnimateAndApplyColor(about.InfoSubscriptionLabel, theme.Colors.TextSecondary); self:_AnimateAndApplyColor(about.InfoSubscriptionValue, theme.Colors.Accent)
    self:_AnimateAndApplyColor(about.FooterText, theme.Colors.TextSecondary)
    self:_AnimateAndApplyColor(about.Separator3, theme.Colors.Separator)
    self:_AnimateAndApplyColor(about.CreditText, theme.Colors.TextSecondary)
    self:_AnimateAndApplyColor(about.StyleLabel, theme.Colors.TextSecondary)
    self:_AnimateAndApplyColor(about.Tooltip.Background, theme.Colors.MainBackground)
    self:_AnimateAndApplyColor(about.Tooltip.Text, theme.Colors.TextPrimary)
    
    -- [[ ИСПРАВЛЕНО: Добавлена анимация цвета для обводки кругов и надписи Auto Save ]]
    for _, circle in ipairs(about.StyleCircles) do
        self:_AnimateAndApplyColor(circle.Border, theme.Colors.Accent)
        if circle.PlusLine1 then self:_AnimateAndApplyColor(circle.PlusLine1, theme.Colors.TextSecondary) end
        if circle.PlusLine2 then self:_AnimateAndApplyColor(circle.PlusLine2, theme.Colors.TextSecondary) end
    end
    self:_AnimateAndApplyColor(about.AutoSaveToggle.Label, theme.Colors.TextSecondary)
    
    local slider = about.AnimationSpeedSlider; 
    self:_AnimateAndApplyColor(slider.Label, theme.Colors.TextSecondary); 
    self:_AnimateAndApplyColor(slider.Back, theme.Colors.DarkBlue);
    self:_AnimateAndApplyColor(slider.LeftFill, theme.Colors.Accent); 
    self:_AnimateAndApplyColor(slider.Nub, theme.Colors.Accent); 
    self:_AnimateAndApplyColor(slider.ValueText, theme.Colors.TextPrimary);
    
    -- Позиционирование
    local winW, winH = 360, 500
    local winX, winY = self.Window.X + (self.Window.Width / 2) - (winW / 2), self.Window.Y + (self.Window.Height / 2) - (winH / 2)
    about.ClickRegion = {x1 = winX, y1 = winY, x2 = winX + winW, y2 = winY + winH}
    about.Background.Position = {winX, winY}; about.Background.Size = {winW, winH}
    about.Border.Position = {winX, winY}; about.Border.Size = {winW, winH}
    if about.Glow then self:_RenderGlowEffect(about.Glow, winX, winY, winW, winH, about.Background.Rounding, theme.Colors.GlowColor) end
    about.HeaderIcon.Position = {winX + 15, winY + 12}
    about.HeaderTitle.Position = {winX + 15 + about.HeaderIcon.Size.x + 8, winY + 13}
    about.CloseButton.Line1.From = {winX + winW - 25, winY + 12}; about.CloseButton.Line1.To = {winX + winW - 15, winY + 22}
    about.CloseButton.Line2.From = {winX + winW - 25, winY + 22}; about.CloseButton.Line2.To = {winX + winW - 15, winY + 12}
    about.CloseButton.ClickRegion = {x1 = winX + winW - 30, y1 = winY + 10, x2 = winX + winW - 10, y2 = winY + 25}
    local currentY = winY + 40
    about.Separator1.From = {winX + 10, currentY}; about.Separator1.To = {winX + winW - 10, currentY}
    currentY = currentY + 25
    about.MainTitle.Position = {winX + winW / 2, currentY}
    currentY = currentY + 40
    about.Separator2.From = {winX + 10, currentY}; about.Separator2.To = {winX + winW - 10, currentY}
    currentY = currentY + 20
    local infoX = winX + 30
    local function renderInfoLine(y, label, value) if label and value then label.Position = {infoX, y}; if label.TextBounds then value.Position = {infoX + label.TextBounds.x + 5, y} end; return y + 25; end; return y; end
    currentY = renderInfoLine(currentY, about.InfoVersionLabel, about.InfoVersionValue)
    currentY = renderInfoLine(currentY, about.InfoBuildDateLabel, about.InfoBuildDateValue)
    currentY = renderInfoLine(currentY, about.InfoBuildTypeLabel, about.InfoBuildTypeValue)
    currentY = renderInfoLine(currentY, about.InfoRegisteredToLabel, about.InfoRegisteredToValue)
    currentY = renderInfoLine(currentY, about.InfoSubscriptionLabel, about.InfoSubscriptionValue)
    about.FooterText.Position = {winX + winW / 2, currentY}
    currentY = currentY + 50; about.Separator3.From = {winX + 10, currentY}; about.Separator3.To = {winX + winW - 10, currentY}; currentY = currentY + 15
    local controlX = winX + 20; local controlW = winW - 40; local controlSpacing = 35
    local rightEdge = winX + winW - 25
    
    local toggle = about.AutoSaveToggle
    local toggleY = currentY - 1
    toggle.Label.Position = {controlX, currentY}; 
    local toggleBackX = rightEdge - toggle.Size.width; 
    toggle.Back.Position = {toggleBackX, toggleY}; 
    toggle.Back.Size = {toggle.Size.width, toggle.Size.height}; 
    toggle.ClickRegion = {x1 = toggleBackX, y1 = toggleY, x2 = toggleBackX + toggle.Size.width, y2 = toggleY + toggle.Size.height}; 
    local targetBackColor, targetNubColor; 
    local nubY = toggleY + toggle.Size.height / 2
    if self.UI.Values[toggle.id] then 
        targetBackColor = self:_DarkenColor(theme.Colors.Accent, 0.3); 
        targetNubColor = theme.Colors.Accent; 
        toggle.Nub.Position = {toggleBackX + toggle.Size.width - toggle.Size.height / 2, nubY}
    else 
        targetBackColor = theme.Colors.DarkGray; 
        targetNubColor = theme.Colors.LightGray; 
        toggle.Nub.Position = {toggleBackX + toggle.Size.height / 2, nubY}
    end;
    self:_AnimateAndApplyColor(toggle.Back, targetBackColor); 
    self:_AnimateAndApplyColor(toggle.Nub, targetNubColor);
    
    currentY = currentY + controlSpacing
    
    local keybind = about.ToggleUIKeybind
    local keybindY = currentY - 4
    self:_AnimateAndApplyColor(keybind.Label, theme.Colors.TextSecondary)
    keybind.Label.Position = {controlX, keybindY + 5}
    local bindButtonX = rightEdge - keybind.Size.width
    local buttonBackgroundColor = keybind.IsListening and theme.Colors.Accent or theme.Colors.DarkBlue
    local buttonTextColor = keybind.IsListening and self:_GetTextColorForBackground(buttonBackgroundColor) or theme.Colors.TextPrimary
    local buttonBorderColor = keybind.IsListening and theme.Colors.Accent or theme.Colors.Separator
    self:_AnimateAndApplyColor(keybind.Button, buttonBackgroundColor)
    self:_AnimateAndApplyColor(keybind.Border, buttonBorderColor)
    self:_AnimateAndApplyColor(keybind.ButtonText, buttonTextColor)
    keybind.Button.Position = {bindButtonX, keybindY}; keybind.Button.Size = {keybind.Size.width, keybind.Size.height}
    keybind.Border.Position = {bindButtonX, keybindY}; keybind.Border.Size = {keybind.Size.width, keybind.Size.height}
    keybind.ButtonText.Text = keybind.IsListening and "..." or string.upper(self.UI.Values[keybind.id] or "none")
    keybind.ButtonText.Position = { bindButtonX + (keybind.Size.width / 2), keybindY + (keybind.Size.height / 2) - (keybind.ButtonText.Size / 2) }
    keybind.ClickRegion = {x1 = bindButtonX, y1 = keybindY, x2 = bindButtonX + keybind.Size.width, y2 = keybindY + keybind.Size.height}

    currentY = currentY + controlSpacing

    slider.Label.Position = {controlX, currentY}; 
    local valueTextWidth = 40; local sliderRightEdge = rightEdge - valueTextWidth; local sliderBackX = controlX + 140; local sliderBackWidth = sliderRightEdge - sliderBackX
    slider.Back.Position = {sliderBackX, currentY + 8}; 
    slider.Back.Size = {sliderBackWidth, 2}; 
    slider.ClickRegion = { x1 = sliderBackX, y1 = currentY - 2, x2 = sliderBackX + sliderBackWidth, y2 = currentY + 18 }; 
    local value_percentage = math.clamp((self.UI.Values[slider.id] - slider.Min) / (slider.Max - slider.Min), 0, 1); 
    local nubX = sliderBackX + sliderBackWidth * value_percentage; 
    slider.LeftFill.Position = {sliderBackX, currentY + 8}; 
    slider.LeftFill.Size = {nubX - sliderBackX, 2}; 
    slider.Nub.Position = {nubX, currentY + 9}; 
    
    local glowWidth = nubX - sliderBackX; 
    local glowHeight = 6;
    if glowWidth > 0 and slider.Glow then 
        self:_RenderGlowEffect(slider.Glow, sliderBackX, currentY + 9 - (glowHeight / 2), glowWidth, glowHeight, slider.LeftFill.Rounding, theme.Colors.GlowAccent) 
    elseif slider.Glow then 
        self:_HideGlowEffect(slider.Glow) 
    end

    local valueText = string.format("%.1f", self.UI.Values[slider.id]); local valueTextX = rightEdge - valueTextWidth + 10; 
    slider.ValueText.Text = valueText; 
    slider.ValueText.Position = {valueTextX, currentY}; 
    
    currentY = currentY + controlSpacing
    
    local styleY = currentY + 4
    about.StyleLabel.Position = {controlX, styleY}; 
    local maxPerRow = 8; local circleSpacing = 30; local circleStartX = rightEdge
    for i, circle in ipairs(about.StyleCircles) do
        local slotIndex = i - 1; local col = slotIndex % maxPerRow; local row = math.floor(slotIndex / maxPerRow)
        local circleX = circleStartX - (col * circleSpacing); local circleY = styleY + 5 + (row * circleSpacing)
        circle.Circle.Position = {circleX, circleY}; circle.Border.Position = {circleX, circleY}
        if circle.Inner then circle.Inner.Position = {circleX, circleY} end
        if circle.PlusLine1 then circle.PlusLine1.From = {circleX - 4, circleY}; circle.PlusLine1.To = {circleX + 4, circleY}; circle.PlusLine2.From = {circleX, circleY - 4}; circle.PlusLine2.To = {circleX, circleY + 4}; end
        circle.ClickRegion = {x1 = circleX - 10, y1 = circleY - 5, x2 = circleX + 10, y2 = circleY + 15}
    end
    if about.HoveredThemeCircle.Name and (tick() - about.HoveredThemeCircle.HoverStartTime > 1) then
        local tooltip = about.Tooltip; local text = about.HoveredThemeCircle.Name; tooltip.Text.Text = text
        if tooltip.Text.TextBounds then
            local ttW = tooltip.Text.TextBounds.x + 16; local ttH = tooltip.Text.TextBounds.y + 10; local ttX = mouse_pos.x + 15; local ttY = mouse_pos.y
            tooltip.Background.Position = {ttX, ttY}; tooltip.Background.Size = {ttW, ttH}; tooltip.Text.Position = {ttX + 8, ttY + 5}
            self:_SetVisibility(tooltip.Background, true); self:_SetVisibility(tooltip.Text, true)
        end
    end
    about.CreditText.Position = {winX + winW / 2, winY + winH - 25}
end



function Library:_RenderSettingsPopup()
    local popup = self.UI.Popups.Settings
    local isVisible = popup.IsOpen and popup.ActiveToggle
    local theme = self.ActiveTheme
    local z = 20 -- Базовый z-index для всплывающего окна

    self:_SetVisibility(popup.Background, isVisible); self:_SetVisibility(popup.Border, isVisible); self:_SetVisibility(popup.Title, isVisible); self:_SetVisibility(popup.Separator, isVisible);

    if not isVisible then
        if popup.Glow then self:_HideGlowEffect(popup.Glow) end
        self:_HideSettingsPopupElements(popup)
        return
    end

    self:_AnimateAndApplyColor(popup.Background, theme.Colors.SectionBackground)
    self:_AnimateAndApplyColor(popup.Border, theme.Colors.Separator)
    self:_AnimateAndApplyColor(popup.Separator, theme.Colors.Separator)

    popup.Title.Text = popup.ActiveToggle.Name .. " Settings"
    self:_AnimateAndApplyColor(popup.Title, theme.Colors.TextPrimary)
    popup.Title.zIndex = z + 2

    local pX, pY = popup.Pos.x, popup.Pos.y
    local pW = 250
    local currentY = pY + 8
    if popup.Title then popup.Title.Position = {pX + 10, currentY}; end
    currentY = currentY + popup.Title.Size + 8
    if popup.Separator then popup.Separator.From = {pX + 10, currentY}; popup.Separator.To = {pX + pW - 10, currentY}; end
    currentY = currentY + 15

    for _, element in ipairs(popup.ActiveToggle.SettingsElements or {}) do
        if element.type == "Keybind" then
            local keybind = element
            self:_SetVisibility(keybind.Label, true) -- << ДОБАВЛЕНО
            self:_SetVisibility(keybind.Button, true)
            self:_SetVisibility(keybind.Border, true)
            self:_SetVisibility(keybind.ButtonText, true)

            keybind.Label.zIndex = z + 2 -- << ДОБАВЛЕНО
            keybind.Button.zIndex = z + 2
            keybind.Border.zIndex = z + 3
            keybind.ButtonText.zIndex = z + 3

            local buttonBackgroundColor = keybind.IsListening and theme.Colors.Accent or theme.Colors.DarkBlue
            local buttonTextColor = keybind.IsListening and self:_GetTextColorForBackground(buttonBackgroundColor) or theme.Colors.TextPrimary
            local buttonBorderColor = keybind.IsListening and theme.Colors.Accent or theme.Colors.Separator

            self:_AnimateAndApplyColor(keybind.Label, theme.Colors.TextSecondary) -- << ДОБАВЛЕНО
            self:_AnimateAndApplyColor(keybind.Button, buttonBackgroundColor)
            self:_AnimateAndApplyColor(keybind.Border, buttonBorderColor)
            self:_AnimateAndApplyColor(keybind.ButtonText, buttonTextColor)

            keybind.Label.Position = { pX + 15, currentY } -- << ДОБАВЛЕНО
            local bindButtonX = pX + pW - keybind.Size.width - 15
            keybind.Button.Position = {bindButtonX, currentY - 5}; keybind.Button.Size = {keybind.Size.width, keybind.Size.height};
            keybind.Border.Position = {bindButtonX, currentY - 5}; keybind.Border.Size = {keybind.Size.width, keybind.Size.height};
            keybind.ButtonText.Text = keybind.IsListening and "..." or string.upper(self.UI.Values[keybind.id] or "none")
            keybind.ButtonText.Position = { bindButtonX + (keybind.Size.width / 2), currentY - 5 + (keybind.Size.height / 2) - (keybind.ButtonText.Size / 2) }
            keybind.ClickRegion = {x1 = bindButtonX, y1 = currentY - 5, x2 = bindButtonX + keybind.Size.width, y2 = currentY - 5 + keybind.Size.height}
            currentY = currentY + 35
        end
    end

    local totalHeight = currentY - pY
    popup.ClickRegion = {x1 = pX, y1 = pY, x2 = pX + pW, y2 = pY + totalHeight}
    if popup.Background then popup.Background.Position = {pX, pY}; popup.Background.Size = {pW, totalHeight}; end
    if popup.Border then popup.Border.Position = {pX, pY}; popup.Border.Size = {pW, totalHeight}; end
    if popup.Glow then self:_RenderGlowEffect(popup.Glow, pX, pY, pW, totalHeight, popup.Background.Rounding, theme.Colors.GlowColor) end
end

function Library:_RenderEditStyleWindow()
    local style_window = self.UI.Popups.EditStyle
    local isVisible = style_window.IsOpen
    local theme = self.ActiveTheme

    self:_SetVisibility(style_window.Background, isVisible); self:_SetVisibility(style_window.Border, isVisible); self:_SetVisibility(style_window.HeaderIcon, isVisible); self:_SetVisibility(style_window.HeaderTitle, isVisible); self:_SetVisibility(style_window.CloseButton.Line1, isVisible); self:_SetVisibility(style_window.CloseButton.Line2, isVisible); self:_SetVisibility(style_window.Separator1, isVisible);
    self:_SetVisibility(style_window.StyleNameLabel, isVisible); self:_SetVisibility(style_window.StyleNameInputBg, isVisible); self:_SetVisibility(style_window.StyleNameInputText, isVisible); self:_SetVisibility(style_window.Separator2, isVisible); self:_SetVisibility(style_window.Separator3, isVisible);
    self:_SetVisibility(style_window.StyleNameInputCursor, isVisible and style_window.IsEditingName and math.sin(tick() * 5) > 0)
    for _, item in ipairs(style_window.ColorItems) do self:_SetVisibility(item.Label, isVisible); self:_SetVisibility(item.ColorCircle, isVisible); self:_SetVisibility(item.ColorBorder, isVisible); end
    self:_SetVisibility(style_window.RealTimeToggle.Label, isVisible); self:_SetVisibility(style_window.RealTimeToggle.Back, isVisible); self:_SetVisibility(style_window.RealTimeToggle.Nub, isVisible);
    self:_SetVisibility(style_window.CancelButton.Background, isVisible); self:_SetVisibility(style_window.CancelButton.Border, isVisible); self:_SetVisibility(style_window.CancelButton.IconLine1, isVisible); self:_SetVisibility(style_window.CancelButton.IconLine2, isVisible); self:_SetVisibility(style_window.CancelButton.Label, isVisible);
    self:_SetVisibility(style_window.SaveButton.Background, isVisible); self:_SetVisibility(style_window.SaveButton.Label, isVisible); self:_SetVisibility(style_window.SaveButton.Icon, isVisible);
    
    if not isVisible then
        self:_HideGlowEffect(style_window.Glow)
        return
    end

    self:_AnimateAndApplyColor(style_window.Background, theme.Colors.SectionBackground)
    self:_AnimateAndApplyColor(style_window.Border, theme.Colors.Separator)
    self:_AnimateAndApplyColor(style_window.HeaderTitle, theme.Colors.TextPrimary)
    self:_AnimateAndApplyColor(style_window.CloseButton.Line1, theme.Colors.TextSecondary)
    self:_AnimateAndApplyColor(style_window.CloseButton.Line2, theme.Colors.TextSecondary)
    self:_AnimateAndApplyColor(style_window.Separator1, theme.Colors.Separator)
    self:_AnimateAndApplyColor(style_window.Separator2, theme.Colors.Separator)
    self:_AnimateAndApplyColor(style_window.Separator3, theme.Colors.Separator)
    self:_AnimateAndApplyColor(style_window.StyleNameLabel, theme.Colors.TextSecondary)
    self:_AnimateAndApplyColor(style_window.StyleNameInputBg, theme.Colors.DarkBlue)
    self:_AnimateAndApplyColor(style_window.StyleNameInputText, theme.Colors.TextPrimary)
    self:_AnimateAndApplyColor(style_window.StyleNameInputCursor, theme.Colors.Accent)
    for _, item in ipairs(style_window.ColorItems) do self:_AnimateAndApplyColor(item.Label, theme.Colors.TextSecondary); self:_AnimateAndApplyColor(item.ColorBorder, theme.Colors.LightGray); end
    self:_AnimateAndApplyColor(style_window.RealTimeToggle.Label, theme.Colors.TextSecondary)
    
    -- [[ НАЧАЛО ИЗМЕНЕНИЙ: Логика цвета для кнопки Cancel ]]
    local cancelButtonBgColor = theme.Colors.MainBackground
    local cancelButtonFgColor = self:_GetTextColorForBackground(cancelButtonBgColor)
    self:_AnimateAndApplyColor(style_window.CancelButton.Background, cancelButtonBgColor)
    self:_AnimateAndApplyColor(style_window.CancelButton.Border, theme.Colors.Separator)
    self:_AnimateAndApplyColor(style_window.CancelButton.IconLine1, cancelButtonFgColor)
    self:_AnimateAndApplyColor(style_window.CancelButton.IconLine2, cancelButtonFgColor)
    self:_AnimateAndApplyColor(style_window.CancelButton.Label, cancelButtonFgColor)
    -- [[ КОНЕЦ ИЗМЕНЕНИЙ ]]
    
    local saveButtonAccentColor = theme.Colors.Accent
    self:_AnimateAndApplyColor(style_window.SaveButton.Background, saveButtonAccentColor)
    local saveButtonTextColor = self:_GetTextColorForBackground(saveButtonAccentColor)
    self:_AnimateAndApplyColor(style_window.SaveButton.Label, saveButtonTextColor)
    self:_AnimateAndApplyColor(style_window.SaveButton.Icon, saveButtonTextColor)

    local winW, winH = 300, 540
    local winX, winY = self.Window.X + self.Window.Width + 15, self.Window.Y
    
    style_window.ClickRegion = {x1 = winX, y1 = winY, x2 = winX + winW, y2 = winY + winH}
    style_window.Background.Position = {winX, winY}; style_window.Background.Size = {winW, winH}
    style_window.Border.Position = {winX, winY}; style_window.Border.Size = {winW, winH}
    self:_RenderGlowEffect(style_window.Glow, winX, winY, winW, winH, style_window.Background.Rounding, theme.Colors.GlowColor)

    local headerY = winY + 12
    local accentIconColor = style_window.EditingTheme.Colors.Accent or {255,255,255,255}
    self:_AnimateAndApplyColor(style_window.HeaderIcon, accentIconColor)
    style_window.HeaderIcon.Position = {winX + 15, headerY}
    style_window.HeaderTitle.Position = {winX + 15 + style_window.HeaderIcon.Size.x + 8, headerY + 1}
    
    style_window.CloseButton.Line1.From = {winX + winW - 25, headerY}; style_window.CloseButton.Line1.To = {winX + winW - 15, headerY + 10}
    style_window.CloseButton.Line2.From = {winX + winW - 25, headerY + 10}; style_window.CloseButton.Line2.To = {winX + winW - 15, headerY}
    style_window.CloseButton.ClickRegion = {x1 = winX + winW - 30, y1 = winY + 10, x2 = winX + winW - 10, y2 = winY + 25}

    local currentY = winY + 40
    style_window.Separator1.From = {winX + 10, currentY}; style_window.Separator1.To = {winX + winW - 10, currentY}
    
    currentY = currentY + 15
    style_window.StyleNameLabel.Position = {winX + 15, currentY}
    local inputW = 150; local inputH = 25
    local inputX = winX + winW - inputW - 15
    style_window.StyleNameInputBg.Position = {inputX, currentY - 5}; style_window.StyleNameInputBg.Size = {inputW, inputH}
    style_window.StyleNameInputText.Position = {inputX + 8, currentY - 5 + (inputH/2) - (style_window.StyleNameInputText.Size / 2)}
    style_window.StyleNameInputClickRegion = {x1 = inputX, y1 = currentY - 5, x2 = inputX + inputW, y2 = currentY - 5 + inputH}
    
    if style_window.StyleNameInputText.TextBounds then
        local cursorX = inputX + 8 + style_window.StyleNameInputText.TextBounds.x
        local cursorY = currentY - 5 + 4
        style_window.StyleNameInputCursor.From = {cursorX, cursorY}
        style_window.StyleNameInputCursor.To = {cursorX, cursorY + inputH - 8}
    end

    currentY = currentY + 30
    style_window.Separator2.From = {winX + 10, currentY}; style_window.Separator2.To = {winX + winW - 10, currentY}
    
    currentY = currentY + 15
    for _, item in ipairs(style_window.ColorItems) do
        item.Label.Position = {winX + 15, currentY}
        local circleX = winX + winW - 30
        
        local c = style_window.EditingTheme.Colors[item.Name] or {255,0,255,255}
        self:_AnimateAndApplyColor(item.ColorCircle, c)

        item.ColorCircle.Position = {circleX, currentY + 7}
        item.ColorBorder.Position = {circleX, currentY + 7}
        item.ClickRegion = {x1 = winX + 15, y1 = currentY, x2 = winX + winW - 15, y2 = currentY + 20}
        currentY = currentY + 25
    end
    
    currentY = currentY + 20
    style_window.Separator3.From = {winX + 10, currentY}; style_window.Separator3.To = {winX + winW - 10, currentY}

    local footerY = winY + winH - 70
    local saveBtn = style_window.SaveButton; local saveBtnW, saveBtnH = 80, 28
    local saveBtnX, saveBtnY = winX + winW - saveBtnW - 15, footerY
    saveBtn.Background.Position = {saveBtnX, saveBtnY}; saveBtn.Background.Size = {saveBtnW, saveBtnH}
    local saveIconX = saveBtnX + 12; local saveIconY = saveBtnY + (saveBtnH / 2) - (saveBtn.Icon.Size.y / 2)
    saveBtn.Icon.Position = {saveIconX, saveIconY}
    saveBtn.Label.Position = {saveIconX + saveBtn.Icon.Size.x + 8, saveBtnY + (saveBtnH / 2) - (saveBtn.Label.Size / 2)}
    saveBtn.ClickRegion = {x1 = saveBtnX, y1 = saveBtnY, x2 = saveBtnX + saveBtnW, y2 = saveBtnY + saveBtnH}

    local cancelBtn = style_window.CancelButton; local cancelBtnW, cancelBtnH = 90, 28
    local cancelBtnX = saveBtnX - cancelBtnW - 10; local cancelBtnY = footerY
    cancelBtn.Background.Position = {cancelBtnX, cancelBtnY}; cancelBtn.Background.Size = {cancelBtnW, cancelBtnH}
    cancelBtn.Border.Position = {cancelBtnX, cancelBtnY}; cancelBtn.Border.Size = {cancelBtnW, cancelBtnH}
    local cancelIconCenterX, cancelIconCenterY = cancelBtnX + 15, cancelBtnY + cancelBtnH / 2
    cancelBtn.IconLine1.From = {cancelIconCenterX - 4, cancelIconCenterY - 4}; cancelBtn.IconLine1.To = {cancelIconCenterX + 4, cancelIconCenterY + 4}
    cancelBtn.IconLine2.From = {cancelIconCenterX - 4, cancelIconCenterY + 4}; cancelBtn.IconLine2.To = {cancelIconCenterX + 4, cancelIconCenterY - 4}
    cancelBtn.Label.Position = {cancelIconCenterX + 10, cancelBtnY + (cancelBtnH / 2) - (cancelBtn.Label.Size / 2)}
    cancelBtn.ClickRegion = {x1 = cancelBtnX, y1 = cancelBtnY, x2 = cancelBtnX + cancelBtnW, y2 = cancelBtnY + cancelBtnH}
    
    local toggleY = footerY + cancelBtnH + 15
    local toggle = style_window.RealTimeToggle
    toggle.Label.Position = {winX + 15, toggleY + 5}
    if toggle.Label.TextBounds then
      local toggleBackX = winX + 15 + toggle.Label.TextBounds.x + 10
      local toggleBackY = toggleY + 7 - 2
      toggle.Back.Position = {toggleBackX, toggleBackY}; 
      toggle.Back.Size = {toggle.Size.width, toggle.Size.height}; 
      toggle.ClickRegion = {x1 = toggleBackX, y1 = toggleBackY, x2 = toggleBackX + toggle.Size.width, y2 = toggleBackY + toggle.Size.height}
      
      local backColor, nubColor
      local nubY = toggleBackY + toggle.Size.height/2
      if self.UI.Values[toggle.id] then
          backColor = theme.Colors.ToggleEnabledBackground or self:_DarkenColor(theme.Colors.Accent, 0.3)
          nubColor = theme.Colors.Accent
          toggle.Nub.Position = {toggleBackX + toggle.Size.width - toggle.Size.height / 2, nubY}
      else
          backColor = theme.Colors.DarkGray
          nubColor = theme.Colors.LightGray
          toggle.Nub.Position = {toggleBackX + toggle.Size.height / 2, nubY}
      end
      self:_AnimateAndApplyColor(toggle.Back, backColor)
      self:_AnimateAndApplyColor(toggle.Nub, nubColor)
    end
end

function Library:_RenderColorPickerWindow()
    local picker = self.UI.Popups.ColorPicker
    local isVisible = picker.IsOpen

    self:_SetVisibility(picker.Background, isVisible)
    self:_SetVisibility(picker.Border, isVisible)
    self:_SetVisibility(picker.ColorSquare, isVisible)
    self:_SetVisibility(picker.GradientOverlay, isVisible)
    self:_SetVisibility(picker.SaturationValueNub, isVisible)
    self:_SetVisibility(picker.HueSlider, isVisible)
    self:_SetVisibility(picker.HueNub, isVisible)
    self:_SetVisibility(picker.HueNubBorder, isVisible)
    self:_SetVisibility(picker.OpacitySliderBackground, isVisible)
    self:_SetVisibility(picker.OpacitySliderGradient, isVisible)
    self:_SetVisibility(picker.OpacityNub, isVisible)
    self:_SetVisibility(picker.OpacityNubBorder, isVisible)
    
    if isVisible then
        local padding = 10
        local squareSize = 160
        local sliderHeight = 8
        local sliderSpacing = 12

        local pickerW = squareSize + (padding * 2)
        local pickerH = squareSize + (padding * 2) + (sliderHeight * 2) + (sliderSpacing * 2)
        local pickerX, pickerY = picker.Pos.x, picker.Pos.y
        
        picker.Background.Position = {pickerX, pickerY}
        picker.Background.Size = {pickerW, pickerH}
        local bgColor = self.ActiveTheme.Colors.SectionBackground
        picker.Background.Color = {bgColor[1], bgColor[2], bgColor[3]}
        picker.Background.Opacity = (bgColor[4] or 255) / 255

        picker.Border.Position = {pickerX, pickerY}
        picker.Border.Size = {pickerW, pickerH}
        local borderColor = self.ActiveTheme.Colors.Separator
        picker.Border.Color = {borderColor[1], borderColor[2], borderColor[3]}
        picker.Border.Opacity = (borderColor[4] or 255) / 255

        self:_RenderGlowEffect(picker.Glow, pickerX, pickerY, pickerW, pickerH, picker.Background.Rounding, self.ActiveTheme.Colors.GlowColor)

        local squareX = pickerX + padding
        local squareY = pickerY + padding
        
        -- Main saturation/value square
        picker.ColorSquare.Position = {squareX, squareY}
        picker.ColorSquare.Size = {squareSize, squareSize}
        local pureHue = self:_HSVtoRGB(picker.h, 1, 1)
        picker.ColorSquare.Color = {pureHue[1], pureHue[2], pureHue[3]}

        picker.GradientOverlay.Position = {squareX, squareY}
        picker.GradientOverlay.Size = {squareSize, squareSize}

        local svNubX = squareX + (picker.s * squareSize)
        local svNubY = squareY + ((1 - picker.v) * squareSize)
        picker.SaturationValueNub.Position = {svNubX, svNubY}
        picker.SaturationValueNub.Color = picker.v > 0.5 and {0,0,0} or {255,255,255}
        picker.SaturationValueRegion = {x1 = squareX, y1 = squareY, x2 = squareX + squareSize, y2 = squareY + squareSize}

        local currentY = squareY + squareSize + sliderSpacing

        -- Hue Slider
        picker.HueSlider.Position = {squareX, currentY}
        picker.HueSlider.Size = {squareSize, sliderHeight}
        local hueNubX = squareX + (picker.h * squareSize)
        local hueNubY = currentY + sliderHeight / 2
        picker.HueNub.Position = {hueNubX, hueNubY}
        picker.HueNubBorder.Position = {hueNubX, hueNubY}
        local hueNubColor = self:_HSVtoRGB(picker.h, 1, 1) -- Dynamic color
        picker.HueNub.Color = {hueNubColor[1], hueNubColor[2], hueNubColor[3]}
        picker.HueNubBorder.Color = {0, 0, 0}
        picker.HueSliderRegion = {x1 = squareX, y1 = currentY, x2 = squareX + squareSize, y2 = currentY + sliderHeight}

        currentY = currentY + sliderHeight + sliderSpacing

        -- Opacity Slider
        picker.OpacitySliderBackground.Position = {squareX, currentY}
        picker.OpacitySliderBackground.Size = {squareSize, sliderHeight}
        local opacityBgColor = self:_HSVtoRGB(picker.h, picker.s, picker.v)
        picker.OpacitySliderBackground.Color = {opacityBgColor[1], opacityBgColor[2], opacityBgColor[3]}
        
        picker.OpacitySliderGradient.Position = {squareX, currentY}
        picker.OpacitySliderGradient.Size = {squareSize, sliderHeight}

        local opacityNubX = squareX + (picker.a * squareSize)
        local opacityNubY = currentY + sliderHeight / 2
        picker.OpacityNub.Position = {opacityNubX, opacityNubY}
        picker.OpacityNubBorder.Position = {opacityNubX, opacityNubY}
        picker.OpacityNub.Color = {255, 255, 255}
        picker.OpacityNubBorder.Color = {0, 0, 0}
        picker.OpacitySliderRegion = {x1 = squareX, y1 = currentY, x2 = squareX + squareSize, y2 = currentY + sliderHeight}
    else
        self:_HideGlowEffect(picker.Glow)
    end
end

function Library:_RenderLoop()
    -- << НАЧАЛО: Новая логика глобальной анимации >>
    local speed_value = self.UI.Values["AboutAnimationSpeed"] or 2.4
    local animationSpeed = (speed_value > 0) and (speed_value / 10.0) or 1 -- Ускоренная анимация для плавности
    
    if self.GlobalAnimation.IsHiding then
        self.GlobalAnimation.Opacity = self.GlobalAnimation.Opacity - animationSpeed
        if self.GlobalAnimation.Opacity <= 0 then
            self.GlobalAnimation.Opacity = 0 -- Принудительно устанавливаем 0
            self.GlobalAnimation.IsHiding = false
        end
    elseif self.GlobalAnimation.IsShowing then
        self.GlobalAnimation.Opacity = self.GlobalAnimation.Opacity + animationSpeed
        if self.GlobalAnimation.Opacity >= 1 then
            self.GlobalAnimation.Opacity = 1 -- Принудительно устанавливаем 1
            self.GlobalAnimation.IsShowing = false
        end
    end
    -- << КОНЕЦ: Новая логика глобальной анимации >>
    if not self.Window.Visible then return end

    -- Проверяем, изменилась ли вкладка с прошлого кадра
    if self.Window.ActiveTab ~= self.Window.LastRenderedTab and self.Window.LastRenderedTab ~= "" then
        -- Если да, запускаем анимацию "исчезновения" старой вкладки
        self.Window.Animation.State = "FADING_OUT"
        self.Window.Animation.OldTab = self.Window.LastRenderedTab
    end

    if self.UI.Core.ConfigsTab.NeedsRefresh then
        self:_RefreshConfigList()
        self.UI.Core.ConfigsTab.NeedsRefresh = false
    end

    if self.UI.Values["AboutAutoSave"] and self.UI.Core.ConfigsTab.LoadedConfigName ~= "" then
        if tick() - lastAutoSaveTime > autoSaveInterval then
            self:_SaveConfig(self.UI.Core.ConfigsTab.LoadedConfigName)
            lastAutoSaveTime = tick()
        end
    end

    self:_UpdateAnimationStates()

    local mouse_pos = getmouseposition()
    if not mouse_pos then return end

    local Core = self.UI.Core
    local theme = self.ActiveTheme
    local isThemeLight = self:_IsThemeLight(theme)
    local windowX, windowY = self:_SafeNumber(self.Window.X, 0), self:_SafeNumber(self.Window.Y, 0)
    local sidebarWidth, headerHeight = self:_SafeNumber(self.Window.SidebarWidth, 0), self:_SafeNumber(self.Window.HeaderHeight, 0)
    local rightPanelX = windowX + sidebarWidth - self.Window.PanelOverlap

    self:_SetVisibility(Core.Sidebar.Drawing, true); self:_SetVisibility(Core.RightPanel.Drawing, true); self:_SetVisibility(Core.VerticalSeparator, true); self:_SetVisibility(Core.SidebarHeaderSeparator, true); self:_SetVisibility(Core.RightPanelHeaderSeparator, true); self:_SetVisibility(Core.Title, true); self:_SetVisibility(Core.SidebarBottomCircle, true); if Core.SidebarAvatar then self:_SetVisibility(Core.SidebarAvatar, true) end; self:_SetVisibility(Core.PlayerDisplayName, true); self:_SetVisibility(Core.TillLabel, true); self:_SetVisibility(Core.ForeverLabel, true)
    self:_SetVisibility(Core.Title2, not isThemeLight); self:_SetVisibility(Core.Title3, not isThemeLight)

    self:_AnimateAndApplyColor(Core.Sidebar.Drawing, theme.Colors.SidebarBackground)
    self:_AnimateAndApplyColor(Core.RightPanel.Drawing, theme.Colors.MainBackground)
    self:_AnimateAndApplyColor(Core.VerticalSeparator, theme.Colors.Separator)
    self:_AnimateAndApplyColor(Core.SidebarHeaderSeparator, theme.Colors.Separator)
    self:_AnimateAndApplyColor(Core.RightPanelHeaderSeparator, theme.Colors.Separator)
    self:_AnimateAndApplyColor(Core.Title, theme.Colors.TextPrimary)
    self:_AnimateAndApplyColor(Core.Title2, theme.Colors.Accent)
    self:_AnimateAndApplyColor(Core.Title3, theme.Colors.SectionBackground)
    self:_AnimateAndApplyColor(Core.SidebarBottomCircle, theme.Colors.Separator)
    self:_AnimateAndApplyColor(Core.PlayerDisplayName, theme.Colors.TextPrimary)
    self:_AnimateAndApplyColor(Core.TillLabel, theme.Colors.TextSecondary)
    self:_AnimateAndApplyColor(Core.ForeverLabel, theme.Colors.Accent)
    if Core.SidebarAvatar then self:_AnimateAndApplyColor(Core.SidebarAvatar, {255, 255, 255, 255}) end

    if Core.Sidebar.Drawing then Core.Sidebar.Drawing.Position = {windowX, windowY}; Core.Sidebar.Drawing.Size = {sidebarWidth, self.Window.Height}; end
    if Core.RightPanel.Drawing then Core.RightPanel.Drawing.Position = {rightPanelX, windowY}; Core.RightPanel.Drawing.Size = {self.Window.Width - sidebarWidth + self.Window.PanelOverlap, self.Window.Height}; end

    self:_RenderGlowEffect(Core.Sidebar.Glow, windowX, windowY, sidebarWidth, self.Window.Height, Core.Sidebar.Drawing.Rounding, theme.Colors.GlowColor, {top=true, bottom=true, left=true, right=true})
    self:_RenderGlowEffect(Core.RightPanel.Glow, rightPanelX, windowY, self.Window.Width - sidebarWidth + self.Window.PanelOverlap, self.Window.Height, Core.RightPanel.Drawing.Rounding, theme.Colors.GlowColor, {top=true, bottom=true, left=false, right=true})

    if Core.VerticalSeparator then Core.VerticalSeparator.Position = {rightPanelX, windowY}; Core.VerticalSeparator.Size = {4, self.Window.Height}; end
    if Core.SidebarHeaderSeparator then Core.SidebarHeaderSeparator.Position = {windowX, windowY + self.Window.Height - 100 + 14}; Core.SidebarHeaderSeparator.Size = {sidebarWidth, 4}; end
    if Core.RightPanelHeaderSeparator then Core.RightPanelHeaderSeparator.Position = {rightPanelX, windowY + headerHeight}; Core.RightPanelHeaderSeparator.Size = {self.Window.Width - sidebarWidth + self.Window.PanelOverlap, 4}; end
    if Core.Title then Core.Title.Position = {windowX + 11, windowY + 25}; end
    if Core.Title2 then Core.Title2.Position = {windowX + 9, windowY + 26}; end
    if Core.Title3 then Core.Title3.Position = {windowX + 7, windowY + 24}; end
    if Core.SidebarBottomCircle then local circleX = windowX + 8 + Core.SidebarBottomCircle.Radius; local circleY = windowY + self.Window.Height - 44; Core.SidebarBottomCircle.Position = {circleX, circleY}; end
    if Core.SidebarAvatar then local avatarSize = 56; local avatarX = windowX + 8; local avatarY = windowY + self.Window.Height - 44 - avatarSize / 2; Core.SidebarAvatar.Position = {avatarX, avatarY}; Core.SidebarAvatar.Size = {avatarSize, avatarSize}; end
    if Core.PlayerDisplayName then local textX = windowX + 15 + Core.SidebarBottomCircle.Radius * 2 + 5; local textY = windowY + self.Window.Height - 56; Core.PlayerDisplayName.Position = {textX, textY}; end
    if Core.TillLabel then local textX = windowX + 15 + Core.SidebarBottomCircle.Radius * 2 + 5; local textY = windowY + self.Window.Height - 40; Core.TillLabel.Position = {textX, textY}; end
    if Core.ForeverLabel then local textX = windowX + 8 + Core.SidebarBottomCircle.Radius * 2 + 30; local textY = windowY + self.Window.Height - 40; Core.ForeverLabel.Position = {textX, textY}; end

    do
        local startX, startY = rightPanelX + 35, windowY + (headerHeight / 2)
        local function renderHeaderButton(button, x, y, width, height, has_icon, is_accent)
             self:_SetVisibility(button.Background, true); self:_SetVisibility(button.Border, true); self:_SetVisibility(button.Label, true); if button.Icon then self:_SetVisibility(button.Icon, button.Icon.Visible) end

             button.Background.Position = {x, y}; button.Background.Size = {width, height};
             button.Border.Position = {x, y}; button.Border.Size = {width, height};

             local isHovered = self:_IsPointInRegion(mouse_pos.x, mouse_pos.y, button.ClickRegion)
             button.IsHovered = isHovered

             local targetBgColor, targetTextColor

             if button == Core.HeaderButtons.CreateNew then
                local baseColor = theme.Colors.Accent
                local opacity = isHovered and 255 or (255 * 0.6)
                targetBgColor = {baseColor[1], baseColor[2], baseColor[3], opacity}
                targetTextColor = self:_GetTextColorForBackground(baseColor)
             else
                targetBgColor = isHovered and self:_DarkenColor(theme.Colors.Accent, 0.5) or (is_accent and theme.Colors.Accent or theme.Colors.MainBackground)
                targetTextColor = is_accent and self:_GetTextColorForBackground(theme.Colors.Accent) or theme.Colors.TextPrimary
             end

             local targetBorderColor = (tick() - (button.ClickTime or 0) < 0.1 or (button.IsOpen)) and theme.Colors.Accent or theme.Colors.Separator

             self:_AnimateAndApplyColor(button.Background, targetBgColor)
             self:_AnimateAndApplyColor(button.Border, targetBorderColor)
             self:_AnimateAndApplyColor(button.Label, targetTextColor)
             if button.Icon then self:_AnimateAndApplyColor(button.Icon, targetTextColor) end

             if has_icon and button.Icon then local iconX, iconY = x + 12, y + (height / 2) - (button.Icon.Size.y / 2); button.Icon.Position = {iconX, iconY}; local labelX, labelY = iconX + button.Icon.Size.x + 5, y + (height / 2) - (button.Label.Size / 2); button.Label.Position = {labelX, labelY}; button.Label.Center = false else button.Label.Position = {x + width / 2, y + (height / 2) - (button.Label.Size / 2)}; button.Label.Center = true end
             button.ClickRegion = {x1 = x, y1 = y, x2 = x + width, y2 = y + height}
        end

        local btnWidth, btnHeight, spacing = 75, 30, 15
        local createNewBtnWidth = 120
        local btnY = startY - (btnHeight / 2)
        local currentX = startX

        renderHeaderButton(Core.HeaderButtons.Save, currentX, btnY, btnWidth, btnHeight, true, false)
        currentX = currentX + btnWidth + spacing

        renderHeaderButton(Core.HeaderButtons.ViewESP, currentX, btnY, btnWidth, btnHeight, false, false)
        currentX = currentX + btnWidth + spacing

        if self.Window.ActiveTab == "Configs" then
            renderHeaderButton(Core.HeaderButtons.CreateNew, currentX, btnY, createNewBtnWidth, btnHeight, true, true)
        else
            self:_SetVisibility(Core.HeaderButtons.CreateNew.Background, false); self:_SetVisibility(Core.HeaderButtons.CreateNew.Border, false); self:_SetVisibility(Core.HeaderButtons.CreateNew.Label, false); self:_SetVisibility(Core.HeaderButtons.CreateNew.Icon, false);
        end

        local settingsIcon = Core.HeaderButtons.Settings.Icon
        local settingsX = rightPanelX + (self.Window.Width - sidebarWidth + self.Window.PanelOverlap) - settingsIcon.Size.x - 20 - 30
        local settingsY = startY - (settingsIcon.Size.y / 2)
        self:_SetVisibility(settingsIcon, true); settingsIcon.Position = {settingsX, settingsY}; Core.HeaderButtons.Settings.ClickRegion = {x1 = settingsX, y1 = settingsY, x2 = settingsX + settingsIcon.Size.x, y2 = settingsY + settingsIcon.Size.y}
        self:_AnimateAndApplyColor(settingsIcon, theme.Colors.TextSecondary)
    end

    self:_SetVisibility(Core.ViewESPPanel, Core.HeaderButtons.ViewESP.IsOpen); self:_SetVisibility(Core.ViewESPPanelBorder, Core.HeaderButtons.ViewESP.IsOpen)
    if Core.HeaderButtons.ViewESP.IsOpen then
        local panelX = windowX + self.Window.Width + 11;
        self:_AnimateAndApplyColor(Core.ViewESPPanel, theme.Colors.SectionBackground)
        self:_AnimateAndApplyColor(Core.ViewESPPanelBorder, theme.Colors.Separator)
        self:_AnimateAndApplyColor(Core.ViewESPImage, {255,255,255,255})
        Core.ViewESPPanel.Position = {panelX, windowY}; Core.ViewESPPanel.Size = {200, 310};
        Core.ViewESPPanelBorder.Position = {panelX, windowY}; Core.ViewESPPanelBorder.Size = {200, 310};
        if Core.ViewESPImage then self:_SetVisibility(Core.ViewESPImage, true); local imageX, imageY = panelX + 3, windowY + 3; Core.ViewESPImage.Position = {imageX, imageY}; Core.ViewESPImage.Size = {194, 304}; end
    elseif Core.ViewESPImage then self:_SetVisibility(Core.ViewESPImage, false) end

    self:_RenderTabs(windowX, windowY + headerHeight, sidebarWidth)

    if self.Window.ActiveTab == "Configs" then
        -- Скрываем все секции, если активна вкладка конфигов
        for _, section in ipairs(self.UI.Sections) do
            local anim_state = self.AnimationState[section.Drawing.Background]
            if anim_state and anim_state.IsVisible then
                self:_SetSectionAndElementsVisibility(section, false)
                anim_state.IsVisible = false
            end
        end
        self:_RenderConfigsTab(rightPanelX, windowY, headerHeight)
    else
        -- << НАЧАЛО ИСПРАВЛЕНИЯ: СКРЫВАЕМ ЭЛЕМЕНТЫ CONFIGS БЕЗОПАСНО >>
        local configsTab = self.UI.Core.ConfigsTab
        if configsTab.MyItemsLabel.Visible then
            self:_SetVisibility(configsTab.MyItemsLabel, false)
            self:_SetVisibility(configsTab.Scrollbar.Background, false)
            self:_SetVisibility(configsTab.Scrollbar.Nub, false)
            for _, item in ipairs(configsTab.Items) do
                self:_SetDrawingTableVisibility(item.Drawing, false) -- Используем новую функцию
            end
        end
        -- << КОНЕЦ ИСПРАВЛЕНИЯ >>
        self:_RenderSections(rightPanelX, windowY, headerHeight)
    end

    -- Рендерим все pop-up окна поверх
    self:_RenderSaveTooltip()
    self:_RenderConfigOptionsPopup()
    self:_RenderSettingsPopup()
    self:_RenderAboutWindow(mouse_pos)
    self:_RenderEditStyleWindow()
    self:_RenderColorPickerWindow()

    -- Запоминаем текущую вкладку для следующего кадра
    self.Window.LastRenderedTab = self.Window.ActiveTab

    if not self.GlobalAnimation.IsHiding and self.GlobalAnimation.Opacity <= 0 then
        self.Window.Visible = false
    end
end

function Library:_RenderTabs(x, y, width)
    local currentY = y + 25
    local theme = self.ActiveTheme
    -- [[ НОВОЕ: Получаем глобальную прозрачность для применения к подсветке ]]
    local globalOpacity = self.GlobalAnimation and self.GlobalAnimation.Opacity or 1

    for _, group in ipairs(self.UI.TabGroups) do
        if group.Header then
            self:_SetVisibility(group.Header, true)
            self:_AnimateAndApplyColor(group.Header, theme.Colors.TabHeader)
            group.Header.Position = {x + 25, currentY}
        end
        currentY = currentY + theme.Fonts.TabHeaderSize + 10

        for _, tab in ipairs(group.Tabs) do
            local tabHeight = theme.Fonts.TabSize + 10
            local is_active = (self.Window.ActiveTab == tab.Name)
            local target_text_color = is_active and theme.Colors.TextPrimary or theme.Colors.TextSecondary
            local startX = x + 25

            if tab.Icon then
                self:_SetVisibility(tab.Icon, true)
                tab.Icon.Position = {startX, currentY + (tabHeight / 2) - (theme.IconSize / 2)}
                local iconColor = theme.Colors.Accent
                self:_AnimateAndApplyColor(tab.Icon, iconColor)
                startX = startX + theme.IconSize + 8
            end

            if tab.Text then
                self:_SetVisibility(tab.Text, true)
                tab.Text.Position = {startX, currentY + (tabHeight / 2) - (tab.Text.Size / 2)}
                self:_AnimateAndApplyColor(tab.Text, target_text_color)
            end

            tab.ClickRegion = {x1 = x + 10, y1 = currentY, x2 = x + width - 10, y2 = currentY + tabHeight}

            if tab.Highlight then
                tab.Highlight.Position = {x + 10, currentY}
                tab.Highlight.Size = {self.Window.SidebarWidth - 20, tabHeight}
                
                local accentColor = theme.Colors.Accent
                tab.Highlight.Color = {accentColor[1], accentColor[2], accentColor[3]}

                local state = self.AnimationState[tab.Highlight]
                if not state then
                    local initialOpacity = is_active and (theme.Transparency.ActiveTabHighlight or 0.28) or 0
                    state = { CurrentOpacity = initialOpacity }
                    self.AnimationState[tab.Highlight] = state
                end

                local targetOpacity = is_active and (theme.Transparency.ActiveTabHighlight or 0.28) or 0
                local speed_value = self.UI.Values["AboutAnimationSpeed"] or 2.4
                local animationSpeed = speed_value / 16.0

                state.CurrentOpacity = state.CurrentOpacity + (targetOpacity - state.CurrentOpacity) * animationSpeed
                -- [[ ИСПРАВЛЕНО: Домножаем на глобальную прозрачность ]]
                tab.Highlight.Opacity = state.CurrentOpacity * globalOpacity
            end

            currentY = currentY + tabHeight + 5
        end
        currentY = currentY + 15
    end
end

function Library:_RenderSingleSection(section, sectionX, sectionY, columnWidth, yOffset, masterOpacity)
    local theme = self.ActiveTheme
    local isThemeLight = self:_IsThemeLight(theme) -- < НОВОЕ: Проверка на светлую тему
    local animatedY = sectionY + yOffset

    local sDrawing = section.Drawing
    for _, obj in pairs(sDrawing) do self:_SetVisibility(obj, true) end
    self:_AnimateAndApplyColor(sDrawing.Background, theme.Colors.SectionBackground, masterOpacity)
    self:_AnimateAndApplyColor(sDrawing.Border, theme.Colors.Separator, masterOpacity)
    self:_AnimateAndApplyColor(sDrawing.Title, theme.Colors.TextPrimary, masterOpacity)
    self:_AnimateAndApplyColor(sDrawing.Separator, theme.Colors.Separator, masterOpacity)

    sDrawing.Background.Position = {sectionX, animatedY}
    sDrawing.Border.Position = {sectionX, animatedY}
    sDrawing.Title.Position = {sectionX + 10, animatedY + 8}
    local separatorY_abs = sDrawing.Title.Position.y + sDrawing.Title.Size + 5
    sDrawing.Separator.From = {sectionX + 10, separatorY_abs}; sDrawing.Separator.To = {sectionX + columnWidth - 10, separatorY_abs}

    local elementY_offset = (separatorY_abs - animatedY) + 15

    for _, el in ipairs(section.Elements) do
        self:_SetVisibility(el.Label, true)
        if el.type == "Toggle" then
            self:_SetVisibility(el.Back, true); self:_SetVisibility(el.Nub, true)
            local currentElementY = animatedY + elementY_offset
            self:_AnimateAndApplyColor(el.Label, theme.Colors.TextSecondary, masterOpacity)
            el.Label.Position = {sectionX + 10, currentElementY}
            local toggleBackX = sectionX + columnWidth - el.Size.width - 15
            local toggleBackY = currentElementY - 1
            el.Back.Position = {toggleBackX, toggleBackY}; el.Back.Size = {el.Size.width, el.Size.height};
            el.ClickRegion = {x1 = toggleBackX, y1 = toggleBackY, x2 = toggleBackX + el.Size.width, y2 = toggleBackY + el.Size.height}
            local is_on = self.UI.Values[el.id]
            local nubY = toggleBackY + el.Size.height / 2
            local targetBackColor, targetNubColor
            
            -- [[ НАЧАЛО ИЗМЕНЕНИЙ: Логика цвета для Toggle ]]
            if is_on then
                if isThemeLight then
                    targetBackColor = theme.Colors.Accent
                    targetNubColor = theme.Colors.SectionBackground
                else
                    targetBackColor = self:_DarkenColor(theme.Colors.Accent, 0.3)
                    targetNubColor = theme.Colors.Accent
                end
            else
                targetBackColor = theme.Colors.DarkGray
                targetNubColor = theme.Colors.LightGray
            end
            -- [[ КОНЕЦ ИЗМЕНЕНИЙ ]]

            el.Nub.Position = is_on and {toggleBackX + el.Size.width - el.Size.height / 2, nubY} or {toggleBackX + el.Size.height / 2, nubY}
            self:_AnimateAndApplyColor(el.Back, targetBackColor, masterOpacity); self:_AnimateAndApplyColor(el.Nub, targetNubColor, masterOpacity)
            
            local iconAreaX = toggleBackX - 10
            if el.HasColor and el.ColorCircle then
                self:_SetVisibility(el.ColorCircle, true); self:_SetVisibility(el.ColorBorder, true)
                local colorValue = self.UI.Values[el.HasColor.id]
                self:_AnimateAndApplyColor(el.ColorCircle, colorValue, masterOpacity); self:_AnimateAndApplyColor(el.ColorBorder, theme.Colors.LightGray, masterOpacity)
                local radius = el.ColorCircle.Radius; local iconWidth = radius * 2
                local iconX = iconAreaX - iconWidth
                el.ColorCircle.Position = {iconX + radius, currentElementY + 7}; el.ColorBorder.Position = {iconX + radius, currentElementY + 7}
                el.ColorClickRegion = {x1 = iconX, y1 = currentElementY, x2 = iconX + iconWidth, y2 = currentElementY + 14}
                iconAreaX = iconX - 5
            else
                if el.ColorCircle then self:_SetVisibility(el.ColorCircle, false) end
                if el.ColorBorder then self:_SetVisibility(el.ColorBorder, false) end
            end
            if el.HasSettings and el.SettingsIcon then
                self:_SetVisibility(el.SettingsIcon, true)
                self:_AnimateAndApplyColor(el.SettingsIcon, theme.Colors.TextSecondary, masterOpacity)
                local iconX = iconAreaX - el.SettingsIcon.Size.x
                el.SettingsIcon.Position = {iconX, currentElementY}
                el.SettingsClickRegion = {x1 = iconX, y1 = currentElementY, x2 = iconX + el.SettingsIcon.Size.x, y2 = currentElementY + el.SettingsIcon.Size.y}
            else
                if el.SettingsIcon then self:_SetVisibility(el.SettingsIcon, false) end
            end
            elementY_offset = elementY_offset + 35
        elseif el.type == "Slider" then
            self:_SetVisibility(el.Back, true); self:_SetVisibility(el.LeftFill, true); self:_SetVisibility(el.Nub, true); self:_SetVisibility(el.ValueText, true)
            local currentElementY = animatedY + elementY_offset
            self:_AnimateAndApplyColor(el.Label, theme.Colors.TextSecondary, masterOpacity)
            el.Label.Position = {sectionX + 10, currentElementY}
            local sliderBackX = sectionX + 100; local sliderBackWidth = columnWidth - 110 - 50
            el.Back.Position = {sliderBackX, currentElementY + 8}; el.Back.Size = {sliderBackWidth, 2};
            el.ClickRegion = { x1 = sliderBackX, y1 = currentElementY - 2, x2 = sliderBackX + sliderBackWidth, y2 = currentElementY + 18 };
            local value_percentage = math.clamp(((self.UI.Values[el.id] or el.Min) - el.Min) / (el.Max - el.Min), 0, 1)
            local nubX = sliderBackX + sliderBackWidth * value_percentage
            el.LeftFill.Position = {sliderBackX, currentElementY + 8}; el.LeftFill.Size = {nubX - sliderBackX, 2}
            el.Nub.Position = {nubX, currentElementY + 9}
            
            local glowWidth = nubX - sliderBackX
            local glowHeight = 6
            if glowWidth > 0 and el.Glow then
                self:_RenderGlowEffect(
                    el.Glow,
                    sliderBackX,
                    currentElementY + 9 - (glowHeight / 2),
                    glowWidth,
                    glowHeight,
                    el.LeftFill.Rounding,
                    theme.Colors.GlowAccent,
                    {top=true, bottom=true, left=true, right=false}
                )
            elseif el.Glow then
                 self:_HideGlowEffect(el.Glow)
            end

            local valueText = tostring(math.floor(self.UI.Values[el.id] or el.Min)); local valueTextX = sectionX + columnWidth - 40
            el.ValueText.Text = valueText; el.ValueText.Position = {valueTextX, currentElementY}
            self:_AnimateAndApplyColor(el.Back, theme.Colors.DarkBlue, masterOpacity); self:_AnimateAndApplyColor(el.LeftFill, theme.Colors.Accent, masterOpacity)
            self:_AnimateAndApplyColor(el.Nub, theme.Colors.Accent, masterOpacity); self:_AnimateAndApplyColor(el.ValueText, theme.Colors.TextPrimary, masterOpacity)
            elementY_offset = elementY_offset + 35
        elseif el.type == "Dropdown" or el.type == "Multidropdown" then
            self:_SetVisibility(el.Button, true); self:_SetVisibility(el.ButtonText, true); self:_SetVisibility(el.ArrowLine1, true); self:_SetVisibility(el.ArrowLine2, true)
            local currentElementY = animatedY + elementY_offset
            self:_AnimateAndApplyColor(el.Label, theme.Colors.TextSecondary, masterOpacity)
            el.Label.Position = {sectionX + 10, currentElementY + 5}
            local dropdownButtonX, dropdownButtonY = sectionX + columnWidth - el.Size.width - 15, currentElementY
            el.Button.Position = {dropdownButtonX, dropdownButtonY}; el.Button.Size = {el.Size.width, el.Size.height}
            local textToShow = (el.type == "Dropdown") and self.UI.Values[el.id] or (#self.UI.Values[el.id] == 0 and "..." or table.concat(self.UI.Values[el.id], ", ")); if #textToShow > 11 then textToShow = string.sub(textToShow, 1, 10) .. "..." end
            el.ButtonText.Position = { dropdownButtonX + 5, dropdownButtonY + el.Size.height / 2 - el.ButtonText.Size / 2 }; el.ButtonText.Text = textToShow
            local arrowX, arrowY = dropdownButtonX + el.Size.width - 15, dropdownButtonY + el.Size.height / 2
            el.ArrowLine1.From = {arrowX, arrowY - 2}; el.ArrowLine1.To = {arrowX + 5, arrowY + 3}; el.ArrowLine2.From = {arrowX + 5, arrowY + 3}; el.ArrowLine2.To = {arrowX + 10, arrowY - 2}
            el.ClickRegion = { x1 = dropdownButtonX, y1 = dropdownButtonY, x2 = dropdownButtonX + el.Size.width, y2 = dropdownButtonY + el.Size.height }
            self:_AnimateAndApplyColor(el.Button, theme.Colors.DarkBlue, masterOpacity); self:_AnimateAndApplyColor(el.ButtonText, theme.Colors.TextPrimary, masterOpacity); self:_AnimateAndApplyColor(el.ArrowLine1, theme.Colors.TextPrimary, masterOpacity); self:_AnimateAndApplyColor(el.ArrowLine2, theme.Colors.TextPrimary, masterOpacity)
            elementY_offset = elementY_offset + 35
            
            if el.IsOpen or el.IsClosing then
                local speed_value = self.UI.Values["AboutAnimationSpeed"] or 2.4
                local animationSpeed = (speed_value / 1.5) / 10.0
                if el.IsOpen and not el.IsClosing then el.FadeOpacity = math.min(1, el.FadeOpacity + animationSpeed)
                elseif el.IsClosing then el.FadeOpacity = math.max(0, el.FadeOpacity - animationSpeed); if el.FadeOpacity == 0 then el.IsClosing = false end end

                if el.FadeOpacity > 0 then
                    local finalOpacity = masterOpacity * el.FadeOpacity
                    local popupWidth = 150; local optionHeight = 25; local popupHeight = (#el.Options * optionHeight) + 10
                    local popupX = dropdownButtonX + (el.Size.width / 2) - (popupWidth / 2); local popupY = dropdownButtonY + (el.Size.height / 2) - (popupHeight / 2)

                    self:_SetVisibility(el.OptionBackground, true); self:_SetVisibility(el.Border, true)
                    self:_AnimateAndApplyColor(el.OptionBackground, theme.Colors.SectionBackground, finalOpacity)
                    self:_AnimateAndApplyColor(el.Border, theme.Colors.Separator, finalOpacity)
                    el.OptionBackground.Position = {popupX, popupY}; el.OptionBackground.Size = {popupWidth, popupHeight}
                    el.Border.Position = {popupX, popupY}; el.Border.Size = {popupWidth, popupHeight}
                    
                    local glowFinalOpacity = 0

                    if el.IsOpen and not el.IsClosing then
                        local threshold = 0.5
                        if el.FadeOpacity > threshold then
                            local glowProgress = (el.FadeOpacity - threshold) / (1.0 - threshold)
                            glowFinalOpacity = masterOpacity * glowProgress
                        end
                    elseif el.IsClosing then
                        glowFinalOpacity = masterOpacity * (el.FadeOpacity * el.FadeOpacity)
                    end

                    local glowColor = self.ActiveTheme.Colors.GlowColor
                    local animatedGlowColor = {glowColor[1], glowColor[2], glowColor[3], (glowColor[4] or 255) * glowFinalOpacity}
                    self:_RenderGlowEffect(el.Glow, popupX, popupY, popupWidth, popupHeight, el.OptionBackground.Rounding, animatedGlowColor)

                    local currentOptionY = popupY + 5
                    local hasSelection = el.type == "Multidropdown" and #self.UI.Values[el.id] > 0
                    
                    local textX = popupX + (hasSelection and 25 or 10)

                    for i, option in ipairs(el.OptionList) do
                        self:_SetVisibility(option.Text, true); self:_SetVisibility(option.Highlight, true)
                        option.ClickRegion = {x1 = popupX, y1 = currentOptionY, x2 = popupX + popupWidth, y2 = currentOptionY + optionHeight}
                        option.Text.Position = {textX, currentOptionY + (optionHeight / 2) - (option.Text.Size / 2)}
                        option.Highlight.Position = {popupX + 5, currentOptionY}; option.Highlight.Size = {popupWidth - 10, optionHeight}

                        local isSelected = (el.type == "Dropdown" and self.UI.Values[el.id] == el.Options[i]) or (el.type == "Multidropdown" and table.find(self.UI.Values[el.id], el.Options[i]))
                        local isHovered = (el.HoveredOptionIndex == i)
                        
                        local targetTextColor = isSelected and theme.Colors.Accent or theme.Colors.TextPrimary
                        self:_AnimateAndApplyColor(option.Text, targetTextColor, finalOpacity)

                        if isHovered then
                            local highlightColor = theme.Colors.Separator
                            self:_AnimateAndApplyColor(option.Highlight, highlightColor, finalOpacity * 0.4)
                        else
                            option.Highlight.Opacity = 0
                        end

                        if el.type == "Multidropdown" then
                            self:_SetVisibility(option.CheckmarkLine1, isSelected); self:_SetVisibility(option.CheckmarkLine2, isSelected)
                            if isSelected then
                                local checkY = currentOptionY + (optionHeight / 2)
                                option.CheckmarkLine1.From = {popupX + 8, checkY}; option.CheckmarkLine1.To = {popupX + 11, checkY + 3}
                                option.CheckmarkLine2.From = {popupX + 11, checkY + 3}; option.CheckmarkLine2.To = {popupX + 15, checkY - 4}
                                self:_AnimateAndApplyColor(option.CheckmarkLine1, theme.Colors.Accent, finalOpacity)
                                self:_AnimateAndApplyColor(option.CheckmarkLine2, theme.Colors.Accent, finalOpacity)
                            end
                        end
                        currentOptionY = currentOptionY + optionHeight
                    end
                end
            else
                self:_HideGlowEffect(el.Glow)
                self:_SetVisibility(el.OptionBackground, false)
                self:_SetVisibility(el.Border, false)
                for _, option in ipairs(el.OptionList) do
                    self:_SetVisibility(option.Text, false)
                    self:_SetVisibility(option.Highlight, false)
                    if el.type == "Multidropdown" then
                        self:_SetVisibility(option.CheckmarkLine1, false)
                        self:_SetVisibility(option.CheckmarkLine2, false)
                    end
                end
            end
        end
    end

    local sectionHeight = elementY_offset - ((separatorY_abs - animatedY) + 15) + 45
    if #section.Elements > 0 then local lastElement = section.Elements[#section.Elements]; if lastElement.type == "Dropdown" or lastElement.type == "Multidropdown" or lastElement.type == "Keybind" then sectionHeight = sectionHeight + 13 end end
    sDrawing.Background.Size = {columnWidth, sectionHeight}; sDrawing.Border.Size = {columnWidth, sectionHeight}
    return sectionHeight
end

function Library:_RenderSections(panelX, panelY, headerHeight)
    local leftColumnY, rightColumnY = panelY + headerHeight + 20, panelY + headerHeight + 20
    local columnSpacing = 20
    local columnWidth = ((self.Window.Width - self.Window.SidebarWidth + self.Window.PanelOverlap) - (columnSpacing * 3)) / 2
    local leftColumnX, rightColumnX = panelX + columnSpacing, panelX + columnSpacing + columnWidth + columnSpacing
    
    -- === Главный цикл рендера секций ===
    for _, section in ipairs(self.UI.Sections) do
        -- Получаем заранее рассчитанное состояние анимации 
        local anim_state = self.AnimationState[section.Drawing.Background]
        if not anim_state then
            anim_state = { Opacity = 0, YOffset = 0, IsVisible = false }
            self.AnimationState[section.Drawing.Background] = anim_state
        end

        local is_on_active_tab = (section.ParentTab == self.Window.ActiveTab)
        local is_on_old_tab = (self.Window.Animation.State == "FADING_OUT" and section.ParentTab == self.Window.Animation.OldTab)

        -- Если секция должна быть видимой (на текущей или исчезающей вкладке) 
        if (is_on_active_tab and self.Window.Animation.State ~= "FADING_OUT") or is_on_old_tab then
             if not anim_state.IsVisible then self:_SetSectionAndElementsVisibility(section, true); anim_state.IsVisible = true; end

            local sectionX, sectionY
            if section.Side == "Left" then sectionX, sectionY = leftColumnX, leftColumnY
            else sectionX, sectionY = rightColumnX, rightColumnY end
            
            -- Отрисовываем секцию с текущими параметрами анимации 
            local sectionHeight = self:_RenderSingleSection(section, sectionX, sectionY, columnWidth, anim_state.YOffset, anim_state.Opacity)
            
            -- Запоминаем последнюю позицию для плавного исчезновения 
            section.LastPos = { X = sectionX, Y = sectionY } 

            if section.Side == "Left" then leftColumnY = leftColumnY + sectionHeight + columnSpacing
            else rightColumnY = rightColumnY + sectionHeight + columnSpacing end
        
        -- Если секция не должна быть видна, скрываем её 
        elseif anim_state.IsVisible then
            self:_SetSectionAndElementsVisibility(section, false)
            anim_state.IsVisible = false
        end
    end
end

function Library:_RenderConfigsTab(panelX, panelY, headerHeight)
    local configs = self.UI.Core.ConfigsTab
    local theme = self.ActiveTheme

    self:_SetVisibility(configs.MyItemsLabel, true)
    self:_SetVisibility(configs.Scrollbar.Background, true)
    self:_SetVisibility(configs.Scrollbar.Nub, true)
    self:_AnimateAndApplyColor(configs.MyItemsLabel, theme.Colors.TextPrimary)
    self:_AnimateAndApplyColor(configs.Scrollbar.Background, theme.Colors.DarkBlue)
    self:_AnimateAndApplyColor(configs.Scrollbar.Nub, theme.Colors.Accent)

    for _, item in ipairs(configs.Items) do
        local d = item.Drawing
        self:_SetVisibility(d.Background, true); self:_SetVisibility(d.Border, true); self:_SetVisibility(d.Name, true); self:_SetVisibility(d.Modified, true); self:_SetVisibility(d.Author, true); self:_SetVisibility(d.OptionsButton.Dot1, true); self:_SetVisibility(d.OptionsButton.Dot2, true); self:_SetVisibility(d.OptionsButton.Dot3, true)
        
        self:_AnimateAndApplyColor(d.Background, theme.Colors.SectionBackground)
        self:_AnimateAndApplyColor(d.Border, theme.Colors.Separator)
        self:_AnimateAndApplyColor(d.Name, theme.Colors.TextPrimary)
        self:_AnimateAndApplyColor(d.Modified, theme.Colors.TextSecondary)
        self:_AnimateAndApplyColor(d.Author, theme.Colors.TextSecondary)
        self:_AnimateAndApplyColor(d.OptionsButton.Dot1, theme.Colors.TextSecondary)
        self:_AnimateAndApplyColor(d.OptionsButton.Dot2, theme.Colors.TextSecondary)
        self:_AnimateAndApplyColor(d.OptionsButton.Dot3, theme.Colors.TextSecondary)
    end

    local startX = panelX + 20
    local startY = panelY + headerHeight + 20
    local contentWidth = (self.Window.Width - self.Window.SidebarWidth + self.Window.PanelOverlap) - 40
    local scrollbarWidth = 6
    local contentAreaWidth = contentWidth - scrollbarWidth - 10
    configs.MyItemsLabel.Position = {startX, startY}
    local currentY = startY + 25
    local itemHeight = 60
    local itemSpacing = 10

    for i, item in ipairs(configs.Items) do
        local d = item.Drawing
        d.Background.Position = {startX, currentY}; d.Background.Size = {contentAreaWidth, itemHeight}
        d.Border.Position = {startX, currentY}; d.Border.Size = {contentAreaWidth, itemHeight}
        d.Name.Text = item.Name; d.Name.Position = {startX + 15, currentY + 12}
        d.Modified.Text = "Modified: " .. item.Modified; d.Modified.Position = {startX + 15, currentY + 35}
        if d.Modified.TextBounds and d.Modified.TextBounds.x then
            d.Author.Text = "Author: " .. item.Author
            d.Author.Position = {startX + 15 + d.Modified.TextBounds.x + 10, currentY + 35}
        end
        local btnWidth, btnHeight = 85, 28
        local btnX = startX + contentAreaWidth - btnWidth - 15
        local btnY = currentY + (itemHeight / 2) - (btnHeight / 2)
        local optionsBtnX = btnX - 25; local optionsBtnY = currentY + (itemHeight / 2)
        d.OptionsButton.Dot1.Position = {optionsBtnX - 6, optionsBtnY}; d.OptionsButton.Dot2.Position = {optionsBtnX, optionsBtnY}; d.OptionsButton.Dot3.Position = {optionsBtnX + 6, optionsBtnY}
        d.OptionsButton.ClickRegion = {x1 = optionsBtnX - 10, y1 = optionsBtnY - 10, x2 = optionsBtnX + 10, y2 = optionsBtnY + 10}
        local isLoaded = (configs.LoadedConfigName == item.Name)
        self:_SetVisibility(d.SaveButton.Background, isLoaded); self:_SetVisibility(d.SaveButton.Border, isLoaded); self:_SetVisibility(d.SaveButton.Icon, isLoaded); self:_SetVisibility(d.SaveButton.Label, isLoaded)
        self:_SetVisibility(d.LoadButton.Background, not isLoaded); self:_SetVisibility(d.LoadButton.Icon, not isLoaded); self:_SetVisibility(d.LoadButton.Label, not isLoaded)
        
        if isLoaded then
            local saveBtn = d.SaveButton
            self:_AnimateAndApplyColor(saveBtn.Background, theme.Colors.SectionBackground)
            self:_AnimateAndApplyColor(saveBtn.Border, theme.Colors.Accent)
            self:_AnimateAndApplyColor(saveBtn.Icon, theme.Colors.TextPrimary)
            self:_AnimateAndApplyColor(saveBtn.Label, theme.Colors.TextPrimary)
            saveBtn.Background.Position = {btnX, btnY}; saveBtn.Background.Size = {btnWidth, btnHeight}
            saveBtn.Border.Position = {btnX, btnY}; saveBtn.Border.Size = {btnWidth, btnHeight}
            local iconX = btnX + 15
            saveBtn.Icon.Position = {iconX, btnY + (btnHeight / 2) - (saveBtn.Icon.Size.y / 2)}
            saveBtn.Label.Position = {iconX + saveBtn.Icon.Size.x + 8, btnY + (btnHeight / 2) - (saveBtn.Label.Size / 2)}
            saveBtn.ClickRegion = {x1 = btnX, y1 = btnY, x2 = btnX + btnWidth, y2 = btnY + btnHeight}
        else
            local loadBtn = d.LoadButton
            local accentColor = theme.Colors.Accent
            local textColorForAccent = self:_GetTextColorForBackground(accentColor)
            
            self:_AnimateAndApplyColor(loadBtn.Background, accentColor)
            self:_AnimateAndApplyColor(loadBtn.Icon, textColorForAccent)
            self:_AnimateAndApplyColor(loadBtn.Label, textColorForAccent)

            loadBtn.Background.Position = {btnX, btnY}; loadBtn.Background.Size = {btnWidth, btnHeight}
            local iconX = btnX + 15
            loadBtn.Icon.Position = {iconX, btnY + (btnHeight / 2) - (loadBtn.Icon.Size.y / 2)}
            loadBtn.Label.Position = {iconX + loadBtn.Icon.Size.x + 8, btnY + (btnHeight / 2) - (loadBtn.Label.Size / 2)}
            loadBtn.ClickRegion = {x1 = btnX, y1 = btnY, x2 = btnX + btnWidth, y2 = btnY + btnHeight}
        end
        currentY = currentY + itemHeight + itemSpacing
    end
    local scrollbarX = startX + contentAreaWidth + 5
    local scrollbarHeight = self.Window.Height - headerHeight - 40
    configs.Scrollbar.Background.Position = {scrollbarX, startY}
    configs.Scrollbar.Background.Size = {scrollbarWidth, scrollbarHeight}
    local nubHeight = 80
    configs.Scrollbar.Nub.Position = {scrollbarX, startY}
    configs.Scrollbar.Nub.Size = {scrollbarWidth, nubHeight}
end

function Library:_RenderConfigOptionsPopup()
    local configs = self.UI.Core.ConfigsTab
    local popup = configs.OptionsPopup
    local isVisible = popup.IsOpen
    local theme = self.ActiveTheme

    self:_SetVisibility(popup.Background, isVisible)
    self:_SetVisibility(popup.Border, isVisible)
    self:_SetVisibility(popup.IncludeStyleToggle.Label, isVisible)
    self:_SetVisibility(popup.IncludeStyleToggle.Back, isVisible)
    self:_SetVisibility(popup.IncludeStyleToggle.Nub, isVisible)

    if not isVisible then
        if popup.Glow then self:_HideGlowEffect(popup.Glow) end
        return
    end

    self:_AnimateAndApplyColor(popup.Background, theme.Colors.SectionBackground)
    self:_AnimateAndApplyColor(popup.Border, theme.Colors.Separator)
    self:_AnimateAndApplyColor(popup.IncludeStyleToggle.Label, theme.Colors.TextSecondary)
    
    local pW, pH = 150, 50
    local pX, pY = popup.Pos.x, popup.Pos.y
    popup.ClickRegion = {x1=pX, y1=pY, x2=pX+pW, y2=pY+pH}
    popup.Background.Position = {pX, pY}; popup.Background.Size = {pW, pH}
    popup.Border.Position = {pX, pY}; popup.Border.Size = {pW, pH}
    if popup.Glow then self:_RenderGlowEffect(popup.Glow, pX, pY, pW, pH, popup.Background.Rounding, theme.Colors.GlowColor) end

    local toggle = popup.IncludeStyleToggle
    local toggleY = pY + (pH / 2) - (toggle.Label.Size / 2)
    toggle.Label.Position = {pX + 10, toggleY}
    local toggleBackX = pX + pW - toggle.Size.width - 15
    toggle.Back.Position = {toggleBackX, toggleY + 2}; toggle.Back.Size = {toggle.Size.width, toggle.Size.height}; toggle.ClickRegion = {x1 = toggleBackX, y1 = toggleY, x2 = toggleBackX + toggle.Size.width, y2 = toggleY + toggle.Size.height + 4}
    
    local targetBackColor, targetNubColor
    if self.UI.Values[toggle.id] then
        targetBackColor = theme.Colors.ToggleEnabledBackground or self:_DarkenColor(theme.Colors.Accent, 0.3)
        targetNubColor = theme.Colors.Accent
        toggle.Nub.Position = {toggleBackX + toggle.Size.width - 5, toggleY + 2 + toggle.Size.height/2}
    else
        targetBackColor = theme.Colors.DarkGray
        targetNubColor = theme.Colors.LightGray
        toggle.Nub.Position = {toggleBackX + 5, toggleY + 2 + toggle.Size.height/2}
    end
    self:_AnimateAndApplyColor(toggle.Back, targetBackColor)
    self:_AnimateAndApplyColor(toggle.Nub, targetNubColor)
end

function Library:_InputLoop()
    self:_CheckGlobalBinds()

    if not self.Window.Visible then return end -- << БЛОКИРУЕМ КЛИКИ, ЕСЛИ UI СКРЫТ

    local mouse_pos = getmouseposition()
    if not mouse_pos then return end

    local mouse_x, mouse_y = self:_SafeNumber(mouse_pos.x, 0), self:_SafeNumber(mouse_pos.y, 0)
    local is_left_pressed_now = isleftpressed()
    local is_left_clicked = was_left_pressed and not is_left_pressed_now

    local picker = self.UI.Popups.ColorPicker
    local style_window = self.UI.Popups.EditStyle
    local configsTab = self.UI.Core.ConfigsTab
    local about_window = self.UI.Core.AboutWindow
    local settings_popup = self.UI.Popups.Settings

    -- Обработка наведения мыши на опции в открытых Dropdown'ах
    local anyDropdownOpen = false
    for _, section in ipairs(self.UI.Sections) do
        if section.ParentTab == self.Window.ActiveTab then
            for _, el in ipairs(section.Elements) do
                if (el.type == "Dropdown" or el.type == "Multidropdown") and el.IsOpen then
                    anyDropdownOpen = true
                    local hoveredFound = false
                    for i, option in ipairs(el.OptionList) do
                        if self:_IsPointInRegion(mouse_x, mouse_y, option.ClickRegion) then
                            el.HoveredOptionIndex = i
                            hoveredFound = true
                            break
                        end
                    end
                    if not hoveredFound then el.HoveredOptionIndex = 0 end
                end
            end
        end
    end

    -- [НАЧАЛО ЛОГИКИ ПЕРЕТАСКИВАНИЯ]
    if is_left_pressed_now then
        if not is_dragging_something then
            is_dragging_something = true
            local about_slider = about_window.AnimationSpeedSlider
            if self.UI.Popups.About.IsOpen and self:_IsPointInRegion(mouse_x, mouse_y, about_slider.ClickRegion) then
                about_slider.IsDragging = true
            elseif picker.IsOpen and self:_IsPointInRegion(mouse_x, mouse_y, picker.HueSliderRegion) then
                picker.isDraggingHue = true
            elseif picker.IsOpen and self:_IsPointInRegion(mouse_x, mouse_y, picker.OpacitySliderRegion) then
                picker.isDraggingOpacity = true
            elseif picker.IsOpen and self:_IsPointInRegion(mouse_x, mouse_y, picker.SaturationValueRegion) then
                picker.isDraggingSaturationValue = true
            elseif not self.UI.Popups.About.IsOpen and not settings_popup.IsOpen and not self.UI.Popups.EditStyle.IsOpen and not self.UI.Popups.ColorPicker.IsOpen and not configsTab.OptionsPopup.IsOpen and not anyDropdownOpen then
                 local started_slider_drag = false
                 if self.Window.ActiveTab ~= "Configs" then
                    for _, section in ipairs(self.UI.Sections) do
                        if section.ParentTab == self.Window.ActiveTab then
                            for _, el in ipairs(section.Elements) do
                                if el.type == "Slider" and self:_IsPointInRegion(mouse_x, mouse_y, el.ClickRegion) then
                                    el.IsDragging = true; started_slider_drag = true; break
                                end
                            end
                        end
                        if started_slider_drag then break end
                    end
                 end
                 if not started_slider_drag then
                    local header_drag_region = {x1 = self.Window.X, y1 = self.Window.Y, x2 = self.Window.X + self.Window.Width, y2 = self.Window.Y + self.Window.HeaderHeight}
                    local on_header_button = self:_IsPointInRegion(mouse_x, mouse_y, self.UI.Core.HeaderButtons.Save.ClickRegion) or self:_IsPointInRegion(mouse_x, mouse_y, self.UI.Core.HeaderButtons.ViewESP.ClickRegion) or self:_IsPointInRegion(mouse_x, mouse_y, self.UI.Core.HeaderButtons.CreateNew.ClickRegion) or self:_IsPointInRegion(mouse_x, mouse_y, self.UI.Core.HeaderButtons.Settings.ClickRegion)
                    if self:_IsPointInRegion(mouse_x, mouse_y, header_drag_region) and not on_header_button then
                        self.Window.IsDragging = true; drag_offset = {x = mouse_x - self.Window.X, y = mouse_y - self.Window.Y}
                    else
                        is_dragging_something = false
                    end
                 end
            else
                is_dragging_something = false
            end
        end
    else
        if self.Window.IsDragging then self.Window.IsDragging = false end
        for _, section in ipairs(self.UI.Sections) do for _, el in ipairs(section.Elements) do if el.IsDragging then el.IsDragging = false end end end
        if about_window.AnimationSpeedSlider.IsDragging then about_window.AnimationSpeedSlider.IsDragging = false end
        if picker.isDraggingHue then picker.isDraggingHue = false end
        if picker.isDraggingOpacity then picker.isDraggingOpacity = false end
        if picker.isDraggingSaturationValue then picker.isDraggingSaturationValue = false end
        is_dragging_something = false
    end

    if self.Window.IsDragging then self.Window.X = mouse_x - drag_offset.x; self.Window.Y = mouse_y - drag_offset.y; end
    for _, section in ipairs(self.UI.Sections) do
        for _, el in ipairs(section.Elements) do
            if el.type == "Slider" and el.IsDragging then
                local sliderBackX, sliderBackWidth = self:_SafeNumber(el.Back.Position.x, 0), self:_SafeNumber(el.Back.Size.x, 1)
                local mouse_relative_x = math.clamp(mouse_x - sliderBackX, 0, sliderBackWidth)
                local percentage = sliderBackWidth > 0 and (mouse_relative_x / sliderBackWidth) or 0
                local raw_value = el.Min + (el.Max - el.Min) * percentage
                local stepped_value = math.floor(raw_value / el.Increment + 0.5) * el.Increment
                local clamped_value = math.clamp(stepped_value, el.Min, el.Max)
                if clamped_value ~= self.UI.Values[el.id] then self.UI.Values[el.id] = clamped_value; if el.Callback then el.Callback(self.UI.Values[el.id]); end end
            end
        end
    end
    local about_slider = about_window.AnimationSpeedSlider
    if about_slider.IsDragging then
        local sliderBackX, sliderBackWidth = self:_SafeNumber(about_slider.Back.Position.x, 0), self:_SafeNumber(about_slider.Back.Size.x, 1)
        local mouse_relative_x = math.clamp(mouse_x - sliderBackX, 0, sliderBackWidth)
        local percentage = sliderBackWidth > 0 and (mouse_relative_x / sliderBackWidth) or 0
        local raw_value = about_slider.Min + (about_slider.Max - about_slider.Min) * percentage
        local stepped_value = math.floor(raw_value / about_slider.Increment + 0.5) * about_slider.Increment
        local clamped_value = math.clamp(stepped_value, about_slider.Min, about_slider.Max)
        if clamped_value ~= self.UI.Values[about_slider.id] then self.UI.Values[about_slider.id] = clamped_value; end
    end

    local function update_color_picker()
        local new_rgb = self:_HSVtoRGB(picker.h, picker.s, picker.v)
        local new_color = {new_rgb[1], new_rgb[2], new_rgb[3], picker.a * 255}
        if picker.EditingValueID then
            self.UI.Values[picker.EditingValueID] = new_color
        elseif picker.EditingColorName then
            style_window.EditingTheme.Colors[picker.EditingColorName] = new_color
            if self.UI.Values.EditStyleRealTime and self.TempTheme then
                 self.TempTheme.Colors[picker.EditingColorName] = new_color
            end
        end
    end

    if picker.isDraggingHue then
        local region = picker.HueSliderRegion; local percentage = math.clamp((mouse_x - region.x1) / (region.x2 - region.x1), 0, 1); picker.h = percentage; update_color_picker()
    end
    if picker.isDraggingOpacity then
        local region = picker.OpacitySliderRegion; local percentage = math.clamp((mouse_x - region.x1) / (region.x2 - region.x1), 0, 1); picker.a = percentage; update_color_picker()
    end
    if picker.isDraggingSaturationValue then
        local region = picker.SaturationValueRegion; picker.s = math.clamp((mouse_x - region.x1) / (region.x2 - region.x1), 0, 1); picker.v = 1 - math.clamp((mouse_y - region.y1) / (region.y2 - region.y1), 0, 1); update_color_picker()
    end

    if about_window and self.UI.Popups.About.IsOpen then
        local is_hovering_any_circle = false
        for _, circle in ipairs(about_window.StyleCircles) do
            if self:_IsPointInRegion(mouse_x, mouse_y, circle.ClickRegion) then
                is_hovering_any_circle = true
                if about_window.HoveredThemeCircle.Name ~= circle.Name then
                    about_window.HoveredThemeCircle.Name = circle.Name
                    about_window.HoveredThemeCircle.HoverStartTime = tick()
                end
                break
            end
        end
        if not is_hovering_any_circle then about_window.HoveredThemeCircle.Name = nil end
    end
    -- [КОНЕЦ ЛОГИКИ ПЕРЕТАСКИВАНИЯ]

    if is_left_clicked and not is_dragging_something then
        local click_was_handled = false

        -- Приоритетная проверка: клик в открытом dropdown
        if anyDropdownOpen then
            local clickedInsideADropdown = false
            for _, section in ipairs(self.UI.Sections) do
                for _, el in ipairs(section.Elements) do
                    if (el.type == "Dropdown" or el.type == "Multidropdown") and el.IsOpen and el.HoveredOptionIndex > 0 then
                        clickedInsideADropdown = true
                        click_was_handled = true
                        local i = el.HoveredOptionIndex
                        if el.type == "Dropdown" then
                            self.UI.Values[el.id] = el.Options[i]
                            if el.Callback then el.Callback(self.UI.Values[el.id]) end
                            el.IsOpen = false
                            el.IsClosing = true
                        else -- Multidropdown
                            local opt = el.Options[i]
                            local found_idx = table.find(self.UI.Values[el.id], opt)
                            if found_idx then table.remove(self.UI.Values[el.id], found_idx)
                            else table.insert(self.UI.Values[el.id], opt) end
                            if el.Callback then el.Callback(self.UI.Values[el.id]) end
                        end
                        break
                    end
                end
                if click_was_handled then break end
            end

            if not clickedInsideADropdown then
                for _, section in ipairs(self.UI.Sections) do
                    for _, el in ipairs(section.Elements) do
                        if (el.type == "Dropdown" or el.type == "Multidropdown") and el.IsOpen then
                            el.IsOpen = false
                            el.IsClosing = true
                        end
                    end
                end
            end
        end

        -- Обработка кликов по окнам-попапам
        if not click_was_handled then
            if settings_popup.IsOpen then
                click_was_handled = true
                if self:_IsPointInRegion(mouse_x, mouse_y, settings_popup.ClickRegion) then
                    for _, element in ipairs(settings_popup.ActiveToggle.SettingsElements or {}) do
                        if element.type == "Keybind" and self:_IsPointInRegion(mouse_x, mouse_y, element.ClickRegion) then
                            element.IsListening = not element.IsListening; break
                        end
                    end
                else
                    self:_HideSettingsPopupElements(settings_popup)
                    settings_popup.IsOpen = false;
                    settings_popup.ActiveToggle = nil;
                end
            elseif configsTab.OptionsPopup.IsOpen then
                click_was_handled = true
                local popup = configsTab.OptionsPopup
                if self:_IsPointInRegion(mouse_x, mouse_y, popup.IncludeStyleToggle.ClickRegion) then
                    self.UI.Values[popup.IncludeStyleToggle.id] = not self.UI.Values[popup.IncludeStyleToggle.id]
                elseif not self:_IsPointInRegion(mouse_x, mouse_y, popup.ClickRegion) then
                    popup.IsOpen = false
                end
            elseif picker.IsOpen then
                click_was_handled = true
                local picker_region = {x1=picker.Background.Position.x, y1=picker.Background.Position.y, x2=picker.Background.Position.x+picker.Background.Size.x, y2=picker.Background.Position.y+picker.Background.Size.y}
                if not self:_IsPointInRegion(mouse_x, mouse_y, picker_region) then
                    picker.IsOpen = false
                end
            elseif style_window.IsOpen then
                click_was_handled = true
                if self:_IsPointInRegion(mouse_x, mouse_y, style_window.CloseButton.ClickRegion) or self:_IsPointInRegion(mouse_x, mouse_y, style_window.CancelButton.ClickRegion) then
                    self:_revert_realtime_changes()
                    style_window.IsOpen = false; style_window.IsEditingName = false
                elseif self:_IsPointInRegion(mouse_x, mouse_y, style_window.SaveButton.ClickRegion) then
                    local newTheme = self:_DeepCopy(style_window.EditingTheme)
                    local newName = style_window.StyleNameInputText.Text; local originalName = style_window.EditingThemeName
                    if newName == "" then newName = "Custom" end
                    if newName ~= originalName and self.Themes[originalName] and not self.Themes[originalName].IsPreset then self.Themes[originalName] = nil end
                    if self.Themes[newName] and newName ~= originalName then local i = 1; while self.Themes[newName .. " (" .. i .. ")"] do i = i + 1 end; newName = newName .. " (" .. i .. ")" end
                    newTheme.Name = newName; newTheme.IsPreset = false; self.Themes[newName] = newTheme
                    self:_RebuildStyleCircles(); self.UI.Values.AboutSelectedStyle = newTheme.Name; self.ActiveTheme = newTheme
                    self.TempTheme = nil; self.PreEditThemeName = nil; self.UI.Values.EditStyleRealTime = false
                    style_window.IsOpen = false; style_window.IsEditingName = false
                elseif self:_IsPointInRegion(mouse_x, mouse_y, style_window.RealTimeToggle.ClickRegion) then
                    self.UI.Values.EditStyleRealTime = not self.UI.Values.EditStyleRealTime
                    if self.UI.Values.EditStyleRealTime then
                        self.PreEditThemeName = self.ActiveTheme.Name; self.TempTheme = self:_DeepCopy(style_window.EditingTheme); self.ActiveTheme = self.TempTheme
                    else
                        self.ActiveTheme = self.Themes[self.PreEditThemeName] or self.Themes.Blue
                        self.UI.Values.AboutSelectedStyle = self.ActiveTheme.Name; self.TempTheme = nil; self.PreEditThemeName = nil
                    end
                elseif self:_IsPointInRegion(mouse_x, mouse_y, style_window.StyleNameInputClickRegion) then
                    style_window.IsEditingName = true
                else
                    local clicked_color = false
                    for _, item in ipairs(style_window.ColorItems) do
                        if self:_IsPointInRegion(mouse_x, mouse_y, item.ClickRegion) then
                            picker.IsOpen = true;
                            picker.EditingColorName = item.Name;
                            picker.EditingValueID = nil;
                            picker.Pos = {x = mouse_x, y = mouse_y}
                            local color_to_edit = style_window.EditingTheme.Colors[item.Name]
                            picker.h, picker.s, picker.v, picker.a = self:_RGBtoHSV(color_to_edit[1], color_to_edit[2], color_to_edit[3], color_to_edit[4])
                            clicked_color = true; break
                        end
                    end
                    if not clicked_color then style_window.IsEditingName = false end
                end
            elseif self.UI.Popups.About.IsOpen then
                click_was_handled = true
                local about = self.UI.Core.AboutWindow

                if self:_IsPointInRegion(mouse_x, mouse_y, about.CloseButton.ClickRegion) then
                    self.UI.Popups.About.IsOpen = false
                elseif self:_IsPointInRegion(mouse_x, mouse_y, about.AutoSaveToggle.ClickRegion) then
                    self.UI.Values.AboutAutoSave = not self.UI.Values.AboutAutoSave
                elseif self:_IsPointInRegion(mouse_x, mouse_y, about.ToggleUIKeybind.ClickRegion) then
                    about.ToggleUIKeybind.IsListening = not about.ToggleUIKeybind.IsListening
                else
                    local circle_clicked = false
                    for _, circle in ipairs(about.StyleCircles) do
                        if self:_IsPointInRegion(mouse_x, mouse_y, circle.ClickRegion) then
                            circle_clicked = true
                            if circle.IsAddButton then
                                self.CustomThemeCounter = self.CustomThemeCounter + 1; local newName = "Custom " .. self.CustomThemeCounter
                                style_window.EditingTheme = self:_DeepCopy(self.ActiveTheme); style_window.EditingThemeName = newName
                                style_window.StyleNameInputText.Text = newName; style_window.IsOpen = true
                            else
                                self.UI.Values.AboutSelectedStyle = circle.Name; self.ActiveTheme = self.Themes[circle.Name]
                            end; break
                        end
                    end
                    if not circle_clicked and not self:_IsPointInRegion(mouse_x, mouse_y, about.ClickRegion) then
                        self.UI.Popups.About.IsOpen = false
                    end
                end
            else
                -- Обработка кликов по основным элементам UI
                if not click_was_handled and self.Window.ActiveTab ~= "Configs" then
                    for _, section in ipairs(self.UI.Sections) do
                        if section.ParentTab == self.Window.ActiveTab then
                            for _, el in ipairs(section.Elements) do
                                if el.type == "Toggle" and el.HasColor and self:_IsPointInRegion(mouse_x, mouse_y, el.ColorClickRegion) then
                                    picker.IsOpen = true
                                    picker.EditingValueID = el.HasColor.id
                                    picker.EditingColorName = nil
                                    picker.Pos = {x = mouse_x, y = mouse_y}
                                    local color_to_edit = self.UI.Values[el.HasColor.id]
                                    picker.h, picker.s, picker.v, picker.a = self:_RGBtoHSV(color_to_edit[1], color_to_edit[2], color_to_edit[3], color_to_edit[4])
                                    click_was_handled = true; break
                                elseif el.HasSettings and self:_IsPointInRegion(mouse_x, mouse_y, el.SettingsClickRegion) then
                                    settings_popup.IsOpen = true; settings_popup.ActiveToggle = el; settings_popup.Pos = {x = mouse_x, y = mouse_y}; click_was_handled = true; break
                                elseif self:_IsPointInRegion(mouse_x, mouse_y, el.ClickRegion) then
                                    if el.type == "Toggle" then
                                        self.UI.Values[el.id] = not self.UI.Values[el.id]
                                        if el.Callback then el.Callback(self.UI.Values[el.id]) end
                                    elseif el.type == "Dropdown" or el.type == "Multidropdown" then
                                        local openingThisOne = not el.IsOpen
                                        for _, s_inner in ipairs(self.UI.Sections) do for _, el_inner in ipairs(s_inner.Elements) do if (el_inner.type == "Dropdown" or el_inner.type == "Multidropdown") and el_inner.IsOpen then el_inner.IsOpen = false; el_inner.IsClosing = true end end end
                                        if openingThisOne then
                                            el.IsOpen = true
                                            el.IsClosing = false
                                            el.FadeOpacity = 0.0
                                        end
                                    end
                                    click_was_handled = true; break
                                end
                            end
                        end; if click_was_handled then break end
                    end
                end
                if not click_was_handled then
                    if self.Window.ActiveTab == "Configs" then
                        for i, item in ipairs(configsTab.Items) do
                            local d = item.Drawing
                            if configsTab.LoadedConfigName == item.Name and self:_IsPointInRegion(mouse_x, mouse_y, d.SaveButton.ClickRegion) then
                                self:_SaveConfig(item.Name); click_was_handled = true; break
                            elseif configsTab.LoadedConfigName ~= item.Name and self:_IsPointInRegion(mouse_x, mouse_y, d.LoadButton.ClickRegion) then
                                self:_LoadConfig(item.Name); click_was_handled = true; break
                            elseif self:_IsPointInRegion(mouse_x, mouse_y, d.OptionsButton.ClickRegion) then
                                local popup = configsTab.OptionsPopup; popup.IsOpen = not popup.IsOpen; popup.ItemIndex = i; popup.Pos = {x = mouse_x - 155, y = mouse_y}; click_was_handled = true; break
                            end
                        end
                    end
                end
                if not click_was_handled then
                    local create_btn_region = self.UI.Core.HeaderButtons.CreateNew.ClickRegion
                    local save_btn_region = self.UI.Core.HeaderButtons.Save.ClickRegion
                    local view_esp_region = self.UI.Core.HeaderButtons.ViewESP.ClickRegion
                    local settings_region = self.UI.Core.HeaderButtons.Settings.ClickRegion
                    if self:_IsPointInRegion(mouse_x, mouse_y, create_btn_region) and self.Window.ActiveTab == "Configs" then
                        click_was_handled = true; self.UI.Core.HeaderButtons.CreateNew.ClickTime = tick(); self:_CreateNewConfig()
                    elseif self:_IsPointInRegion(mouse_x, mouse_y, save_btn_region) then
                        click_was_handled = true; self.UI.Core.HeaderButtons.Save.ClickTime = tick(); if configsTab.LoadedConfigName ~= "" then self:_SaveConfig(configsTab.LoadedConfigName) end
                    elseif self:_IsPointInRegion(mouse_x, mouse_y, view_esp_region) then
                        click_was_handled = true; self.UI.Core.HeaderButtons.ViewESP.IsOpen = not self.UI.Core.HeaderButtons.ViewESP.IsOpen; self.UI.Core.HeaderButtons.ViewESP.ClickTime = tick();
                    elseif self:_IsPointInRegion(mouse_x, mouse_y, settings_region) then
                        click_was_handled = true; self.UI.Popups.About.IsOpen = not self.UI.Popups.About.IsOpen;
                    else
                        for _, group in ipairs(self.UI.TabGroups) do for _, tab in ipairs(group.Tabs) do if self:_IsPointInRegion(mouse_x, mouse_y, tab.ClickRegion) then self.Window.ActiveTab = tab.Name; click_was_handled = true; break; end end if click_was_handled then break; end end
                    end
                end
            end
        end
    end

    -- Обработка нажатий клавиш для активных биндов
    do
        local key = getpressedkey()
        if key and key ~= "None" then
            -- Для бинда в окне "About"
            if about_window.ToggleUIKeybind and about_window.ToggleUIKeybind.IsListening then
                if self.UI.Values[about_window.ToggleUIKeybind.id] ~= key then
                    self.UI.Values[about_window.ToggleUIKeybind.id] = key
                end
                about_window.ToggleUIKeybind.IsListening = false
            -- Для биндов в настройках Toggle
            elseif settings_popup.IsOpen and settings_popup.ActiveToggle then
                for _, element in ipairs(settings_popup.ActiveToggle.SettingsElements or {}) do
                    if element.type == "Keybind" and element.IsListening then
                        if self.UI.Values[element.id] ~= key then self.UI.Values[element.id] = key; end
                        element.IsListening = false; break
                    end
                end
            end
        end
    end

    -- Для ввода имени стиля
    if style_window.IsEditingName then
        local key = getpressedkey()
        if key and key ~= "None" and key ~= style_window.last_key_pressed and (tick() - style_window.last_key_press_time > style_window.key_press_delay) then
            local current_text = style_window.StyleNameInputText.Text
            if key == "Backspace" then if #current_text > 0 then style_window.StyleNameInputText.Text = string.sub(current_text, 1, -2) end
            elseif key == "Space" then if #current_text < 20 then style_window.StyleNameInputText.Text = current_text .. " " end
            elseif string.len(key) == 1 and string.match(key, "%w") then if #current_text < 20 then style_window.StyleNameInputText.Text = current_text .. key end
            end
            style_window.last_key_press_time = tick(); style_window.last_key_pressed = key
        elseif key == "None" then style_window.last_key_pressed = "None" end
    end

    -- Проверка биндов для функций (например, для Toggle)
    local currentTime = tick()
    if currentTime - (lastBindCheckTime or 0) > 0.1 then
        local pressed_key = getpressedkey()
        if pressed_key and pressed_key ~= "None" then
            local bind_triggered = false
            for id, value in pairs(self.UI.Values) do
                if type(value) == "string" and string.sub(id, -4) == "Bind" and value == pressed_key and id ~= "ToggleUIBind" then
                    for _, s in ipairs(self.UI.Sections) do
                        for _, el in ipairs(s.Elements) do
                            if el.SettingsElements then
                                for _, setting_el in ipairs(el.SettingsElements) do
                                    if setting_el.id == id and setting_el.Callback then
                                        pcall(setting_el.Callback)
                                        lastBindCheckTime = currentTime
                                        bind_triggered = true
                                        break
                                    end
                                end
                            end
                            if bind_triggered then break end
                        end
                        if bind_triggered then break end
                    end
                end
                if bind_triggered then break end
            end
        end
    end
    was_left_pressed = is_left_pressed_now
end



function Library:_AddPresetsTab()
    local tabGroupName = "PRESETS"
    local tabName = "Configs"

    for _, group in ipairs(self.UI.TabGroups) do
        if group.Name == tabGroupName then return end
    end

    local group = { Name = tabGroupName, Header = self:_CreateDrawingObject("Text"), Tabs = {} }
    if group.Header then
        group.Header.Font = self.ActiveTheme.Fonts.Main; group.Header.Size = self.ActiveTheme.Fonts.TabHeaderSize; group.Header.Text = group.Name; group.Header.Center = false; group.Header.Outline = false; group.Header.zIndex = 3;
    end

    local tab = {
        Name = tabName,
        Text = self:_CreateDrawingObject("Text"),
        Icon = self:_CreateDrawingObject("Image"),
        ClickRegion = {},
        Highlight = self:_CreateDrawingObject("Square") -- Добавляем недостающий объект
    }
    -- И настраиваем его
    if tab.Highlight then
        tab.Highlight.Filled = true
        tab.Highlight.zIndex = 2
        tab.Highlight.Rounding = self.ActiveTheme.Rounding.Element + 3
        tab.Highlight.Visible = true
    end
    
    if tab.Text then
        tab.Text.Font = self.ActiveTheme.Fonts.Main; tab.Text.Size = self.ActiveTheme.Fonts.TabSize; tab.Text.Text = tabName; tab.Text.Center = false; tab.Text.Outline = false; tab.Text.zIndex = 3; end
    if tab.Icon then
        tab.Icon.Url = "https://s6.imgcdn.dev/Y4Skk8.png" -- Gear icon
        tab.Icon.Size = {self.ActiveTheme.IconSize, self.ActiveTheme.IconSize}; tab.Icon.zIndex = 3;
    end

    table.insert(group.Tabs, tab)
    table.insert(self.UI.TabGroups, group)
end


function Library:_MainLoop()
    print(SCRIPT_PREFIX .. "UI Initialized and Main Loop started. 3541")
    local is_first_frame = true
    while true do -- Цикл теперь работает всегда, чтобы ловить бинды
        self:_InputLoop() -- Проверка ввода выполняется всегда

        if self.Window.Visible then -- А отрисовка - только когда окно видимо
            if is_first_frame then
                self:_AddPresetsTab()
                is_first_frame = false
            end
            self:_RenderLoop()
        end
        wait(0.01)
    end
end

--================================================================
--[[ PRIVATE: INTERNAL ELEMENT CREATORS ]]
--================================================================

function Library:_Internal_CreateToggle(options)
    if self.UI.Values[options.id] == nil then
        self.UI.Values[options.id] = options.Default or false
    end
    local z = options.zIndex or 4
    local toggle = {
        id = options.id, type = "Toggle", Name = options.Name,
        Size = {width = 35, height = 20}, -- << ИЗМЕНЕНА ВЫСОТА
        HasSettings = options.HasSettings or false,
        HasColor = options.HasColor or false,
        Callback = options.Callback,
        Label = self:_CreateDrawingObject("Text"), Back = self:_CreateDrawingObject("Square"),
        Nub = self:_CreateDrawingObject("Circle"), ClickRegion = {}, SettingsClickRegion = {},
        SettingsIcon = nil,
        ColorCircle = nil,
        ColorBorder = nil,
        ColorClickRegion = {},
        CurrentBackColor = {0,0,0,0},
        CurrentNubColor = {0,0,0,0}
    }
    if toggle.HasColor and type(toggle.HasColor) == 'table' then
        if self.UI.Values[toggle.HasColor.id] == nil then
            self.UI.Values[toggle.HasColor.id] = toggle.HasColor.Default or {255, 255, 255, 255}
        end
        toggle.ColorCircle = self:_CreateDrawingObject("Circle")
        toggle.ColorBorder = self:_CreateDrawingObject("Circle")
        if toggle.ColorCircle then
            toggle.ColorCircle.Filled = true; toggle.ColorCircle.zIndex = z + 1; toggle.ColorCircle.Radius = 6;
        end
        if toggle.ColorBorder then
            toggle.ColorBorder.Filled = false; toggle.ColorBorder.Thickness = 1; toggle.ColorBorder.zIndex = z + 2; toggle.ColorBorder.Radius = 7;
        end
    end
    if toggle.HasSettings then
        toggle.SettingsIcon = self:_CreateDrawingObject("Image")
        if toggle.SettingsIcon then
            toggle.SettingsIcon.Url = "https://s6.imgcdn.dev/Y4Skk8.png"
            toggle.SettingsIcon.Size = {16, 16}
            toggle.SettingsIcon.zIndex = z + 1
        end
    end
    if toggle.Label then
        toggle.Label.Font = self.ActiveTheme.Fonts.Main; toggle.Label.Size = self.ActiveTheme.Fonts.Size + 2; toggle.Label.Text = toggle.Name; toggle.Label.Center = false; toggle.Label.Outline = false; toggle.Label.zIndex = z;
    end
    if toggle.Back then
        toggle.Back.Filled = true; toggle.Back.zIndex = z;
        toggle.Back.Rounding = 10; -- << ИЗМЕНЕНО СКРУГЛЕНИЕ (ВЫСОТА / 2) ДЛЯ ЭФФЕКТА КАПСУЛЫ
    end
    if toggle.Nub then
        toggle.Nub.Filled = true; toggle.Nub.zIndex = z + 1;
        toggle.Nub.Radius = 8; -- << ИЗМЕНЕН РАДИУС, ЧТОБЫ КРУЖОК БЫЛ ВНУТРИ
    end
    return toggle
end

function Library:_Internal_CreateSlider(options)
    if self.UI.Values[options.id] == nil then
        self.UI.Values[options.id] = options.Default or options.Min or 0
    end
    local z = options.zIndex or 4
    local slider = {
        id = options.id, type = "Slider", Name = options.Name, Min = options.Min or 0, Max = options.Max or 100,
        Increment = options.Increment or 1, IsDragging = false, Callback = options.Callback,
        Label = self:_CreateDrawingObject("Text"), Back = self:_CreateDrawingObject("Square"),
        LeftFill = self:_CreateDrawingObject("Square"),
        -- RightFill = self:_CreateDrawingObject("Square"), -- Элемент RightFill больше не нужен
        Nub = self:_CreateDrawingObject("Circle"), ValueText = self:_CreateDrawingObject("Text"),
        ClickRegion = {}, Glow = self:_Internal_CreateGlowSet(z),
        CurrentNubColor = {0,0,0,0}, CurrentFillColor = {0,0,0,0}
    }
    if slider.Label then slider.Label.Font = self.ActiveTheme.Fonts.Main; slider.Label.Size = self.ActiveTheme.Fonts.Size + 2; slider.Label.Text = slider.Name; slider.Label.Center = false; slider.Label.Outline = false; slider.Label.zIndex = z; end
    if slider.Back then slider.Back.Filled = true; slider.Back.zIndex = z; slider.Back.Rounding = 1; end
    if slider.LeftFill then slider.LeftFill.Filled = true; slider.LeftFill.zIndex = z + 1; slider.LeftFill.Rounding = 1; end
    -- if slider.RightFill then slider.RightFill.Filled = true; slider.RightFill.zIndex = z + 1; slider.RightFill.Rounding = 1; end -- И его настройка тоже
    if slider.Nub then slider.Nub.Filled = true; slider.Nub.zIndex = z + 2; slider.Nub.Radius = 8; end
    if slider.ValueText then slider.ValueText.Font = self.ActiveTheme.Fonts.Main; slider.ValueText.Size = self.ActiveTheme.Fonts.Size; slider.ValueText.Center = false; slider.ValueText.Outline = false; slider.ValueText.zIndex = z; end
    return slider
end

function Library:_Internal_CreateDropdown(options)
    if self.UI.Values[options.id] == nil then
        self.UI.Values[options.id] = options.Default or options.Options[1]
    end
    local z = options.zIndex or 4
    local dropdown = {
        id = options.id, type = "Dropdown", Name = options.Name, Options = options.Options,
        IsOpen = false, IsClosing = false, FadeOpacity = 0.0,
        HoveredOptionIndex = 0,
        Size = options.Size or {width = 120, height = 25}, Callback = options.Callback,
        Label = self:_CreateDrawingObject("Text"), Button = self:_CreateDrawingObject("Square"),
        ButtonText = self:_CreateDrawingObject("Text"), OptionList = {},
        OptionBackground = self:_CreateDrawingObject("Square"), ArrowLine1 = self:_CreateDrawingObject("Line"),
        ArrowLine2 = self:_CreateDrawingObject("Line"), ClickRegion = {},
        Border = self:_CreateDrawingObject("Square"),
        Glow = self:_Internal_CreateGlowSet(z + 8),
        CurrentButtonColor = {0,0,0,0}
    }
    if dropdown.Label then dropdown.Label.Font = self.ActiveTheme.Fonts.Main; dropdown.Label.Size = self.ActiveTheme.Fonts.Size + 2; dropdown.Label.Text = dropdown.Name; dropdown.Label.Center = false; dropdown.Label.Outline = false; dropdown.Label.zIndex = z; end
    if dropdown.Button then dropdown.Button.Filled = true; dropdown.Button.zIndex = z; dropdown.Button.Rounding = self.ActiveTheme.Rounding.Element; end
    if dropdown.ButtonText then dropdown.ButtonText.Font = self.ActiveTheme.Fonts.Main; dropdown.ButtonText.Size = self.ActiveTheme.Fonts.Size + 3; dropdown.ButtonText.Text = self.UI.Values[dropdown.id]; dropdown.ButtonText.Center = false; dropdown.ButtonText.Outline = false; dropdown.ButtonText.zIndex = z + 1; end
    if dropdown.OptionBackground then dropdown.OptionBackground.Filled = true; dropdown.OptionBackground.zIndex = z + 9; dropdown.OptionBackground.Visible = false; dropdown.OptionBackground.Rounding = self.ActiveTheme.Rounding.Section; end
    if dropdown.ArrowLine1 then dropdown.ArrowLine1.Thickness = 2; dropdown.ArrowLine1.zIndex = z + 2; end
    if dropdown.ArrowLine2 then dropdown.ArrowLine2.Thickness = 2; dropdown.ArrowLine2.zIndex = z + 2; end
    if dropdown.Border then dropdown.Border.Filled = false; dropdown.Border.Thickness = 1; dropdown.Border.zIndex = z + 12; dropdown.Border.Visible = false; dropdown.Border.Rounding = self.ActiveTheme.Rounding.Section; end

    for i, option in ipairs(dropdown.Options) do
        local optionEntry = {
            Text = self:_CreateDrawingObject("Text"),
            Highlight = self:_CreateDrawingObject("Square"),
            ClickRegion = {}
        }
        if optionEntry.Text then optionEntry.Text.Font = self.ActiveTheme.Fonts.Main; optionEntry.Text.Size = self.ActiveTheme.Fonts.Size; optionEntry.Text.Text = option; optionEntry.Text.Center = false; optionEntry.Text.Outline = false; optionEntry.Text.zIndex = z + 11; optionEntry.Text.Visible = false; end
        if optionEntry.Highlight then optionEntry.Highlight.Filled = true; optionEntry.Highlight.zIndex = z + 10; optionEntry.Highlight.Visible = false; optionEntry.Highlight.Rounding = self.ActiveTheme.Rounding.Element; end
        table.insert(dropdown.OptionList, optionEntry)
    end
    return dropdown
end

function Library:_Internal_CreateMultidropdown(options)
    if self.UI.Values[options.id] == nil then
        self.UI.Values[options.id] = options.Default or {}
    end
    local z = options.zIndex or 4
    local multidropdown = {
        id = options.id, type = "Multidropdown", Name = options.Name, Options = options.Options,
        IsOpen = false, IsClosing = false, FadeOpacity = 0.0,
        HoveredOptionIndex = 0,
        Size = {width = 120, height = 25}, Callback = options.Callback,
        Label = self:_CreateDrawingObject("Text"), Button = self:_CreateDrawingObject("Square"),
        ButtonText = self:_CreateDrawingObject("Text"), OptionList = {},
        OptionBackground = self:_CreateDrawingObject("Square"), ArrowLine1 = self:_CreateDrawingObject("Line"),
        ArrowLine2 = self:_CreateDrawingObject("Line"), ClickRegion = {},
        Border = self:_CreateDrawingObject("Square"),
        Glow = self:_Internal_CreateGlowSet(z + 8),
        CurrentButtonColor = {0,0,0,0}
    }
    if multidropdown.Label then multidropdown.Label.Font = self.ActiveTheme.Fonts.Main; multidropdown.Label.Size = self.ActiveTheme.Fonts.Size + 2; multidropdown.Label.Text = multidropdown.Name; multidropdown.Label.Center = false; multidropdown.Label.Outline = false; multidropdown.Label.zIndex = z; end
    if multidropdown.Button then multidropdown.Button.Filled = true; multidropdown.Button.zIndex = z; multidropdown.Button.Rounding = self.ActiveTheme.Rounding.Element; end
    if multidropdown.ButtonText then multidropdown.ButtonText.Font = self.ActiveTheme.Fonts.Main; multidropdown.ButtonText.Size = self.ActiveTheme.Fonts.Size + 3; multidropdown.ButtonText.Text = ""; multidropdown.ButtonText.Center = false; multidropdown.ButtonText.Outline = false; multidropdown.ButtonText.zIndex = z + 1; end
    if multidropdown.OptionBackground then multidropdown.OptionBackground.Filled = true; multidropdown.OptionBackground.zIndex = z + 9; multidropdown.OptionBackground.Visible = false; multidropdown.OptionBackground.Rounding = self.ActiveTheme.Rounding.Section; end
    if multidropdown.ArrowLine1 then multidropdown.ArrowLine1.Thickness = 2; multidropdown.ArrowLine1.zIndex = z + 2; end
    if multidropdown.ArrowLine2 then multidropdown.ArrowLine2.Thickness = 2; multidropdown.ArrowLine2.zIndex = z + 2; end
    if multidropdown.Border then multidropdown.Border.Filled = false; multidropdown.Border.Thickness = 1; multidropdown.Border.zIndex = z + 12; multidropdown.Border.Visible = false; multidropdown.Border.Rounding = self.ActiveTheme.Rounding.Section; end

    for i, option in ipairs(multidropdown.Options) do
        local optionEntry = {
            Text = self:_CreateDrawingObject("Text"),
            Highlight = self:_CreateDrawingObject("Square"),
            CheckmarkLine1 = self:_CreateDrawingObject("Line"), -- << ДОБАВЛЕНО
            CheckmarkLine2 = self:_CreateDrawingObject("Line"), -- << ДОБАВЛЕНО
            ClickRegion = {}
        }
        if optionEntry.Text then optionEntry.Text.Font = self.ActiveTheme.Fonts.Main; optionEntry.Text.Size = self.ActiveTheme.Fonts.Size; optionEntry.Text.Text = option; optionEntry.Text.Center = false; optionEntry.Text.Outline = false; optionEntry.Text.zIndex = z + 11; optionEntry.Text.Visible = false; end
        if optionEntry.Highlight then optionEntry.Highlight.Filled = true; optionEntry.Highlight.zIndex = z + 10; optionEntry.Highlight.Visible = false; optionEntry.Highlight.Rounding = self.ActiveTheme.Rounding.Element; end
        -- << НАСТРОЙКА ГАЛОЧКИ >>
        if optionEntry.CheckmarkLine1 then optionEntry.CheckmarkLine1.Thickness = 2; optionEntry.CheckmarkLine1.zIndex = z + 12; optionEntry.CheckmarkLine1.Visible = false; end
        if optionEntry.CheckmarkLine2 then optionEntry.CheckmarkLine2.Thickness = 2; optionEntry.CheckmarkLine2.zIndex = z + 12; optionEntry.CheckmarkLine2.Visible = false; end
        table.insert(multidropdown.OptionList, optionEntry)
    end
    return multidropdown
end

function Library:_Internal_CreateKeybind(options)
    if self.UI.Values[options.id] == nil then
        self.UI.Values[options.id] = options.Default or "none"
    end
    local z = options.zIndex or 4
    local keybind = {
        id = options.id,
        type = "Keybind",
        Name = options.Name,
        Label = self:_CreateDrawingObject("Text"), -- << ДОБАВЛЕНО
        Size = {width = 100, height = 25},
        Callback = options.Callback,
        Button = self:_CreateDrawingObject("Square"),
        Border = self:_CreateDrawingObject("Square"),
        ButtonText = self:_CreateDrawingObject("Text"),
        IsListening = false,
        ClickRegion = {}
    }
    if keybind.Label then -- << ДОБАВЛЕН БЛОК
        keybind.Label.Font = self.ActiveTheme.Fonts.Main; keybind.Label.Size = self.ActiveTheme.Fonts.Size + 2; keybind.Label.Text = keybind.Name; keybind.Label.Center = false; keybind.Label.Outline = false; keybind.Label.zIndex = z;
    end
    if keybind.Button then
        keybind.Button.Filled = true; keybind.Button.zIndex = z; keybind.Button.Rounding = self.ActiveTheme.Rounding.Element;
    end
    if keybind.Border then
        keybind.Border.Filled = false; keybind.Border.Thickness = 1; keybind.Border.zIndex = z + 1; keybind.Border.Rounding = self.ActiveTheme.Rounding.Element;
    end
    if keybind.ButtonText then
        keybind.ButtonText.Font = self.ActiveTheme.Fonts.Main; keybind.ButtonText.Size = self.ActiveTheme.Fonts.Size; keybind.ButtonText.Text = self.UI.Values[keybind.id]; keybind.ButtonText.Center = true; keybind.ButtonText.Outline = false; keybind.ButtonText.zIndex = z + 1;
    end
    return keybind
end

--================================================================
--[[ PUBLIC API ]]
--================================================================

function Library:Tab(options)
    local tabGroupName = options.Group
    local tabName = options.Name

    local existingGroup; for _, group in ipairs(self.UI.TabGroups) do if group.Name == tabGroupName then existingGroup = group; break end end

    if not existingGroup then
        existingGroup = { Name = tabGroupName, Header = self:_CreateDrawingObject("Text"), Tabs = {} }
        if existingGroup.Header then existingGroup.Header.Font = self.ActiveTheme.Fonts.Main; existingGroup.Header.Size = self.ActiveTheme.Fonts.TabHeaderSize; existingGroup.Header.Text = existingGroup.Name; existingGroup.Header.Center = false; existingGroup.Header.Outline = false; existingGroup.Header.zIndex = 3; end
        table.insert(self.UI.TabGroups, existingGroup)
    end

    local tab_obj = {
        Name = tabName,
        Text = self:_CreateDrawingObject("Text"),
        Icon = nil,
        ClickRegion = {},
        --[[ НОВОЕ: Персональный объект подсветки для вкладки ]]
        Highlight = self:_CreateDrawingObject("Square")
    }
    if tab_obj.Highlight then
        tab_obj.Highlight.Filled = true
        tab_obj.Highlight.zIndex = 2
        tab_obj.Highlight.Rounding = self.ActiveTheme.Rounding.Element + 3
        tab_obj.Highlight.Visible = true -- Он всегда видим, но может быть прозрачным
    end
    if tab_obj.Text then tab_obj.Text.Font = self.ActiveTheme.Fonts.Main; tab_obj.Text.Size = self.ActiveTheme.Fonts.TabSize; tab_obj.Text.Text = tabName; tab_obj.Text.Center = false; tab_obj.Text.Outline = false; tab_obj.Text.zIndex = 3; end
    if options.Icon then tab_obj.Icon = self:_CreateDrawingObject("Image"); if tab_obj.Icon then tab_obj.Icon.Url = options.Icon; tab_obj.Icon.Size = {self.ActiveTheme.IconSize, self.ActiveTheme.IconSize}; tab_obj.Icon.zIndex = 3; end end

    if self.Window.ActiveTab == "" then self.Window.ActiveTab = tabName end
    table.insert(existingGroup.Tabs, tab_obj)

    local self_lib = self
    local TabObject = {};
    function TabObject:Section(sectionOptions) sectionOptions.ParentTab = tabName; return self_lib:Section(sectionOptions) end
    return TabObject
end

function Library:Section(options)
    local section = {
        Title = options.Name, ParentTab = options.ParentTab, Side = options.Side or "Left", Elements = {},
        Drawing = { Background = self:_CreateDrawingObject("Square"), Border = self:_CreateDrawingObject("Square"), Title = self:_CreateDrawingObject("Text"), Separator = self:_CreateDrawingObject("Line") }
    }
    -- Настройка объектов отрисовки для секции [cite: 46, 47, 125]
    if section.Drawing.Background then section.Drawing.Background.Filled = true; section.Drawing.Background.zIndex = 2; section.Drawing.Background.Rounding = self.ActiveTheme.Rounding.Section; end
    if section.Drawing.Border then section.Drawing.Border.Filled = false; section.Drawing.Border.Thickness = 1; section.Drawing.Border.zIndex = 3; section.Drawing.Border.Rounding = self.ActiveTheme.Rounding.Section; end
    if section.Drawing.Title then section.Drawing.Title.Font = self.ActiveTheme.Fonts.Main; section.Drawing.Title.Size = self.ActiveTheme.Fonts.Size + 10; section.Drawing.Title.Text = section.Title; section.Drawing.Title.Center = false; section.Drawing.Title.Outline = false; section.Drawing.Title.zIndex = 4; end
    if section.Drawing.Separator then section.Drawing.Separator.Thickness = 2; section.Drawing.Separator.zIndex = 3; end

    table.insert(self.UI.Sections, section)

    local self_lib = self
    local SectionObject = {}
    local last_element = nil -- Ссылка на последний добавленный элемент для цепочки 

    -- Создаем объект для цепочки вызовов после Toggle 
    local function CreateToggleChain(toggle_element)
        local chain = {}
        function chain:Keybind(keybindOptions)
            local keybind_element = self_lib:_Internal_CreateKeybind(keybindOptions)
            -- Привязываем keybind к toggle
            if not toggle_element.SettingsElements then toggle_element.SettingsElements = {} end
            table.insert(toggle_element.SettingsElements, keybind_element)

            -- Логика обработки нажатия на бинд
            local original_keybind_callback = keybindOptions.Callback
            keybind_element.Callback = function()
                if original_keybind_callback then
                    -- Если у бинда есть своя функция, вызываем её
                    original_keybind_callback()
                else
                    -- Иначе, переключаем родительский Toggle
                    self_lib.UI.Values[toggle_element.id] = not self_lib.UI.Values[toggle_element.id]
                    if toggle_element.Callback then
                        toggle_element.Callback(self_lib.UI.Values[toggle_element.id])
                    end
                end
            end

            return SectionObject -- Возвращаем объект секции для продолжения цепочки
        end
        return chain
    end

    function SectionObject:Toggle(toggleOptions)
        last_element = self_lib:_Internal_CreateToggle(toggleOptions)
        table.insert(section.Elements, last_element)
        -- ИСПРАВЛЕНИЕ: Вместо того чтобы возвращать ТОЛЬКО цепочку для Keybind,
        -- мы возвращаем саму секцию, чтобы можно было вызывать другие методы.
        -- А метод Keybind добавляем прямо в объект секции, но он будет работать
        -- только с последним созданным Toggle.
        function SectionObject:Keybind(keybindOptions)
            if last_element and last_element.type == "Toggle" then
                return CreateToggleChain(last_element):Keybind(keybindOptions)
            end
            -- Если последний элемент не Toggle, просто продолжаем цепочку
            return SectionObject
        end
        return SectionObject
    end

    function SectionObject:Slider(sliderOptions) table.insert(section.Elements, self_lib:_Internal_CreateSlider(sliderOptions)); return SectionObject end
    function SectionObject:Dropdown(dropdownOptions) table.insert(section.Elements, self_lib:_Internal_CreateDropdown(dropdownOptions)); return SectionObject end
    function SectionObject:Multidropdown(multidropdownOptions) table.insert(section.Elements, self_lib:_Internal_CreateMultidropdown(multidropdownOptions)); return SectionObject end

    return SectionObject
end

function Library:Unload()
    self.Window.Visible = false
    for _, obj in ipairs(self.UI.DrawingObjects) do if obj and obj.Remove then pcall(obj.Remove, obj) end end
    self.UI.DrawingObjects = {}; print(SCRIPT_PREFIX .. "UI Unloaded.")
end

function Library:Create()
    self:_InitializeCoreUI()
    setmetatable(self.AnimationState, {__mode = "k"}) -- Делаем ключи слабыми для авто-очистки
    
    -- Config System Initialization
    if not checkfolder(self.ConfigFolderPath) then
        makefolder(self.ConfigFolderPath)
        print(SCRIPT_PREFIX .. "Created config folder: " .. self.ConfigFolderPath)
    end
    
    local files = listfiles(self.ConfigFolderPath)
    if not files or #files == 0 then
        print(SCRIPT_PREFIX .. "No configs found. Creating 'default.cfg'...")
        self:_SaveConfig("default")
    end

    self:_RefreshConfigList()
    if self.UI.Core.ConfigsTab.Items[1] then
        self:_LoadConfig(self.UI.Core.ConfigsTab.Items[1].Name)
    end

    spawn(function() self:_MainLoop() end)
    return self
end

function Library:ToggleVisibility()
    -- Не прерываем текущую анимацию
    if self.GlobalAnimation.IsHiding or self.GlobalAnimation.IsShowing then return end

    if self.GlobalAnimation.Opacity == 1 then
        self.GlobalAnimation.IsHiding = true
    else
        self.GlobalAnimation.Opacity = 0 -- Убеждаемся, что начинаем с нуля
        self.Window.Visible = true      -- ВАЖНО: запускаем рендер-цикл для анимации появления
        self.GlobalAnimation.IsShowing = true
    end
end

function Library:_CheckGlobalBinds()
    if self.UI.Popups.ColorPicker.IsOpen or self.UI.Popups.EditStyle.IsOpen then
        return -- Не обрабатываем глобальные бинды, если открыты окна-попапы
    end
    
    local key = getpressedkey()
    if key and key ~= "None" and key == self.UI.Values["ToggleUIBind"] then
        -- Защита от многократного срабатывания при зажатии
        if (tick() - self.lastUIToggleTime) > 0.3 then
            self:ToggleVisibility()
            self.lastUIToggleTime = tick()
        end
    end
end

return Library
